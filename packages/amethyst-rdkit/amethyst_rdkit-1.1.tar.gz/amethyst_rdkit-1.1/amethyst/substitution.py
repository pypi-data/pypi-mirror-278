import itertools
from typing import List, Optional, Union

from loguru import logger
from rdkit.Chem.AllChem import MolFromSmiles, MolToSmiles, ReplaceSubstructs
from rdkit.Chem.rdchem import Mol
from rdkit.Chem.rdmolops import SanitizeMol, molzipFragments
from rdkit.Chem.rdRGroupDecomposition import RelabelMappedDummies, RGroupLabelling

from amethyst.io import Substituents
from amethyst.utils import mols_to_str


# REVIEW - Do I need this. Can just use RelabelMappedDummies to change them into atom maps.
def placeholder_atom_sub(
    core_mol: Mol,
    placeholder_atom: str,
    r_groups: Union[List[str], List[Mol]],
    inner: bool = False,
) -> List[Mol]:
    mols = []
    core_dummy_idx = core_mol.GetSubstructMatch(MolFromSmiles(placeholder_atom))

    if type(r_groups[0]) == Mol:
        for i in r_groups:
            mod_mol = ReplaceSubstructs(
                core_mol,
                MolFromSmiles(placeholder_atom),
                i,
                replaceAll=True,
                replacementConnectionPoint=(0 if not inner else core_dummy_idx),
            )
            logger.debug(f"Generated SMILES: {MolToSmiles(mod_mol[0])}")
            SanitizeMol(mod_mol[0])
            mols.append(mod_mol[0])
    else:
        for i in r_groups:
            mod_mol = ReplaceSubstructs(
                core_mol,
                MolFromSmiles(placeholder_atom),
                MolFromSmiles(i),
                replaceAll=True,
                replacementConnectionPoint=(0 if not inner else core_dummy_idx),
            )
            logger.debug(f"Generated SMILES: {MolToSmiles(mod_mol[0])}")
            SanitizeMol(mod_mol[0])
            mols.append(mod_mol[0])
    return mols


# Checks:
# - actually use molzip with relabelMappedDummies
# - insertion of Mol's at right indices
# - if it works with rdRGroupDecomposition output
# -- https://www.rdkit.org/docs/source/rdkit.Chem.rdRGroupDecomposition.html#rdkit.Chem.rdRGroupDecomposition.RGroupDecompositionParameters
def general_sub(
    core_mol: Mol, subs: List[Substituents], relabelled: Optional[bool] = True
) -> List[Mol]:
    """Combines two molecules with atom maps as attachment points.

    Args:
        core_mol (Mol): Scaffold, R attachment points have to be labelled in atom map format - [*:#], if not set relabelled to Flase.
        subs (List[Substituents]): R-groups
        relabelled (Optional[Bool]): If the supplied core is relabelled to have atom maps as attachment points. Substituents generated by io module are automatically relabelled. Defaults to True.

    Returns:
        List[Mol]: _description_
    """
    if relabelled:
        pass
    else:
        RelabelMappedDummies(core_mol, outputLabels=RGroupLabelling.AtomMap)
        logger.debug(f"Relabelled core: {MolToSmiles(core_mol)}")
    r_groups: List[List[Mol]] = [x.subs for x in subs]
    combinations: List[List[Mol]] = [x for x in itertools.product(*r_groups)]
    logger.debug([[MolToSmiles(x) for x in y] for y in combinations])
    output_mols: List[Mol] = []

    for sets in combinations:
        temp = [core_mol, *sets]
        logger.debug(f"Output mols: {mols_to_str(output_mols)}")
        logger.debug(f"Temp: {mols_to_str(temp)}")
        logger.debug(f"Current sub: {mols_to_str(temp)}")
        sub_mol = molzipFragments(temp)
        output_mols.append(sub_mol)
    logger.debug(f"Generated SMILES: {mols_to_str(output_mols)}")

    return output_mols
