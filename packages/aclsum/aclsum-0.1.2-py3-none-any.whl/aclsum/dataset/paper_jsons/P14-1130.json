{
    "paper_id": "P14-1130",
    "header": {
        "generated_with": "S2ORC 1.0.0",
        "date_generated": "2023-06-16T12:16:21.933141Z"
    },
    "title": "Low-Rank Tensors for Scoring Dependency Structures",
    "authors": [
        {
            "first": "Tao",
            "middle": [],
            "last": "Lei",
            "suffix": "",
            "affiliation": {},
            "email": "taolei@csail.mit.edu"
        },
        {
            "first": "Yu",
            "middle": [],
            "last": "Xin",
            "suffix": "",
            "affiliation": {},
            "email": "yuxin@csail.mit.edu"
        },
        {
            "first": "Yuan",
            "middle": [],
            "last": "Zhang",
            "suffix": "",
            "affiliation": {},
            "email": "yuanzh@csail.mit.edu"
        },
        {
            "first": "Regina",
            "middle": [],
            "last": "Barzilay",
            "suffix": "",
            "affiliation": {},
            "email": "regina@csail.mit.edu"
        },
        {
            "first": "Tommi",
            "middle": [],
            "last": "Jaakkola",
            "suffix": "",
            "affiliation": {},
            "email": ""
        }
    ],
    "year": "",
    "venue": null,
    "identifiers": {},
    "abstract": "Accurate scoring of syntactic structures such as head-modifier arcs in dependency parsing typically requires rich, highdimensional feature representations. A small subset of such features is often selected manually. This is problematic when features lack clear linguistic meaning as in embeddings or when the information is blended across features. In this paper, we use tensors to map high-dimensional feature vectors into low dimensional representations. We explicitly maintain the parameters as a low-rank tensor to obtain low dimensional representations of words in their syntactic roles, and to leverage modularity in the tensor for easy training with online algorithms. Our parser consistently outperforms the Turbo and MST parsers across 14 different languages. We also obtain the best published UAS results on 5 languages. 1 ",
    "pdf_parse": {
        "paper_id": "P14-1130",
        "_pdf_hash": "",
        "abstract": [
            {
                "text": "Accurate scoring of syntactic structures such as head-modifier arcs in dependency parsing typically requires rich, highdimensional feature representations. A small subset of such features is often selected manually. This is problematic when features lack clear linguistic meaning as in embeddings or when the information is blended across features. In this paper, we use tensors to map high-dimensional feature vectors into low dimensional representations. We explicitly maintain the parameters as a low-rank tensor to obtain low dimensional representations of words in their syntactic roles, and to leverage modularity in the tensor for easy training with online algorithms. Our parser consistently outperforms the Turbo and MST parsers across 14 different languages. We also obtain the best published UAS results on 5 languages. 1 ",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Abstract",
                "sec_num": null
            }
        ],
        "body_text": [
            {
                "text": "Finding an expressive representation of input sentences is crucial for accurate parsing. Syntactic relations manifest themselves in a broad range of surface indicators, ranging from morphological to lexical, including positional and part-of-speech (POS) tagging features. Traditionally, parsing research has focused on modeling the direct connection between the features and the predicted syntactic relations such as head-modifier (arc) relations in dependency parsing. Even in the case of firstorder parsers, this results in a high-dimensional vector representation of each arc. Discrete features, and their cross products, can be further complemented with auxiliary information about words participating in an arc, such as continuous vector representations of words. The exploding dimensionality of rich feature vectors must then be balanced with the difficulty of effectively learning the associated parameters from limited training data.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "A predominant way to counter the high dimensionality of features is to manually design or select a meaningful set of feature templates, which are used to generate different types of features (Mc-Donald et al., 2005a; Koo and Collins, 2010; Martins et al., 2013) . Direct manual selection may be problematic for two reasons. First, features may lack clear linguistic interpretation as in distributional features or continuous vector embeddings of words. Second, designing a small subset of templates (and features) is challenging when the relevant linguistic information is distributed across the features. For instance, morphological properties are closely tied to part-of-speech tags, which in turn relate to positional features. These features are not redundant. Therefore, we may suffer a performance loss if we select only a small subset of the features. On the other hand, by including all the rich features, we face over-fitting problems.",
                "cite_spans": [
                    {
                        "start": 191,
                        "end": 216,
                        "text": "(Mc-Donald et al., 2005a;",
                        "ref_id": null
                    },
                    {
                        "start": 217,
                        "end": 239,
                        "text": "Koo and Collins, 2010;",
                        "ref_id": null
                    },
                    {
                        "start": 240,
                        "end": 261,
                        "text": "Martins et al., 2013)",
                        "ref_id": "BIBREF23"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "We depart from this view and leverage highdimensional feature vectors by mapping them into low dimensional representations. We begin by representing high-dimensional feature vectors as multi-way cross-products of smaller feature vectors that represent words and their syntactic relations (arcs). The associated parameters are viewed as a tensor (multi-way array) of low rank, and optimized for parsing performance. By explicitly representing the tensor in a low-rank form, we have direct control over the effective dimensionality of the set of parameters. We obtain role-dependent low-dimensional representations for words (head, modifier) that are specifically tailored for parsing accuracy, and use standard online algorithms for optimizing the low-rank tensor components.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "The overall approach has clear linguistic and computational advantages:",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "\u2022 Our low dimensional embeddings are tailored to the syntactic context of words (head, modifier) . This low dimensional syntactic abstraction can be thought of as a proxy to manually constructed POS tags.",
                "cite_spans": [
                    {
                        "start": 80,
                        "end": 96,
                        "text": "(head, modifier)",
                        "ref_id": null
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "\u2022 By automatically selecting a small number of dimensions useful for parsing, we can leverage a wide array of (correlated) features. Unlike parsers such as MST, we can easily benefit from auxiliary information (e.g., word vectors) appended as features.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "We implement the low-rank factorization model in the context of first-and third-order dependency parsing. The model was evaluated on 14 languages, using dependency data from CoNLL 2008 and CoNLL 2006. We compare our results against the MST (McDonald et al., 2005a) and Turbo (Martins et al., 2013) parsers. The low-rank parser achieves average performance of 89.08% across 14 languages, compared to 88.73% for the Turbo parser, and 87.19% for MST. The power of the low-rank model becomes evident in the absence of any part-of-speech tags. For instance, on the English dataset, the low-rank model trained without POS tags achieves 90.49% on first-order parsing, while the baseline gets 86.70% if trained under the same conditions, and 90.58% if trained with 12 core POS tags. Finally, we demonstrate that the model can successfully leverage word vector representations, in contrast to the baselines.",
                "cite_spans": [
                    {
                        "start": 236,
                        "end": 264,
                        "text": "MST (McDonald et al., 2005a)",
                        "ref_id": null
                    },
                    {
                        "start": 269,
                        "end": 297,
                        "text": "Turbo (Martins et al., 2013)",
                        "ref_id": null
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Introduction",
                "sec_num": "1"
            },
            {
                "text": "Selecting Features for Dependency Parsing A great deal of parsing research has been dedicated to feature engineering (Lazaridou et al., 2013; Marton et al., 2010; Marton et al., 2011) . While in most state-of-the-art parsers, features are selected manually (McDonald et al., 2005a; McDonald et al., 2005b; Koo and Collins, 2010; Martins et al., 2013; Zhang and McDonald, 2012a; Rush and Petrov, 2012a) , automatic feature selection methods are gaining popularity (Martins et al., 2011b; Ballesteros and Nivre, 2012; Nilsson and Nugues, 2010; Ballesteros, 2013) . Following standard machine learning practices, these algorithms iteratively select a subset of features by optimizing parsing performance on a development set. These feature selection methods are particularly promising in parsing scenarios where the optimal feature set is likely to be a small subset of the original set of candidate features. Our technique, in contrast, is suitable for cases where the relevant information is distributed across a larger set of related features.",
                "cite_spans": [
                    {
                        "start": 117,
                        "end": 141,
                        "text": "(Lazaridou et al., 2013;",
                        "ref_id": "BIBREF17"
                    },
                    {
                        "start": 142,
                        "end": 162,
                        "text": "Marton et al., 2010;",
                        "ref_id": "BIBREF24"
                    },
                    {
                        "start": 163,
                        "end": 183,
                        "text": "Marton et al., 2011)",
                        "ref_id": "BIBREF25"
                    },
                    {
                        "start": 257,
                        "end": 281,
                        "text": "(McDonald et al., 2005a;",
                        "ref_id": null
                    },
                    {
                        "start": 282,
                        "end": 305,
                        "text": "McDonald et al., 2005b;",
                        "ref_id": null
                    },
                    {
                        "start": 306,
                        "end": 328,
                        "text": "Koo and Collins, 2010;",
                        "ref_id": null
                    },
                    {
                        "start": 329,
                        "end": 350,
                        "text": "Martins et al., 2013;",
                        "ref_id": "BIBREF23"
                    },
                    {
                        "start": 351,
                        "end": 377,
                        "text": "Zhang and McDonald, 2012a;",
                        "ref_id": null
                    },
                    {
                        "start": 378,
                        "end": 401,
                        "text": "Rush and Petrov, 2012a)",
                        "ref_id": null
                    },
                    {
                        "start": 463,
                        "end": 486,
                        "text": "(Martins et al., 2011b;",
                        "ref_id": null
                    },
                    {
                        "start": 487,
                        "end": 515,
                        "text": "Ballesteros and Nivre, 2012;",
                        "ref_id": "BIBREF0"
                    },
                    {
                        "start": 516,
                        "end": 541,
                        "text": "Nilsson and Nugues, 2010;",
                        "ref_id": "BIBREF30"
                    },
                    {
                        "start": 542,
                        "end": 560,
                        "text": "Ballesteros, 2013)",
                        "ref_id": "BIBREF1"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Related Work",
                "sec_num": "2"
            },
            {
                "text": "Embedding for Dependency Parsing A lot of recent work has been done on mapping words into vector spaces (Collobert and Weston, 2008; Turian et al., 2010; Dhillon et al., 2011; Mikolov et al., 2013) . Traditionally, these vector representations have been derived primarily from co-occurrences of words within sentences, ignoring syntactic roles of the co-occurring words. Nevertheless, any such word-level representation can be used to offset inherent sparsity problems associated with full lexicalization (Cirik and S \u00b8ensoy, 2013) . In this sense they perform a role similar to POS tags.",
                "cite_spans": [
                    {
                        "start": 104,
                        "end": 132,
                        "text": "(Collobert and Weston, 2008;",
                        "ref_id": "BIBREF7"
                    },
                    {
                        "start": 133,
                        "end": 153,
                        "text": "Turian et al., 2010;",
                        "ref_id": "BIBREF40"
                    },
                    {
                        "start": 154,
                        "end": 175,
                        "text": "Dhillon et al., 2011;",
                        "ref_id": "BIBREF10"
                    },
                    {
                        "start": 176,
                        "end": 197,
                        "text": "Mikolov et al., 2013)",
                        "ref_id": "BIBREF29"
                    },
                    {
                        "start": 505,
                        "end": 531,
                        "text": "(Cirik and S \u00b8ensoy, 2013)",
                        "ref_id": "BIBREF4"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Related Work",
                "sec_num": "2"
            },
            {
                "text": "Word-level vector space embeddings have so far had limited impact on parsing performance. From a computational perspective, adding nonsparse vectors directly as features, including their combinations, can significantly increase the number of active features for scoring syntactic structures (e.g., dependency arc). Because of this issue, Cirik and S \u00b8ensoy (2013) used word vectors only as unigram features (without combinations) as part of a shift reduce parser (Nivre et al., 2007) . The improvement on the overall parsing performance was marginal. Another application of word vectors is compositional vector grammar (Socher et al., 2013) . While this method learns to map word combinations into vectors, it builds on existing word-level vector representations. In contrast, we represent words as vectors in a manner that is directly optimized for parsing. This framework enables us to learn new syntactically guided embeddings while also leveraging separately estimated word vectors as starting features, leading to improved parsing performance.",
                "cite_spans": [
                    {
                        "start": 338,
                        "end": 363,
                        "text": "Cirik and S \u00b8ensoy (2013)",
                        "ref_id": "BIBREF4"
                    },
                    {
                        "start": 463,
                        "end": 483,
                        "text": "(Nivre et al., 2007)",
                        "ref_id": "BIBREF32"
                    },
                    {
                        "start": 619,
                        "end": 640,
                        "text": "(Socher et al., 2013)",
                        "ref_id": "BIBREF35"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Related Work",
                "sec_num": "2"
            },
            {
                "text": "Dimensionality Reduction Many machine learning problems can be cast as matrix problems where the matrix represents a set of co-varying parameters. Such problems include, for example, multi-task learning and collaborative filtering. Rather than assuming that each parameter can be set independently of others, it is helpful to assume that the parameters vary in a low dimensional subspace that has to be estimated together with the parameters. In terms of the parameter matrix, this corresponds to a low-rank assumption. Low-rank constraints are commonly used for improving generalization (Lee and Seung, 1999; Srebro et al., 2003; Srebro et al., 2004; Evgeniou and Pontil, 2007) A strict low-rank assumption can be restrictive. Indeed, recent approaches to matrix problems decompose the parameter matrix as a sum of lowrank and sparse matrices (Tao and Yuan, 2011; Zhou and Tao, 2011) . The sparse matrix is used to highlight a small number of parameters that should vary independently even if most of them lie on a low-dimensional subspace (Waters et al., 2011; Chandrasekaran et al., 2011) . We follow this decomposition while extending the parameter matrix into a tensor.",
                "cite_spans": [
                    {
                        "start": 588,
                        "end": 609,
                        "text": "(Lee and Seung, 1999;",
                        "ref_id": "BIBREF18"
                    },
                    {
                        "start": 610,
                        "end": 630,
                        "text": "Srebro et al., 2003;",
                        "ref_id": "BIBREF36"
                    },
                    {
                        "start": 631,
                        "end": 651,
                        "text": "Srebro et al., 2004;",
                        "ref_id": "BIBREF37"
                    },
                    {
                        "start": 652,
                        "end": 678,
                        "text": "Evgeniou and Pontil, 2007)",
                        "ref_id": "BIBREF11"
                    },
                    {
                        "start": 844,
                        "end": 864,
                        "text": "(Tao and Yuan, 2011;",
                        "ref_id": "BIBREF39"
                    },
                    {
                        "start": 865,
                        "end": 884,
                        "text": "Zhou and Tao, 2011)",
                        "ref_id": "BIBREF46"
                    },
                    {
                        "start": 1041,
                        "end": 1062,
                        "text": "(Waters et al., 2011;",
                        "ref_id": "BIBREF41"
                    },
                    {
                        "start": 1063,
                        "end": 1091,
                        "text": "Chandrasekaran et al., 2011)",
                        "ref_id": "BIBREF3"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Related Work",
                "sec_num": "2"
            },
            {
                "text": "Tensors are multi-way generalizations of matrices and possess an analogous notion of rank. Tensors are increasingly used as tools in spectral estimation (Hsu and Kakade, 2013) , including in parsing (Cohen et al., 2012) and other NLP problems (de Cruys et al., 2013) , where the goal is to avoid local optima in maximum likelihood estimation. In contrast, we expand features for parsing into a multi-way tensor, and operate with an explicit low-rank representation of the associated parameter tensor. The explicit representation sidesteps inherent complexity problems associated with the tensor rank (Hillar and Lim, 2009) . Our parameters are divided into a sparse set corresponding to manually chosen MST or Turbo parser features and a larger set governed by a low-rank tensor.",
                "cite_spans": [
                    {
                        "start": 153,
                        "end": 175,
                        "text": "(Hsu and Kakade, 2013)",
                        "ref_id": "BIBREF14"
                    },
                    {
                        "start": 199,
                        "end": 219,
                        "text": "(Cohen et al., 2012)",
                        "ref_id": "BIBREF5"
                    },
                    {
                        "start": 243,
                        "end": 266,
                        "text": "(de Cruys et al., 2013)",
                        "ref_id": "BIBREF9"
                    },
                    {
                        "start": 600,
                        "end": 622,
                        "text": "(Hillar and Lim, 2009)",
                        "ref_id": "BIBREF13"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Related Work",
                "sec_num": "2"
            },
            {
                "text": "We will commence here by casting first-order dependency parsing as a tensor estimation problem. We will start by introducing the notation used in the paper, followed by a more formal description of our dependency parsing task.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Problem Formulation",
                "sec_num": "3"
            },
            {
                "text": "Let A \u2208 R n\u00d7n\u00d7d be a 3-dimensional tensor (a 3way array). We denote each element of the tensor as A i,j,k where i \u2208",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "[n], j \u2208 [n], k \u2208 [d] and [n] is a shorthand for the set of integers {1, 2, \u2022 \u2022 \u2022 , n}.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "Similarly, we use M i,j and u i to represent the elements of matrix M and vector u, respectively.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "We define the inner product of two tensors (or matrices) as A, B = vec(A) T vec(B), where vec(\u2022) concatenates the tensor (or matrix) elements into a column vector. The squared norm of a tensor/matrix is denoted by A2 = A, A .",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "The Kronecker product of three vectors is denoted by u \u2297 v \u2297 w and forms a rank-1 tensor such that",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "(u \u2297 v \u2297 w) i,j,k = u i v j w k .",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "Note that the vectors u, v, and w may be column or row vectors. Their orientation is defined based on usage. For example, u \u2297 v is a rank-1 matrix uv T when u and v are column vectors (u T v if they are row vectors). We say that tensor A is in Kruskal form if",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "EQUATION",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [
                    {
                        "start": 0,
                        "end": 8,
                        "text": "EQUATION",
                        "ref_id": "EQREF",
                        "raw_str": "A = r i=1 U (i, :) \u2297 V (i, :) \u2297 W (i, :)",
                        "eq_num": "(1)"
                    }
                ],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "where U, V \u2208 R r\u00d7n , W \u2208 R r\u00d7d and U (i, :) is the i th row of matrix U . We will directly learn a lowrank tensor A (because r is small) in this form as one of our model parameters.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Basic Notations",
                "sec_num": "3.1"
            },
            {
                "text": "Let x be a sentence and Y(x) the set of possible dependency trees over the words in x. We assume that the score S(x, y) of each candidate dependency tree y \u2208 Y(x) decomposes into a sum of \"local\" scores for arcs. Specifically:",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "S(x, y) = h\u2192m \u2208 y s(h \u2192 m) \u2200y \u2208 Y(x)",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "where h \u2192 m is the head-modifier dependency arc in the tree y. Each y is understood as a collection of arcs h \u2192 m where h and m index words in x. 2 For example, x(h) is the word corresponding to h. We suppress the dependence on x whenever it is clear from context. For example, s(h \u2192 m) can depend on x in complicated ways as discussed below. The predicted parse is obtained as \u0177 = arg max y\u2208Y(x) S(x, y).",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "A key problem is how we parameterize the arc scores s(h \u2192 m). Following the MST parser (McDonald et al., 2005a) we can define rich features characterizing each head-modifier arc, compiled into a sparse binary vector \u03c6 h\u2192m \u2208 R L that depends on the sentence x as well as the chosen arc h \u2192 m (again, we suppress the dependence on x). Based on this feature representation, we define the score of each arc as s \u03b8 (h \u2192 m) = Table 1 : Word feature templates used by our model. pos, form, lemma and morph stand for the fine POS tag, word form, word lemma and the morphology feature (provided in CoNLL format file) of the current word. There is a bias term that is always active for any word. The suffixes -p and -n refer to the left and right of the current word respectively. For example, pos-p means the POS tag to the left of the current word in the sentence.",
                "cite_spans": [
                    {
                        "start": 87,
                        "end": 111,
                        "text": "(McDonald et al., 2005a)",
                        "ref_id": null
                    }
                ],
                "ref_spans": [
                    {
                        "start": 426,
                        "end": 427,
                        "text": "1",
                        "ref_id": null
                    }
                ],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "\u03b8, \u03c6 h\u2192m where \u03b8 \u2208 R L represent adjustable parameters to be learned, and L is the number of parameters (and possible features in \u03c6 h\u2192m ).",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "We can alternatively specify arc features in terms of rank-1 tensors by taking the Kronecker product of simpler feature vectors associated with the head (vector \u03c6 h \u2208 R n ), and modifier (vector \u03c6 m \u2208 R n ), as well as the arc itself (vector \u03c6 h,m \u2208 R d ). Here \u03c6 h,m is much lower dimensional than the MST arc feature vector \u03c6 h\u2192m discussed earlier. For example, \u03c6 h,m may be composed of only indicators for binned arc lengths3 . \u03c6 h and \u03c6 m , on the other hand, are built from features shown in Table 1 . By taking the cross-product of all these component feature vectors, we obtain the full feature representation for arc h \u2192 m as a rank-1 tensor",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 503,
                        "end": 504,
                        "text": "1",
                        "ref_id": null
                    }
                ],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "\u03c6 h \u2297 \u03c6 m \u2297 \u03c6 h,m \u2208 R n\u00d7n\u00d7d",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "Note that elements of this rank-1 tensor include feature combinations that are not part of the feature crossings in \u03c6 h\u2192m . In this sense, the rank-1 tensor represents a substantial feature expansion. The arc score s tensor (h \u2192 m) associated with the tensor representation is defined analogously as",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "s tensor (h \u2192 m) = A, \u03c6 h \u2297 \u03c6 m \u2297 \u03c6 h,m",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "where the adjustable parameters A also form a tensor. Given the typical dimensions of the component feature vectors, \u03c6 h , \u03c6 m , \u03c6 h,m , it is not even possible to store all the parameters in A. Indeed, in the full English training set of CoNLL-2008, the tensor involves around 8 \u00d7 10 11 entries while the MST feature vector has approximately 1.5 \u00d7 10 7 features. To counter this feature explosion, we restrict the parameters A to have low rank.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "Low-Rank Dependency Scoring We can represent a rank-r tensor A explicitly in terms of parameter matrices U , V , and W as shown in Eq. 1. As a result, the arc score for the tensor reduces to evaluating U \u03c6 h , V \u03c6 m , and W \u03c6 h,m which are all r dimensional vectors and can be computed efficiently based on any sparse vectors \u03c6 h , \u03c6 m , and \u03c6 h,m . The resulting arc score",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "EQUATION",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [
                    {
                        "start": 0,
                        "end": 8,
                        "text": "EQUATION",
                        "ref_id": "EQREF",
                        "raw_str": "s tensor (h \u2192 m) is then r i=1 [U \u03c6 h ] i [V \u03c6 m ] i [W \u03c6 h,m ] i",
                        "eq_num": "(2)"
                    }
                ],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "By learning parameters U , V , and W that function well in dependency parsing, we also learn contextdependent embeddings for words and arcs. Specifically, U \u03c6 h (for a given sentence, suppressed) is an r dimensional vector representation of the word corresponding to h as a head word. Similarly, V \u03c6 m provides an analogous representation for a modifier m. Finally, W \u03c6 h,m is a vector embedding of the supplemental arc-dependent information. The resulting embedding is therefore tied to the syntactic roles of the words (and arcs), and learned in order to perform well in parsing.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "We expect a dependency parsing model to benefit from several aspects of the low-rank tensor scoring. For example, we can easily incorporate additional useful features in the feature vectors \u03c6 h , \u03c6 m and \u03c6 h,m , since the low-rank assumption (for small enough r) effectively counters the otherwise uncontrolled feature expansion. Moreover, by controlling the amount of information we can extract from each of the component feature vectors (via rank r), the statistical estimation problem does not scale dramatically with the dimensions of \u03c6 h , \u03c6 m and \u03c6 h,m . In particular, the low-rank constraint can help generalize to unseen arcs. Consider a feature \u03b4(x(h",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": ") = a) \u2022 \u03b4(x(m) = b) \u2022 \u03b4(dis(x, h, m) = c",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": ") which is non-zero only for an arc a \u2192 b with distance c in sentence x. If the arc has not been seen in the available training data, it does not contribute to the traditional arc score s \u03b8 (\u2022). In contrast, with the low-rank constraint, the arc score in Eq. 2 would typically be non-zero.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "Combined Scoring Our parsing model aims to combine the strengths of both traditional features from the MST/Turbo parser as well as the new low-rank tensor features. In this way, our model is able to capture a wide range of information including the auxiliary features without having uncontrolled feature explosion, while still having the full accessibility to the manually engineered features that are proven useful. Specifically, we define the arc score s \u03b3 (h \u2192 m) as the combination",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "EQUATION",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [
                    {
                        "start": 0,
                        "end": 8,
                        "text": "EQUATION",
                        "ref_id": "EQREF",
                        "raw_str": "(1 -\u03b3)s tensor (h \u2192 m) + \u03b3s \u03b8 (h \u2192 m) = (1 -\u03b3) r i=1 [U \u03c6 h ] i [V \u03c6 m ] i [W \u03c6 h,m ] i + \u03b3 \u03b8, \u03c6 h\u2192m",
                        "eq_num": "(3)"
                    }
                ],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "where \u03b8 \u2208 R L , U \u2208 R r\u00d7n , V \u2208 R r\u00d7n , and W \u2208 R r\u00d7d are the model parameters to be learned. The rank r and \u03b3 \u2208 [0, 1] (balancing the two scores) represent hyper-parameters in our model.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Dependency Parsing",
                "sec_num": "3.2"
            },
            {
                "text": "The training set D = {(x i , \u0177i )} N i=1 consists of N pairs, where each pair consists of a sentence x i and the corresponding gold (target) parse y i . The goal is to learn values for the parameters \u03b8, U , V and W that optimize the combined scoring function S \u03b3 (x, y) = h\u2192m\u2208y s \u03b3 (h \u2192 m), defined in Eq. 3, for parsing performance. We adopt a maximum soft-margin framework for this learning problem. Specifically, we find parameters \u03b8, U , V , W , and {\u03be i } that minimize",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "EQUATION",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [
                    {
                        "start": 0,
                        "end": 8,
                        "text": "EQUATION",
                        "ref_id": "EQREF",
                        "raw_str": "C i \u03be i + \u03b8 2 + U 2 + V 2 + W 2 s.t. S \u03b3 (x i , \u0177i ) \u2265 S \u03b3 (x i , y i ) + \u0177i -y i 1 -\u03be i \u2200y i \u2208 Y(x i ), \u2200i.",
                        "eq_num": "(4)"
                    }
                ],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "where \u0177i -y i 1 is the number of mismatched arcs between the two trees, and \u03be i is a non-negative slack variable. The constraints serve to separate the gold tree from other alternatives in Y(x i ) with a margin that increases with distance.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "The objective as stated is not jointly convex with respect to U , V and W due to our explicit representation of the low-rank tensor. However, if we fix any two sets of parameters, for example, if we fix V and W , then the combined score S \u03b3 (x, y) will be a linear function of both \u03b8 and U . As a result, the objective will be jointly convex with respect to \u03b8 and U and could be optimized using standard tools. However, to accelerate learning, we adopt an online learning setup. Specifically, we use the passive-aggressive learning algorithm (Crammer et al., 2006) tailored to our setting, updating pairs of parameter sets, (\u03b8, U ), (\u03b8, V ) and (\u03b8, W ) in an alternating manner. This method is described below.",
                "cite_spans": [
                    {
                        "start": 542,
                        "end": 564,
                        "text": "(Crammer et al., 2006)",
                        "ref_id": "BIBREF8"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "Online Learning In an online learning setup, we update parameters successively based on each sentence. In order to apply the passive-aggressive algorithm, we fix two of U , V and W (say, for example, V and W ) in an alternating manner, and apply a closed-form update to the remaining parameters (here U and \u03b8). This is possible since the objective function with respect to (\u03b8, U ) has a similar form as in the original passive-aggressive algorithm. To illustrate this, consider a training sentence x i . The update involves finding first the best competing tree, \u1ef9i = arg max",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "y i \u2208Y(x i ) S \u03b3 (x i , y i ) + \u0177i -y i 1 (5)",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "which is the tree that violates the constraint in Eq. 4 most (i.e. maximizes the loss \u03be i ). We then obtain parameter increments \u2206\u03b8 and \u2206U by solving min \u2206\u03b8, \u2206U, \u03be\u22650",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "1 2 \u2206\u03b8 2 + 1 2 \u2206U 2 + C\u03be s.t. S \u03b3 (x i , \u0177i ) \u2265 S \u03b3 (x i , \u1ef9i ) + \u0177i -\u1ef9i 1 -\u03be",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "In this way, the optimization problem attempts to keep the parameter change as small as possible, while forcing it to achieve mostly zero loss on this single instance. This problem has a closed form solution",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "\u2206\u03b8 = min C, loss \u03b3 2 d\u03b8 2 + (1 -\u03b3) 2 du 2 \u03b3d\u03b8 \u2206U = min C, loss \u03b3 2 d\u03b8 2 + (1 -\u03b3) 2 du 2 (1 -\u03b3)du where loss = S \u03b3 (x i , \u1ef9i ) + \u0177i -\u1ef9i 1 -S \u03b3 (x i , \u0177i ) d\u03b8 = h\u2192m \u2208 \u0177i \u03c6 h\u2192m - h\u2192m \u2208 \u1ef9i \u03c6 h\u2192m du = h\u2192m \u2208 \u0177i [(V \u03c6 m ) (W \u03c6 h,m )] \u2297 \u03c6 h - h\u2192m \u2208 \u1ef9i [(V \u03c6 m ) (W \u03c6 h,m )] \u2297 \u03c6 h",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "where (u v) i = u i v i is the Hadamard (elementwise) product. The magnitude of change of \u03b8 and U is controlled by the parameter C. By varying C, we can determine an appropriate step size for the online updates. The updates also illustrate how \u03b3 balances the effect of the MST component of the score relative to the low-rank tensor score. When \u03b3 = 0, the arc scores are entirely based on the lowrank tensor and \u2206\u03b8 = 0. Note that \u03c6 h , \u03c6 m , \u03c6 h,m , and \u03c6 h\u2192m are typically very sparse for each word or arc. Therefore du and d\u03b8 are also sparse and can be computed efficiently.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Learning",
                "sec_num": "4"
            },
            {
                "text": "The alternating online algorithm relies on how we initialize U , V , and W since each update is carried out in the context of the other two. A random initialization of these parameters is unlikely to work well, both due to the dimensions involved, and the nature of the alternating updates. We consider here instead a reasonable deterministic \"guess\" as the initialization method.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Initialization",
                "sec_num": null
            },
            {
                "text": "We begin by training our model without any low-rank parameters, and obtain parameters \u03b8. The majority of features in this MST component can be expressed as elements of the feature tensor, i.e., as [\u03c6 h \u2297 \u03c6 m \u2297 \u03c6 h,m ] i,j,k . We can therefore create a tensor representation of \u03b8 such that B i,j,k equals the corresponding parameter value in \u03b8. We use a low-rank version of B as the initialization. Specifically, we unfold the tensor B into a matrix B (h) of dimensions n and nd, where",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Initialization",
                "sec_num": null
            },
            {
                "text": "n = dim(\u03c6 h ) = dim(\u03c6 m ) and d = dim(\u03c6 h,m ).",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Initialization",
                "sec_num": null
            },
            {
                "text": "For instance, a rank-1 tensor can be unfolded as u \u2297 v \u2297 w = u \u2297 vec(v \u2297 w). We compute the top-r SVD of the resulting unfolded matrix such that B (h) = P T SQ. U is initialized as P . Each right singular vector S i Q(i, :) is also a matrix in R n\u00d7d . The leading left and right singular vectors of this matrix are assigned to V (i, :) and W (i, :) respectively. In our implementation, we run one epoch of our model without low-rank parameters and initialize the tensor A.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Initialization",
                "sec_num": null
            },
            {
                "text": "Parameter Averaging The passive-aggressive algorithm regularizes the increments (e.g. \u2206\u03b8 and \u2206U ) during each update but does not include any overall regularization. In other words, keeping updating the model may lead to large parameter values and over-fitting. To counter this effect, we use parameter averaging as used in the MST and Turbo parsers. The final parameters are those averaged across all the iterations (cf. (Collins, 2002) ). For simplicity, in our algorithm we average U , V , W and \u03b8 separately, which works well empirically.",
                "cite_spans": [
                    {
                        "start": 422,
                        "end": 437,
                        "text": "(Collins, 2002)",
                        "ref_id": "BIBREF6"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Initialization",
                "sec_num": null
            },
            {
                "text": "Datasets We test our dependency model on 14 languages, including the English dataset from CoNLL 2008 shared tasks and all 13 datasets from CoNLL 2006 shared tasks (Buchholz and Marsi, 2006; Surdeanu et al., 2008) . These datasets include manually annotated dependency trees, POS tags and morphological information. Following standard practices, we encode this information as features.",
                "cite_spans": [
                    {
                        "start": 163,
                        "end": 189,
                        "text": "(Buchholz and Marsi, 2006;",
                        "ref_id": "BIBREF2"
                    },
                    {
                        "start": 190,
                        "end": 212,
                        "text": "Surdeanu et al., 2008)",
                        "ref_id": "BIBREF38"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "Methods We compare our model to MST and Turbo parsers on non-projective dependency parsing. For our parser, we train both a first-order parsing model (as described in Section 3 and 4) as well as a third-order model. The third order parser simply adds high-order features, those typically used in MST and Turbo parsers, into our s \u03b8 (x, y) = \u03b8, \u03c6(x, y) scoring component. The decoding algorithm for the third-order parsing is based on (Zhang et al., 2014) . For the Turbo parser, we directly compare with the recent published results in (Martins et al., 2013) . For the MST parser, we train and test using the most recent version of the code. 4 In addition, we implemented two additional baselines, NT-1st (first order) and NT-3rd (third order), corresponding to our model without the tensor component.",
                "cite_spans": [
                    {
                        "start": 434,
                        "end": 454,
                        "text": "(Zhang et al., 2014)",
                        "ref_id": "BIBREF45"
                    },
                    {
                        "start": 536,
                        "end": 558,
                        "text": "(Martins et al., 2013)",
                        "ref_id": "BIBREF23"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "Features For the arc feature vector \u03c6 h\u2192m , we use the same set of feature templates as MST v0.5.1. For head/modifier vector \u03c6 h and \u03c6 m , we show the complete set of feature templates used by our model in Table 1 . Finally, we use a similar set of feature templates as Turbo v2.1 for 3rd order parsing.",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 212,
                        "end": 213,
                        "text": "1",
                        "ref_id": null
                    }
                ],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "To add auxiliary word vector representations, we use the publicly available word vectors (Cirik 2010), Rush and Petrov (2012b) , Zhang and McDonald (2012b) and Zhang et al. (2013) .",
                "cite_spans": [
                    {
                        "start": 103,
                        "end": 126,
                        "text": "Rush and Petrov (2012b)",
                        "ref_id": null
                    },
                    {
                        "start": 129,
                        "end": 155,
                        "text": "Zhang and McDonald (2012b)",
                        "ref_id": null
                    },
                    {
                        "start": 160,
                        "end": 179,
                        "text": "Zhang et al. (2013)",
                        "ref_id": "BIBREF44"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "and S \u00b8ensoy, 2013), learned from raw data (Globerson et al., 2007; Maron et al., 2010) . Three languages in our dataset -English, German and Swedish -have corresponding word vectors in this collection. 5 The dimensionality of this representation varies by language: English has 50 dimensional word vectors, while German and Swedish have 25 dimensional word vectors. Each entry of the word vector is added as a feature value into feature vectors \u03c6 h and \u03c6 m . For each word in the sentence, we add its own word vector as well as the vectors of its left and right words. We should note that since our model parameter A is represented and learned in the low-rank form, we only have to store and maintain the low-rank projections U \u03c6 h , V \u03c6 m and W \u03c6 h,m rather than explicitly calculate the feature tensor \u03c6 h \u2297\u03c6 m \u2297\u03c6 h,m . Therefore updating parameters and decoding a sentence is still efficient, i.e., linear in the number of values of the feature vector. In contrast, assume we take the cross-product of the auxiliary word vector values, POS tags and lexical items of a word and its context, and add the crossed values into a normal model (in \u03c6 h\u2192m ). The number of features for each arc would be at least quadratic, growing into thousands, and would be a significant impediment to parsing efficiency.",
                "cite_spans": [
                    {
                        "start": 43,
                        "end": 67,
                        "text": "(Globerson et al., 2007;",
                        "ref_id": "BIBREF12"
                    },
                    {
                        "start": 68,
                        "end": 87,
                        "text": "Maron et al., 2010)",
                        "ref_id": "BIBREF19"
                    }
                ],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "Evaluation Following standard practices, we train our full model and the baselines for 10 5 https://github.com/wolet/sprml13-word-embeddings epochs. As the evaluation measure, we use unlabeled attachment scores (UAS) excluding punctuation. In all the reported experiments, the hyperparameters are set as follows: r = 50 (rank of the tensor), C = 1 for first-order model and C = 0.01 for third-order model.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Experimental Setup",
                "sec_num": "5"
            },
            {
                "text": "Overall Performance Table 2 shows the performance of our model and the baselines on 14 CoNLL datasets. Our model outperforms Turbo parser, MST parser, as well as its own variants without the tensor component. The improvements of our low-rank model are consistent across languages: results for the first order parser are better on 11 out of 14 languages. By comparing NT-1st and NT-3rd (models without low-rank) with our full model (with low-rank), we obtain 0.7% absolute improvement on first-order parsing, and 0.3% improvement on third-order parsing. Our model also achieves the best UAS on 5 languages.",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 26,
                        "end": 27,
                        "text": "2",
                        "ref_id": "TABREF0"
                    }
                ],
                "eq_spans": [],
                "section": "Results",
                "sec_num": "6"
            },
            {
                "text": "We next focus on the first-order model and gauge the impact of the tensor component. First, we test our model by varying the hyper-parameter \u03b3 which balances the tensor score and the traditional MST/Turbo score components. Figure 1 shows the average UAS on CoNLL test datasets after each training epoch. We can see that the improvement of adding the low-rank tensor is consistent across various choices of hyper parame- To assess the ability of our model to incorporate a range of features, we add unsupervised word vectors to our model. As described in previous section, we do so by appending the values of different coordinates in the word vector into \u03c6 h and \u03c6 m . As Table 3 shows, adding this information increases the parsing performance for all the three languages. For instance, we obtain more than 0.5% absolute improvement on Swedish.",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 230,
                        "end": 231,
                        "text": "1",
                        "ref_id": null
                    },
                    {
                        "start": 677,
                        "end": 678,
                        "text": "3",
                        "ref_id": null
                    }
                ],
                "eq_spans": [],
                "section": "Results",
                "sec_num": "6"
            },
            {
                "text": "Syntactic Abstraction without POS Since our model learns a compressed representation of feature vectors, we are interested to measure its performance when part-of-speech tags are not provided (See Table 4 ). The rationale is that given all other features, the model would induce representations that play a similar role to POS tags. Note that the performance of traditional parsers drops when tags are not provided. For example, the performance gap is 10% on German. Our experiments show that low-rank parser operates effectively in the absence of tags. In fact, it nearly reaches the performance of the original parser that used the tags on English.",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 203,
                        "end": 204,
                        "text": "4",
                        "ref_id": "TABREF2"
                    }
                ],
                "eq_spans": [],
                "section": "Results",
                "sec_num": "6"
            },
            {
                "text": "We manually analyze low-dimensional projections to assess whether they capture syntactic abstraction. For this purpose, we train a model with only a tensor component (such that it has to learn an accurate tensor) on the English dataset and obtain low dimensional embeddings U \u03c6 w and V \u03c6 w for each word. The two r-dimension vectors are concatenated as an \"averaged\" vector. We use this vector to calculate the cosine similarity between words. Table 5 shows examples of five closest neighbors of queried words. While these lists include some noise, we can clearly see that the neighbors exhibit similar syntactic behavior. For example, \"on\" is close to other prepositions. More interestingly, we can consider the impact of syntactic context on the derived projections. The bottom part of Table 5 shows that the neighbors change substantially depending on the syntactic role of the word. For example, the closest words to the word \"increase\" are verbs in the context phrase \"will increase again\", while the closest words become nouns given a different phrase \"an increase of\". ",
                "cite_spans": [],
                "ref_spans": [
                    {
                        "start": 450,
                        "end": 451,
                        "text": "5",
                        "ref_id": "TABREF3"
                    },
                    {
                        "start": 794,
                        "end": 795,
                        "text": "5",
                        "ref_id": "TABREF3"
                    }
                ],
                "eq_spans": [],
                "section": "Examples of Derived Projections",
                "sec_num": null
            },
            {
                "text": "Accurate scoring of syntactic structures such as head-modifier arcs in dependency parsing typically requires rich, high-dimensional feature representations. We introduce a low-rank factorization method that enables to map high dimensional feature vectors into low dimensional representations. Our method maintains the parameters as a low-rank tensor to obtain low dimensional representations of words in their syntactic roles, and to leverage modularity in the tensor for easy training with online algorithms. We implement the approach on first-order to third-order dependency parsing. Our parser outperforms the Turbo and MST parsers across 14 languages. Future work involves extending the tensor component to capture higher-order structures. In particular, we would consider second-order structures such as grandparent-head-modifier by increasing the dimensionality of the tensor. This tensor will accordingly be a four or five-way array. The online update algorithm remains applicable since each dimension is optimized in an alternating fashion.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Conclusions",
                "sec_num": "7"
            },
            {
                "text": "The authors acknowledge the support of the MURI program (W911NF-10-1-0533) and the DARPA BOLT program. This research is developed in collaboration with the Arabic Language Technoligies (ALT) group at Qatar Computing Research Institute (QCRI) within the LYAS project. We thank Volkan Cirik for sharing the unsupervised word vector data. Thanks to Amir Globerson, Andreea Gane, the members of the MIT NLP group and the ACL reviewers for their suggestions and comments. Any opinions, findings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organizations.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "Acknowledgements",
                "sec_num": "8"
            },
            {
                "text": "Our code is available at https://github.com/ taolei87/RBGParser.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "",
                "sec_num": null
            },
            {
                "text": "Note that in the case of high-order parsing, the sum S(x, y) may also include local scores for other syntactic structures, such as grandhead-head-modifier score s(g \u2192 h \u2192 m). See(Martins et al., 2013) for a complete list of these structures.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "",
                "sec_num": null
            },
            {
                "text": "In our current version, \u03c6 h,m only contains the binned arc length. Other possible features include, for example, the label of the arc h \u2192 m, the POS tags between the head and the modifier, boolean flags which indicate the occurence of in-between punctutations or conjunctions, etc.",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "",
                "sec_num": null
            },
            {
                "text": "http://sourceforge.net/projects/mstparser/",
                "cite_spans": [],
                "ref_spans": [],
                "eq_spans": [],
                "section": "",
                "sec_num": null
            }
        ],
        "back_matter": [],
        "bib_entries": {
            "BIBREF0": {
                "ref_id": "b0",
                "title": "Mal-tOptimizer: An optimization tool for MaltParser",
                "authors": [
                    {
                        "first": "Miguel",
                        "middle": [],
                        "last": "Ballesteros",
                        "suffix": ""
                    },
                    {
                        "first": "Joakim",
                        "middle": [],
                        "last": "Nivre",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "EACL. The Association for Computer Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Miguel Ballesteros and Joakim Nivre. 2012. Mal- tOptimizer: An optimization tool for MaltParser. In EACL. The Association for Computer Linguistics.",
                "links": null
            },
            "BIBREF1": {
                "ref_id": "b1",
                "title": "Effective morphological feature selection with MaltOptimizer at the SPMRL 2013 shared task",
                "authors": [
                    {
                        "first": "Miguel",
                        "middle": [],
                        "last": "Ballesteros",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Miguel Ballesteros. 2013. Effective morpholog- ical feature selection with MaltOptimizer at the SPMRL 2013 shared task. In Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF2": {
                "ref_id": "b2",
                "title": "CoNLL-X shared task on multilingual dependency parsing",
                "authors": [
                    {
                        "first": "Sabine",
                        "middle": [],
                        "last": "Buchholz",
                        "suffix": ""
                    },
                    {
                        "first": "Erwin",
                        "middle": [],
                        "last": "Marsi",
                        "suffix": ""
                    }
                ],
                "year": 2006,
                "venue": "Proceedings of the Tenth Conference on Computational Natural Language Learning, CoNLL-X '06",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X shared task on multilingual dependency parsing. In Proceedings of the Tenth Conference on Computa- tional Natural Language Learning, CoNLL-X '06. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF3": {
                "ref_id": "b3",
                "title": "Rank-sparsity incoherence for matrix decomposition",
                "authors": [
                    {
                        "first": "Venkat",
                        "middle": [],
                        "last": "Chandrasekaran",
                        "suffix": ""
                    },
                    {
                        "first": "Sujay",
                        "middle": [],
                        "last": "Sanghavi",
                        "suffix": ""
                    },
                    {
                        "first": "Pablo",
                        "middle": [
                            "A"
                        ],
                        "last": "Parrilo",
                        "suffix": ""
                    },
                    {
                        "first": "Alan",
                        "middle": [
                            "S"
                        ],
                        "last": "Willsky",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "SIAM Journal on Optimization",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Venkat Chandrasekaran, Sujay Sanghavi, Pablo A Par- rilo, and Alan S Willsky. 2011. Rank-sparsity in- coherence for matrix decomposition. SIAM Journal on Optimization.",
                "links": null
            },
            "BIBREF4": {
                "ref_id": "b4",
                "title": "The AI-KU system at the SPMRL 2013 shared task : Unsupervised features for dependency parsing",
                "authors": [
                    {
                        "first": "Volkan",
                        "middle": [],
                        "last": "Cirik",
                        "suffix": ""
                    },
                    {
                        "first": "S",
                        "middle": [],
                        "last": "H\u00fcsn\u00fc",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "\u00b8ensoy",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Volkan Cirik and H\u00fcsn\u00fc S \u00b8ensoy. 2013. The AI-KU system at the SPMRL 2013 shared task : Unsuper- vised features for dependency parsing. In Proceed- ings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF5": {
                "ref_id": "b5",
                "title": "Spectral learning of latent-variable PCFGs",
                "authors": [
                    {
                        "first": "Karl",
                        "middle": [],
                        "last": "Shay B Cohen",
                        "suffix": ""
                    },
                    {
                        "first": "Michael",
                        "middle": [],
                        "last": "Stratos",
                        "suffix": ""
                    },
                    {
                        "first": "Dean",
                        "middle": [
                            "P"
                        ],
                        "last": "Collins",
                        "suffix": ""
                    },
                    {
                        "first": "Lyle",
                        "middle": [],
                        "last": "Foster",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Ungar",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers",
                "volume": "1",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Shay B Cohen, Karl Stratos, Michael Collins, Dean P Foster, and Lyle Ungar. 2012. Spectral learning of latent-variable PCFGs. In Proceedings of the 50th Annual Meeting of the Association for Computa- tional Linguistics: Long Papers-Volume 1. Associ- ation for Computational Linguistics.",
                "links": null
            },
            "BIBREF6": {
                "ref_id": "b6",
                "title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms",
                "authors": [
                    {
                        "first": "Michael",
                        "middle": [],
                        "last": "Collins",
                        "suffix": ""
                    }
                ],
                "year": 2002,
                "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing",
                "volume": "10",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Michael Collins. 2002. Discriminative training meth- ods for hidden markov models: Theory and exper- iments with perceptron algorithms. In Proceedings of the Conference on Empirical Methods in Natural Language Processing -Volume 10, EMNLP '02. As- sociation for Computational Linguistics.",
                "links": null
            },
            "BIBREF7": {
                "ref_id": "b7",
                "title": "A unified architecture for natural language processing: Deep neural networks with multitask learning",
                "authors": [
                    {
                        "first": "R",
                        "middle": [],
                        "last": "Collobert",
                        "suffix": ""
                    },
                    {
                        "first": "J",
                        "middle": [],
                        "last": "Weston",
                        "suffix": ""
                    }
                ],
                "year": 2008,
                "venue": "International Conference on Machine Learning, ICML",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "R. Collobert and J. Weston. 2008. A unified architec- ture for natural language processing: Deep neural networks with multitask learning. In International Conference on Machine Learning, ICML.",
                "links": null
            },
            "BIBREF8": {
                "ref_id": "b8",
                "title": "Online passive-aggressive algorithms",
                "authors": [
                    {
                        "first": "Koby",
                        "middle": [],
                        "last": "Crammer",
                        "suffix": ""
                    },
                    {
                        "first": "Ofer",
                        "middle": [],
                        "last": "Dekel",
                        "suffix": ""
                    },
                    {
                        "first": "Joseph",
                        "middle": [],
                        "last": "Keshet",
                        "suffix": ""
                    },
                    {
                        "first": "Shai",
                        "middle": [],
                        "last": "Shalev-Shwartz",
                        "suffix": ""
                    },
                    {
                        "first": "Yoram",
                        "middle": [],
                        "last": "Singer",
                        "suffix": ""
                    }
                ],
                "year": 2006,
                "venue": "The Journal of Machine Learning Research",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Koby Crammer, Ofer Dekel, Joseph Keshet, Shai Shalev-Shwartz, and Yoram Singer. 2006. Online passive-aggressive algorithms. The Journal of Ma- chine Learning Research.",
                "links": null
            },
            "BIBREF9": {
                "ref_id": "b9",
                "title": "A tensor-based factorization model of semantic compositionality",
                "authors": [
                    {
                        "first": "Tim",
                        "middle": [],
                        "last": "Van De Cruys",
                        "suffix": ""
                    },
                    {
                        "first": "Thierry",
                        "middle": [],
                        "last": "Poibeau",
                        "suffix": ""
                    },
                    {
                        "first": "Anna",
                        "middle": [],
                        "last": "Korhonen",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "HLT-NAACL. The Association for Computational Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Tim Van de Cruys, Thierry Poibeau, and Anna Korho- nen. 2013. A tensor-based factorization model of semantic compositionality. In HLT-NAACL. The As- sociation for Computational Linguistics.",
                "links": null
            },
            "BIBREF10": {
                "ref_id": "b10",
                "title": "Multiview learning of word embeddings via CCA",
                "authors": [
                    {
                        "first": "S",
                        "middle": [],
                        "last": "Paramveer",
                        "suffix": ""
                    },
                    {
                        "first": "Dean",
                        "middle": [],
                        "last": "Dhillon",
                        "suffix": ""
                    },
                    {
                        "first": "Lyle",
                        "middle": [],
                        "last": "Foster",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Ungar",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Advances in Neural Information Processing Systems",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Paramveer S. Dhillon, Dean Foster, and Lyle Ungar. 2011. Multiview learning of word embeddings via CCA. In Advances in Neural Information Process- ing Systems.",
                "links": null
            },
            "BIBREF11": {
                "ref_id": "b11",
                "title": "Multitask feature learning",
                "authors": [
                    {
                        "first": "A",
                        "middle": [],
                        "last": "Evgeniou",
                        "suffix": ""
                    },
                    {
                        "first": "Massimiliano",
                        "middle": [],
                        "last": "Pontil",
                        "suffix": ""
                    }
                ],
                "year": 2007,
                "venue": "Advances in neural information processing systems: Proceedings of the 2006 conference",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "A Evgeniou and Massimiliano Pontil. 2007. Multi- task feature learning. In Advances in neural infor- mation processing systems: Proceedings of the 2006 conference. The MIT Press.",
                "links": null
            },
            "BIBREF12": {
                "ref_id": "b12",
                "title": "Euclidean embedding of cooccurrence data",
                "authors": [
                    {
                        "first": "Gal",
                        "middle": [],
                        "last": "Amir Globerson",
                        "suffix": ""
                    },
                    {
                        "first": "Fernando",
                        "middle": [],
                        "last": "Chechik",
                        "suffix": ""
                    },
                    {
                        "first": "Naftali",
                        "middle": [],
                        "last": "Pereira",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Tishby",
                        "suffix": ""
                    }
                ],
                "year": 2007,
                "venue": "Journal of Machine Learning Research",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Amir Globerson, Gal Chechik, Fernando Pereira, and Naftali Tishby. 2007. Euclidean embedding of co- occurrence data. Journal of Machine Learning Re- search.",
                "links": null
            },
            "BIBREF13": {
                "ref_id": "b13",
                "title": "Most tensor problems are NP-hard",
                "authors": [
                    {
                        "first": "Christopher",
                        "middle": [],
                        "last": "Hillar",
                        "suffix": ""
                    },
                    {
                        "first": "Lek-Heng",
                        "middle": [],
                        "last": "Lim",
                        "suffix": ""
                    }
                ],
                "year": 2009,
                "venue": "",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {
                    "arXiv": [
                        "arXiv:0911.1393"
                    ]
                },
                "num": null,
                "urls": [],
                "raw_text": "Christopher Hillar and Lek-Heng Lim. 2009. Most tensor problems are NP-hard. arXiv preprint arXiv:0911.1393.",
                "links": null
            },
            "BIBREF14": {
                "ref_id": "b14",
                "title": "Learning mixtures of spherical gaussians: moment methods and spectral decompositions",
                "authors": [
                    {
                        "first": "Daniel",
                        "middle": [],
                        "last": "Hsu",
                        "suffix": ""
                    },
                    {
                        "first": "M",
                        "middle": [],
                        "last": "Sham",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Kakade",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the 4th Conference on Innovations in Theoretical Computer Science",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Daniel Hsu and Sham M Kakade. 2013. Learning mix- tures of spherical gaussians: moment methods and spectral decompositions. In Proceedings of the 4th Conference on Innovations in Theoretical Computer Science. ACM.",
                "links": null
            },
            "BIBREF15": {
                "ref_id": "b15",
                "title": "Efficient thirdorder dependency parsers",
                "authors": [
                    {
                        "first": "Terry",
                        "middle": [],
                        "last": "Koo",
                        "suffix": ""
                    },
                    {
                        "first": "Michael",
                        "middle": [],
                        "last": "Collins",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, ACL '10",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Terry Koo and Michael Collins. 2010. Efficient third- order dependency parsers. In Proceedings of the 48th Annual Meeting of the Association for Compu- tational Linguistics, ACL '10. Association for Com- putational Linguistics.",
                "links": null
            },
            "BIBREF16": {
                "ref_id": "b16",
                "title": "Dual decomposition for parsing with non-projective head automata",
                "authors": [
                    {
                        "first": "Terry",
                        "middle": [],
                        "last": "Koo",
                        "suffix": ""
                    },
                    {
                        "first": "Alexander",
                        "middle": [
                            "M"
                        ],
                        "last": "Rush",
                        "suffix": ""
                    },
                    {
                        "first": "Michael",
                        "middle": [],
                        "last": "Collins",
                        "suffix": ""
                    },
                    {
                        "first": "Tommi",
                        "middle": [],
                        "last": "Jaakkola",
                        "suffix": ""
                    },
                    {
                        "first": "David",
                        "middle": [],
                        "last": "Sontag",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Terry Koo, Alexander M Rush, Michael Collins, Tommi Jaakkola, and David Sontag. 2010. Dual decomposition for parsing with non-projective head automata. In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Process- ing. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF17": {
                "ref_id": "b17",
                "title": "Fish transporters and miracle homes: How compositional distributional semantics can help NP parsing",
                "authors": [
                    {
                        "first": "Angeliki",
                        "middle": [],
                        "last": "Lazaridou",
                        "suffix": ""
                    },
                    {
                        "first": "Eva",
                        "middle": [
                            "Maria"
                        ],
                        "last": "Vecchi",
                        "suffix": ""
                    },
                    {
                        "first": "Marco",
                        "middle": [],
                        "last": "Baroni",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Angeliki Lazaridou, Eva Maria Vecchi, and Marco Baroni. 2013. Fish transporters and miracle homes: How compositional distributional semantics can help NP parsing. In Proceedings of the 2013 Conference on Empirical Methods in Natural Lan- guage Processing. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF18": {
                "ref_id": "b18",
                "title": "Learning the parts of objects by non-negative matrix factorization",
                "authors": [
                    {
                        "first": "D",
                        "middle": [],
                        "last": "Daniel",
                        "suffix": ""
                    },
                    {
                        "first": "H",
                        "middle": [],
                        "last": "Lee",
                        "suffix": ""
                    },
                    {
                        "first": "Seung",
                        "middle": [],
                        "last": "Sebastian",
                        "suffix": ""
                    }
                ],
                "year": 1999,
                "venue": "Nature",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Daniel D Lee and H Sebastian Seung. 1999. Learning the parts of objects by non-negative matrix factor- ization. Nature.",
                "links": null
            },
            "BIBREF19": {
                "ref_id": "b19",
                "title": "Sphere embedding: An application to partof-speech induction",
                "authors": [
                    {
                        "first": "Yariv",
                        "middle": [],
                        "last": "Maron",
                        "suffix": ""
                    },
                    {
                        "first": "Michael",
                        "middle": [],
                        "last": "Lamar",
                        "suffix": ""
                    },
                    {
                        "first": "Elie",
                        "middle": [],
                        "last": "Bienenstock",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Advances in Neural Information Processing Systems",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Yariv Maron, Michael Lamar, and Elie Bienenstock. 2010. Sphere embedding: An application to part- of-speech induction. In Advances in Neural Infor- mation Processing Systems.",
                "links": null
            },
            "BIBREF20": {
                "ref_id": "b20",
                "title": "Turbo parsers: Dependency parsing by approximate variational inference",
                "authors": [
                    {
                        "first": "F",
                        "middle": [
                            "T"
                        ],
                        "last": "Andr\u00e9",
                        "suffix": ""
                    },
                    {
                        "first": "Noah",
                        "middle": [
                            "A"
                        ],
                        "last": "Martins",
                        "suffix": ""
                    },
                    {
                        "first": "Eric",
                        "middle": [
                            "P"
                        ],
                        "last": "Smith",
                        "suffix": ""
                    },
                    {
                        "first": "Pedro",
                        "middle": [
                            "Mq"
                        ],
                        "last": "Xing",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Aguiar",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "M\u00e1rio",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Figueiredo",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Andr\u00e9 FT Martins, Noah A Smith, Eric P Xing, Pe- dro MQ Aguiar, and M\u00e1rio AT Figueiredo. 2010. Turbo parsers: Dependency parsing by approximate variational inference. In Proceedings of the 2010 Conference on Empirical Methods in Natural Lan- guage Processing. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF21": {
                "ref_id": "b21",
                "title": "Dual decomposition with many overlapping components",
                "authors": [
                    {
                        "first": "F",
                        "middle": [
                            "T"
                        ],
                        "last": "Andr\u00e9",
                        "suffix": ""
                    },
                    {
                        "first": "Noah",
                        "middle": [
                            "A"
                        ],
                        "last": "Martins",
                        "suffix": ""
                    },
                    {
                        "first": "Pedro",
                        "middle": [
                            "M Q"
                        ],
                        "last": "Smith",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Aguiar",
                        "suffix": ""
                    },
                    {
                        "first": "A",
                        "middle": [
                            "T"
                        ],
                        "last": "M\u00e1rio",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Figueiredo",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Andr\u00e9 F. T. Martins, Noah A. Smith, Pedro M. Q. Aguiar, and M\u00e1rio A. T. Figueiredo. 2011a. Dual decomposition with many overlapping components. In Proceedings of the Conference on Empirical Methods in Natural Language Processing, EMNLP '11. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF22": {
                "ref_id": "b22",
                "title": "Structured sparsity in structured prediction",
                "authors": [
                    {
                        "first": "F",
                        "middle": [
                            "T"
                        ],
                        "last": "Andr\u00e9",
                        "suffix": ""
                    },
                    {
                        "first": "Noah",
                        "middle": [
                            "A"
                        ],
                        "last": "Martins",
                        "suffix": ""
                    },
                    {
                        "first": "Pedro",
                        "middle": [
                            "Mq"
                        ],
                        "last": "Smith",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Aguiar",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "M\u00e1rio",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Figueiredo",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Andr\u00e9 FT Martins, Noah A Smith, Pedro MQ Aguiar, and M\u00e1rio AT Figueiredo. 2011b. Structured spar- sity in structured prediction. In Proceedings of the Conference on Empirical Methods in Natural Lan- guage Processing. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF23": {
                "ref_id": "b23",
                "title": "Turning on the turbo: Fast third-order non-projective turbo parsers",
                "authors": [
                    {
                        "first": "F",
                        "middle": [
                            "T"
                        ],
                        "last": "Andr\u00e9",
                        "suffix": ""
                    },
                    {
                        "first": "Miguel",
                        "middle": [
                            "B"
                        ],
                        "last": "Martins",
                        "suffix": ""
                    },
                    {
                        "first": "Noah",
                        "middle": [
                            "A"
                        ],
                        "last": "Almeida",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Smith",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the 51th Annual Meeting of the Association for Computational Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Andr\u00e9 FT Martins, Miguel B Almeida, and Noah A Smith. 2013. Turning on the turbo: Fast third-order non-projective turbo parsers. In Proceedings of the 51th Annual Meeting of the Association for Compu- tational Linguistics. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF24": {
                "ref_id": "b24",
                "title": "Improving arabic dependency parsing with lexical and inflectional morphological features",
                "authors": [
                    {
                        "first": "Yuval",
                        "middle": [],
                        "last": "Marton",
                        "suffix": ""
                    },
                    {
                        "first": "Nizar",
                        "middle": [],
                        "last": "Habash",
                        "suffix": ""
                    },
                    {
                        "first": "Owen",
                        "middle": [],
                        "last": "Rambow",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the NAACL HLT 2010 First Workshop on Statistical Parsing of Morphologically-Rich Languages, SPMRL '10",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Yuval Marton, Nizar Habash, and Owen Rambow. 2010. Improving arabic dependency parsing with lexical and inflectional morphological features. In Proceedings of the NAACL HLT 2010 First Work- shop on Statistical Parsing of Morphologically-Rich Languages, SPMRL '10. Association for Computa- tional Linguistics.",
                "links": null
            },
            "BIBREF25": {
                "ref_id": "b25",
                "title": "Improving arabic dependency parsing with form-based and functional morphological features",
                "authors": [
                    {
                        "first": "Yuval",
                        "middle": [],
                        "last": "Marton",
                        "suffix": ""
                    },
                    {
                        "first": "Nizar",
                        "middle": [],
                        "last": "Habash",
                        "suffix": ""
                    },
                    {
                        "first": "Owen",
                        "middle": [],
                        "last": "Rambow",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Yuval Marton, Nizar Habash, and Owen Rambow. 2011. Improving arabic dependency parsing with form-based and functional morphological features. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies. Association for Computa- tional Linguistics.",
                "links": null
            },
            "BIBREF26": {
                "ref_id": "b26",
                "title": "Online large-margin training of dependency parsers",
                "authors": [
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    },
                    {
                        "first": "Koby",
                        "middle": [],
                        "last": "Crammer",
                        "suffix": ""
                    },
                    {
                        "first": "Fernando",
                        "middle": [],
                        "last": "Pereira",
                        "suffix": ""
                    }
                ],
                "year": 2005,
                "venue": "Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL'05)",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Ryan McDonald, Koby Crammer, and Fernando Pereira. 2005a. Online large-margin training of de- pendency parsers. In Proceedings of the 43rd An- nual Meeting of the Association for Computational Linguistics (ACL'05).",
                "links": null
            },
            "BIBREF27": {
                "ref_id": "b27",
                "title": "Non-projective dependency parsing using spanning tree algorithms",
                "authors": [
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    },
                    {
                        "first": "Fernando",
                        "middle": [],
                        "last": "Pereira",
                        "suffix": ""
                    },
                    {
                        "first": "Kiril",
                        "middle": [],
                        "last": "Ribarov",
                        "suffix": ""
                    },
                    {
                        "first": "Jan",
                        "middle": [],
                        "last": "Haji\u010d",
                        "suffix": ""
                    }
                ],
                "year": 2005,
                "venue": "Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Ryan McDonald, Fernando Pereira, Kiril Ribarov, and Jan Haji\u010d. 2005b. Non-projective dependency pars- ing using spanning tree algorithms. In Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Pro- cessing. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF28": {
                "ref_id": "b28",
                "title": "Multilingual dependency analysis with a two-stage discriminative parser",
                "authors": [
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    },
                    {
                        "first": "Kevin",
                        "middle": [],
                        "last": "Lerman",
                        "suffix": ""
                    },
                    {
                        "first": "Fernando",
                        "middle": [],
                        "last": "Pereira",
                        "suffix": ""
                    }
                ],
                "year": 2006,
                "venue": "Proceedings of the Tenth Conference on Computational Natural Language Learning",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Ryan McDonald, Kevin Lerman, and Fernando Pereira. 2006. Multilingual dependency analysis with a two-stage discriminative parser. In Proceedings of the Tenth Conference on Computational Natural Language Learning. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF29": {
                "ref_id": "b29",
                "title": "Efficient estimation of word representations in vector space",
                "authors": [
                    {
                        "first": "Tomas",
                        "middle": [],
                        "last": "Mikolov",
                        "suffix": ""
                    },
                    {
                        "first": "Kai",
                        "middle": [],
                        "last": "Chen",
                        "suffix": ""
                    },
                    {
                        "first": "Greg",
                        "middle": [],
                        "last": "Corrado",
                        "suffix": ""
                    },
                    {
                        "first": "Jeffrey",
                        "middle": [],
                        "last": "Dean",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. 2013. Efficient estimation of word represen- tations in vector space. CoRR.",
                "links": null
            },
            "BIBREF30": {
                "ref_id": "b30",
                "title": "Automatic discovery of feature sets for dependency parsing",
                "authors": [
                    {
                        "first": "Peter",
                        "middle": [],
                        "last": "Nilsson",
                        "suffix": ""
                    },
                    {
                        "first": "Pierre",
                        "middle": [],
                        "last": "Nugues",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the 23rd International Conference on Computational Linguistics (Coling 2010). Coling 2010 Organizing Committee",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Peter Nilsson and Pierre Nugues. 2010. Automatic discovery of feature sets for dependency parsing. In Proceedings of the 23rd International Conference on Computational Linguistics (Coling 2010). Coling 2010 Organizing Committee.",
                "links": null
            },
            "BIBREF31": {
                "ref_id": "b31",
                "title": "Labeled pseudoprojective dependency parsing with support vector machines",
                "authors": [
                    {
                        "first": "Joakim",
                        "middle": [],
                        "last": "Nivre",
                        "suffix": ""
                    },
                    {
                        "first": "Johan",
                        "middle": [],
                        "last": "Hall",
                        "suffix": ""
                    },
                    {
                        "first": "Jens",
                        "middle": [],
                        "last": "Nilsson",
                        "suffix": ""
                    }
                ],
                "year": 2006,
                "venue": "Proceedings of the Tenth Conference on Computational Natural Language Learning. Association for Computational Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Joakim Nivre, Johan Hall, Jens Nilsson, G\u00fcls \u00b8en Eryiit, and Svetoslav Marinov. 2006. Labeled pseudo- projective dependency parsing with support vector machines. In Proceedings of the Tenth Conference on Computational Natural Language Learning. As- sociation for Computational Linguistics.",
                "links": null
            },
            "BIBREF32": {
                "ref_id": "b32",
                "title": "MaltParser: A language-independent system for data-driven dependency parsing",
                "authors": [
                    {
                        "first": "Joakim",
                        "middle": [],
                        "last": "Nivre",
                        "suffix": ""
                    },
                    {
                        "first": "Johan",
                        "middle": [],
                        "last": "Hall",
                        "suffix": ""
                    },
                    {
                        "first": "Jens",
                        "middle": [],
                        "last": "Nilsson",
                        "suffix": ""
                    },
                    {
                        "first": "Atanas",
                        "middle": [],
                        "last": "Chanev",
                        "suffix": ""
                    },
                    {
                        "first": "G\u00fclsen",
                        "middle": [],
                        "last": "Eryigit",
                        "suffix": ""
                    },
                    {
                        "first": "Sandra",
                        "middle": [],
                        "last": "K\u00fcbler",
                        "suffix": ""
                    },
                    {
                        "first": "Svetoslav",
                        "middle": [],
                        "last": "Marinov",
                        "suffix": ""
                    },
                    {
                        "first": "Erwin",
                        "middle": [],
                        "last": "Marsi",
                        "suffix": ""
                    }
                ],
                "year": 2007,
                "venue": "Natural Language Engineering",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Joakim Nivre, Johan Hall, Jens Nilsson, Atanas Chanev, G\u00fclsen Eryigit, Sandra K\u00fcbler, Svetoslav Marinov, and Erwin Marsi. 2007. MaltParser: A language-independent system for data-driven depen- dency parsing. Natural Language Engineering.",
                "links": null
            },
            "BIBREF33": {
                "ref_id": "b33",
                "title": "Vine pruning for efficient multi-pass dependency parsing",
                "authors": [
                    {
                        "first": "Alexander",
                        "middle": [],
                        "last": "Rush",
                        "suffix": ""
                    },
                    {
                        "first": "Slav",
                        "middle": [],
                        "last": "Petrov",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "The 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (NAACL '12)",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Alexander Rush and Slav Petrov. 2012a. Vine pruning for efficient multi-pass dependency parsing. In The 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Hu- man Language Technologies (NAACL '12).",
                "links": null
            },
            "BIBREF34": {
                "ref_id": "b34",
                "title": "Vine pruning for efficient multi-pass dependency parsing",
                "authors": [
                    {
                        "first": "M",
                        "middle": [],
                        "last": "Alexander",
                        "suffix": ""
                    },
                    {
                        "first": "Slav",
                        "middle": [],
                        "last": "Rush",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Petrov",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Alexander M Rush and Slav Petrov. 2012b. Vine prun- ing for efficient multi-pass dependency parsing. In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computa- tional Linguistics: Human Language Technologies. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF35": {
                "ref_id": "b35",
                "title": "Parsing with compositional vector grammars",
                "authors": [
                    {
                        "first": "Richard",
                        "middle": [],
                        "last": "Socher",
                        "suffix": ""
                    },
                    {
                        "first": "John",
                        "middle": [],
                        "last": "Bauer",
                        "suffix": ""
                    },
                    {
                        "first": "Christopher",
                        "middle": [
                            "D"
                        ],
                        "last": "Manning",
                        "suffix": ""
                    },
                    {
                        "first": "Andrew",
                        "middle": [
                            "Y"
                        ],
                        "last": "Ng",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of the 51th Annual Meeting of the Association for Computational Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Richard Socher, John Bauer, Christopher D. Manning, and Andrew Y. Ng. 2013. Parsing with compo- sitional vector grammars. In Proceedings of the 51th Annual Meeting of the Association for Compu- tational Linguistics.",
                "links": null
            },
            "BIBREF36": {
                "ref_id": "b36",
                "title": "Weighted low-rank approximations",
                "authors": [
                    {
                        "first": "Nathan",
                        "middle": [],
                        "last": "Srebro",
                        "suffix": ""
                    },
                    {
                        "first": "Tommi",
                        "middle": [],
                        "last": "Jaakkola",
                        "suffix": ""
                    }
                ],
                "year": 2003,
                "venue": "ICML",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Nathan Srebro, Tommi Jaakkola, et al. 2003. Weighted low-rank approximations. In ICML.",
                "links": null
            },
            "BIBREF37": {
                "ref_id": "b37",
                "title": "Maximum-margin matrix factorization",
                "authors": [
                    {
                        "first": "Nathan",
                        "middle": [],
                        "last": "Srebro",
                        "suffix": ""
                    },
                    {
                        "first": "Jason",
                        "middle": [],
                        "last": "Rennie",
                        "suffix": ""
                    },
                    {
                        "first": "Tommi",
                        "middle": [
                            "S"
                        ],
                        "last": "Jaakkola",
                        "suffix": ""
                    }
                ],
                "year": 2004,
                "venue": "Advances in neural information processing systems",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Nathan Srebro, Jason Rennie, and Tommi S Jaakkola. 2004. Maximum-margin matrix factorization. In Advances in neural information processing systems.",
                "links": null
            },
            "BIBREF38": {
                "ref_id": "b38",
                "title": "The CoNLL-2008 shared task on joint parsing of syntactic and semantic dependencies",
                "authors": [
                    {
                        "first": "Mihai",
                        "middle": [],
                        "last": "Surdeanu",
                        "suffix": ""
                    },
                    {
                        "first": "Richard",
                        "middle": [],
                        "last": "Johansson",
                        "suffix": ""
                    },
                    {
                        "first": "Adam",
                        "middle": [],
                        "last": "Meyers",
                        "suffix": ""
                    },
                    {
                        "first": "Llu\u00eds",
                        "middle": [],
                        "last": "M\u00e0rquez",
                        "suffix": ""
                    },
                    {
                        "first": "Joakim",
                        "middle": [],
                        "last": "Nivre",
                        "suffix": ""
                    }
                ],
                "year": 2008,
                "venue": "Proceedings of the Twelfth Conference on Computational Natural Language Learning, CoNLL '08",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Mihai Surdeanu, Richard Johansson, Adam Meyers, Llu\u00eds M\u00e0rquez, and Joakim Nivre. 2008. The CoNLL-2008 shared task on joint parsing of syn- tactic and semantic dependencies. In Proceedings of the Twelfth Conference on Computational Natu- ral Language Learning, CoNLL '08. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF39": {
                "ref_id": "b39",
                "title": "Recovering lowrank and sparse components of matrices from incomplete and noisy observations",
                "authors": [
                    {
                        "first": "Min",
                        "middle": [],
                        "last": "Tao",
                        "suffix": ""
                    },
                    {
                        "first": "Xiaoming",
                        "middle": [],
                        "last": "Yuan",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "SIAM Journal on Optimization",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Min Tao and Xiaoming Yuan. 2011. Recovering low- rank and sparse components of matrices from in- complete and noisy observations. SIAM Journal on Optimization.",
                "links": null
            },
            "BIBREF40": {
                "ref_id": "b40",
                "title": "Word representations: A simple and general method for semi-supervised learning",
                "authors": [
                    {
                        "first": "Joseph",
                        "middle": [],
                        "last": "Turian",
                        "suffix": ""
                    },
                    {
                        "first": "Lev",
                        "middle": [],
                        "last": "Ratinov",
                        "suffix": ""
                    },
                    {
                        "first": "Yoshua",
                        "middle": [],
                        "last": "Bengio",
                        "suffix": ""
                    }
                ],
                "year": 2010,
                "venue": "Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, ACL '10",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010. Word representations: A simple and general method for semi-supervised learning. In Proceedings of the 48th Annual Meeting of the Association for Compu- tational Linguistics, ACL '10. Association for Com- putational Linguistics.",
                "links": null
            },
            "BIBREF41": {
                "ref_id": "b41",
                "title": "SpaRCS: Recovering lowrank and sparse matrices from compressive measurements",
                "authors": [
                    {
                        "first": "Aswin",
                        "middle": [
                            "C"
                        ],
                        "last": "Andrew E Waters",
                        "suffix": ""
                    },
                    {
                        "first": "Richard",
                        "middle": [],
                        "last": "Sankaranarayanan",
                        "suffix": ""
                    },
                    {
                        "first": "",
                        "middle": [],
                        "last": "Baraniuk",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Advances in Neural Information Processing Systems",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Andrew E Waters, Aswin C Sankaranarayanan, and Richard Baraniuk. 2011. SpaRCS: Recovering low- rank and sparse matrices from compressive mea- surements. In Advances in Neural Information Pro- cessing Systems.",
                "links": null
            },
            "BIBREF42": {
                "ref_id": "b42",
                "title": "Generalized higher-order dependency parsing with cube pruning",
                "authors": [
                    {
                        "first": "Hao",
                        "middle": [],
                        "last": "Zhang",
                        "suffix": ""
                    },
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, EMNLP-CoNLL '12",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Hao Zhang and Ryan McDonald. 2012a. Generalized higher-order dependency parsing with cube prun- ing. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Process- ing and Computational Natural Language Learn- ing, EMNLP-CoNLL '12. Association for Compu- tational Linguistics.",
                "links": null
            },
            "BIBREF43": {
                "ref_id": "b43",
                "title": "Generalized higher-order dependency parsing with cube pruning",
                "authors": [
                    {
                        "first": "Hao",
                        "middle": [],
                        "last": "Zhang",
                        "suffix": ""
                    },
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    }
                ],
                "year": 2012,
                "venue": "Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Hao Zhang and Ryan McDonald. 2012b. Generalized higher-order dependency parsing with cube prun- ing. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Process- ing and Computational Natural Language Learning. Association for Computational Linguistics.",
                "links": null
            },
            "BIBREF44": {
                "ref_id": "b44",
                "title": "Online learning for inexact hypergraph search",
                "authors": [
                    {
                        "first": "Hao",
                        "middle": [],
                        "last": "Zhang",
                        "suffix": ""
                    },
                    {
                        "first": "Liang",
                        "middle": [],
                        "last": "Huang",
                        "suffix": ""
                    },
                    {
                        "first": "Kai",
                        "middle": [],
                        "last": "Zhao",
                        "suffix": ""
                    },
                    {
                        "first": "Ryan",
                        "middle": [],
                        "last": "Mcdonald",
                        "suffix": ""
                    }
                ],
                "year": 2013,
                "venue": "Proceedings of EMNLP",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Hao Zhang, Liang Huang Kai Zhao, and Ryan McDon- ald. 2013. Online learning for inexact hypergraph search. In Proceedings of EMNLP.",
                "links": null
            },
            "BIBREF45": {
                "ref_id": "b45",
                "title": "Steps to excellence: Simple inference with refined scoring of dependency trees",
                "authors": [
                    {
                        "first": "Yuan",
                        "middle": [],
                        "last": "Zhang",
                        "suffix": ""
                    },
                    {
                        "first": "Tao",
                        "middle": [],
                        "last": "Lei",
                        "suffix": ""
                    },
                    {
                        "first": "Regina",
                        "middle": [],
                        "last": "Barzilay",
                        "suffix": ""
                    },
                    {
                        "first": "Tommi",
                        "middle": [],
                        "last": "Jaakkola",
                        "suffix": ""
                    },
                    {
                        "first": "Amir",
                        "middle": [],
                        "last": "Globerson",
                        "suffix": ""
                    }
                ],
                "year": 2014,
                "venue": "Proceedings of the 52th Annual Meeting of the Association for Computational Linguistics",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Yuan Zhang, Tao Lei, Regina Barzilay, Tommi Jaakkola, and Amir Globerson. 2014. Steps to ex- cellence: Simple inference with refined scoring of dependency trees. In Proceedings of the 52th An- nual Meeting of the Association for Computational Linguistics. Association for Computational Linguis- tics.",
                "links": null
            },
            "BIBREF46": {
                "ref_id": "b46",
                "title": "Godec: Randomized low-rank & sparse matrix decomposition in noisy case",
                "authors": [
                    {
                        "first": "Tianyi",
                        "middle": [],
                        "last": "Zhou",
                        "suffix": ""
                    },
                    {
                        "first": "Dacheng",
                        "middle": [],
                        "last": "Tao",
                        "suffix": ""
                    }
                ],
                "year": 2011,
                "venue": "Proceedings of the 28th International Conference on Machine Learning",
                "volume": "",
                "issue": "",
                "pages": "",
                "other_ids": {},
                "num": null,
                "urls": [],
                "raw_text": "Tianyi Zhou and Dacheng Tao. 2011. Godec: Ran- domized low-rank & sparse matrix decomposition in noisy case. In Proceedings of the 28th International Conference on Machine Learning (ICML-11).",
                "links": null
            }
        },
        "ref_entries": {
            "TABREF0": {
                "content": "<table><tr><td/><td/><td colspan=\"2\">First-order only</td><td/><td/><td/><td>High-order</td><td/><td/></tr><tr><td/><td>Ours</td><td>NT-1st</td><td>MST</td><td>Turbo</td><td colspan=\"5\">Ours-3rd NT-3rd MST-2nd Turbo-3rd Best Published</td></tr><tr><td>Arabic</td><td>79.60</td><td>78.71</td><td>78.3</td><td>77.23</td><td>79.95</td><td>79.53</td><td>78.75</td><td>79.64</td><td>81.12 (Ma11)</td></tr><tr><td>Bulgarian</td><td>92.30</td><td>91.14</td><td>90.98</td><td>91.76</td><td>93.50</td><td>92.79</td><td>91.56</td><td>93.1</td><td>94.02 (Zh13)</td></tr><tr><td>Chinese</td><td>91.43</td><td>90.85</td><td>90.40</td><td>88.49</td><td>92.68</td><td>92.39</td><td>91.77</td><td>89.98</td><td>91.89 (Ma10)</td></tr><tr><td>Czech</td><td>87.90</td><td>86.62</td><td>86.18</td><td>87.66</td><td>90.50</td><td>89.43</td><td>87.3</td><td>90.32</td><td>90.32 (Ma13)</td></tr><tr><td>Danish</td><td>90.64</td><td>89.80</td><td>89.84</td><td>89.42</td><td>91.39</td><td>90.82</td><td>90.5</td><td>91.48</td><td>92.00 (Zh13)</td></tr><tr><td>Dutch</td><td>84.81</td><td>83.77</td><td>82.89</td><td>83.61</td><td>86.41</td><td>86.08</td><td>84.11</td><td>86.19</td><td>86.19 (Ma13)</td></tr><tr><td>English</td><td>91.84</td><td>91.40</td><td>90.59</td><td>91.21</td><td>93.02</td><td>92.82</td><td>91.54</td><td>93.22</td><td>93.22 (Ma13)</td></tr><tr><td>German</td><td>90.24</td><td>89.70</td><td>89.54</td><td>90.52</td><td>91.97</td><td>92.26</td><td>90.14</td><td>92.41</td><td>92.41 (Ma13)</td></tr><tr><td>Japanese</td><td>93.74</td><td>93.36</td><td>93.38</td><td>92.78</td><td>93.71</td><td>93.23</td><td>92.92</td><td>93.52</td><td>93.72 (Ma11)</td></tr><tr><td>Portuguese</td><td>90.94</td><td>90.67</td><td>89.92</td><td>91.14</td><td>91.92</td><td>91.63</td><td>91.08</td><td>92.69</td><td>93.03 (Ko10)</td></tr><tr><td>Slovene</td><td>84.25</td><td>83.15</td><td>82.09</td><td>82.81</td><td>86.24</td><td>86.07</td><td>83.25</td><td>86.01</td><td>86.95 (Ma11)</td></tr><tr><td>Spanish</td><td>85.27</td><td>84.95</td><td>83.79</td><td>83.61</td><td>88.00</td><td>87.47</td><td>84.33</td><td>85.59</td><td>87.96 (Zh13)</td></tr><tr><td>Swedish</td><td>89.86</td><td>89.66</td><td>88.27</td><td>89.36</td><td>91.00</td><td>90.83</td><td>89.05</td><td>91.14</td><td>91.62 (Zh13)</td></tr><tr><td>Turkish</td><td>75.84</td><td>74.89</td><td>74.81</td><td>75.98</td><td>76.84</td><td>75.83</td><td>74.39</td><td>76.9</td><td>77.55 (Ko10)</td></tr><tr><td>Average</td><td>87.76</td><td>87.05</td><td>86.5</td><td>86.83</td><td>89.08</td><td>88.66</td><td>87.19</td><td>88.73</td><td>89.43</td></tr></table>",
                "type_str": "table",
                "text": "First-order parsing (left) and high-order parsing (right) results on CoNLL-2006 datasets and the English dataset of CoNLL-2008. For our model, the experiments are ran with rank r = 50 and hyperparameter \u03b3 = 0.3. To remove the tensor in our model, we ran experiments with \u03b3 = 1, corresponding to columns NT-1st and NT-3rd. The last column shows results of most accurate parsers among Nivre et al. (2006), McDonald et al. (2006), Martins et al. (2010), Martins et al. (2011a), Martins et al. (2013), Koo et al. (",
                "html": null,
                "num": null
            },
            "TABREF2": {
                "content": "<table><tr><td>Our model</td><td>NT-1st</td></tr><tr><td colspan=\"2\">-POS +wv. -POS +POS</td></tr><tr><td colspan=\"2\">English 88.89 90.49 86.70 90.58</td></tr><tr><td colspan=\"2\">German 82.63 85.80 78.71 88.50</td></tr><tr><td colspan=\"2\">Swedish 81.84 85.90 79.65 88.75</td></tr></table>",
                "type_str": "table",
                "text": "The first three columns show parsing results when models are trained without POS tags. The last column gives the upper-bound, i.e. the performance of a parser trained with 12 Core POS tags. The low-rank model outperforms NT-1st by a large margin. Adding word vector features further improves performance.",
                "html": null,
                "num": null
            },
            "TABREF3": {
                "content": "<table><tr><td>greatly</td><td>profit</td><td/><td>says</td><td>on</td><td>when</td></tr><tr><td>actively</td><td>earnings</td><td/><td>adds</td><td>with</td><td>where</td></tr><tr><td>openly</td><td colspan=\"3\">franchisees predicts</td><td>into</td><td>what</td></tr><tr><td colspan=\"2\">significantly shares</td><td/><td>noted</td><td>at</td><td>why</td></tr><tr><td>outright</td><td>revenue</td><td/><td>wrote</td><td colspan=\"2\">during which</td></tr><tr><td colspan=\"2\">substantially members</td><td/><td colspan=\"2\">contends over</td><td>who</td></tr><tr><td>increase</td><td colspan=\"4\">will increase again an increase of</td></tr><tr><td>rise</td><td>arguing</td><td/><td>gain</td><td/></tr><tr><td>advance</td><td>be</td><td/><td>prices</td><td/></tr><tr><td>contest</td><td>charging</td><td/><td colspan=\"2\">payment</td></tr><tr><td>halt</td><td>gone</td><td/><td colspan=\"2\">members</td></tr><tr><td colspan=\"2\">Exchequer making</td><td/><td colspan=\"2\">subsidiary</td></tr><tr><td>hit</td><td colspan=\"2\">attacks hit the</td><td colspan=\"2\">hardest hit is</td></tr><tr><td>shed</td><td>distributes</td><td/><td colspan=\"2\">monopolies</td></tr><tr><td>rallied</td><td>stayed</td><td/><td>pills</td><td/></tr><tr><td>triggered</td><td>sang</td><td/><td colspan=\"2\">sophistication</td></tr><tr><td>appeared</td><td>removed</td><td/><td colspan=\"2\">ventures</td></tr><tr><td>understate</td><td>eased</td><td/><td colspan=\"2\">factors</td></tr><tr><td/><td colspan=\"2\">#Tok. Len.</td><td colspan=\"3\">Train. Time (hour) NT-1st Ours</td></tr><tr><td>Arabic</td><td>42K</td><td>32</td><td>0.13</td><td colspan=\"2\">0.22</td></tr><tr><td colspan=\"2\">Chinese 337K</td><td>6</td><td>0.37</td><td colspan=\"2\">0.65</td></tr><tr><td colspan=\"2\">English 958K</td><td>24</td><td>1.88</td><td colspan=\"2\">2.83</td></tr></table>",
                "type_str": "table",
                "text": "Table6illustrates the impact of estimating low-rank tensor parameters on the running time of the algorithm. For comparison, we also show the NT-1st times across three typical languages. The Arabic dataset has the longest average sentence length, while the Chinese dataset Five closest neighbors of the queried words (shown in bold). The upper part shows our learned embeddings group words with similar syntactic behavior. The two bottom parts of the table demonstrate that how the projections change depending on the syntactic context of the word.",
                "html": null,
                "num": null
            },
            "TABREF4": {
                "content": "<table/>",
                "type_str": "table",
                "text": "Comparison of training times across three typical datasets. The second column is the number of tokens in each data set. The third column shows the average sentence length. Both first-order models are implemented in Java and run as a single process. has the shortest sentence length in CoNLL 2006. Based on these results, estimating a rank-50 tensor together with MST parameters only increases the running time by a factor of 1.7.",
                "html": null,
                "num": null
            }
        }
    }
}