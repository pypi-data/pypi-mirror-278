# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_trait.ipynb.

# %% auto 0
__all__ = ['genome', 'founder_pop', 'qtl_map', 't', 'select_qtl_loci', 'TraitA']

# %% ../nbs/02_trait.ipynb 3
from .core import *
import torch
import attr
from typing import Tuple, Optional, List
from fastcore.test import *
import matplotlib.pyplot as plt
import torch.nn as nn
import pdb

def select_qtl_loci(num_qtl_per_chromosome: int, genome: Genome) -> torch.Tensor:
    """
    Randomly selects loci to be QTLs on each chromosome.

    Args:
    ----
    num_qtl_per_chromosome (int): Number of QTLs to select per chromosome.
    genome (Genome): Genome object containing the chromosome structure.
    device (str): Device to create the tensor on ('cpu' or 'cuda'). Defaults to 'cpu'.

    Returns:
    -------
    torch.Tensor: A boolean tensor indicating which loci are QTLs. 
                  Shape: (number_chromosomes, loci_per_chromosome)
    """
    
    assert num_qtl_per_chromosome <= genome.n_loci_per_chromosome, "too many qtls for this trait given your Genome object"
    assert num_qtl_per_chromosome > 0, "you need at least 1 QTL per chromosome"
    
    qtl_indices = []
    for i in range(genome.n_chromosomes):
        # Randomly sample indices for QTLs on the current chromosome
        chromosome_indices = torch.randperm(genome.n_loci_per_chromosome)[:num_qtl_per_chromosome]
        
        # Create a boolean tensor for the current chromosome, marking QTL positions as True
        chromosome_qtl_flags = torch.zeros(genome.n_loci_per_chromosome, dtype=torch.bool)
        chromosome_qtl_flags[chromosome_indices] = True
        
        qtl_indices.append(chromosome_qtl_flags)
    
    return torch.stack(qtl_indices)

# %% ../nbs/02_trait.ipynb 4
class TraitA(nn.Module):
    """
    Represents a trait with only additive genetic effects.

    Args:
        genome (Genome): The genome object.
        target_mean (float): The desired genetic mean for the trait in the founder population.
        target_variance (float): The desired genetic variance for the trait in the founder population.
    """
    
    def __init__(self, genome: Genome, founder_population: Population, target_mean: float, target_variance: float):
        super().__init__()
        self.genome = genome
        self.target_mean = torch.tensor(target_mean, device=self.genome.device)
        self.target_variance = torch.tensor(target_variance, device=self.genome.device)
        self.effects = None  # QTL effects (to be initialized later)
        self.intercept = None
        self.qtl_map =  torch.randint(0, 2, (self.genome.n_chromosomes, self.genome.n_loci_per_chromosome), device=self.genome.device) # random qtl map
        
        # Move computations to the GPU for performance
        with torch.no_grad(): 
            self.sample_initial_effects()
            self.scale_effects(founder_population)

    def _calculate_scaled_additive_dosages(self, genotypes: torch.Tensor) -> torch.Tensor:
        """
        Calculates the scaled additive genotype dosages.

        Args:
            genotypes (torch.Tensor): A tensor representing the genotypes of individuals.
                                     Shape: (n_individuals, ploidy, n_chromosomes, n_loci_per_chromosome).

        Returns:
            torch.Tensor: A tensor of scaled additive dosages. 
                         Shape: (n_individuals, ploidy, n_chromosomes, n_loci_per_chromosome).
        """
        return (genotypes - self.genome.ploidy / 2) * (2 / self.genome.ploidy)

    def sample_initial_effects(self):
        """
        Sample initial values for the genetic effects from a standard normal distribution.
        """
        self.effects = torch.randn((self.genome.n_chromosomes, self.genome.n_loci_per_chromosome), device=self.genome.device) 

    def scale_effects(self, founder_pop: Population):
        """
        Scale the marker effects to achieve the specified genetic variance in the founder population.
        """
        founder_genotypes = founder_pop.get_dosages().float().to(self.genome.device)  # Move to GPU
        scaled_dosages = self._calculate_scaled_additive_dosages(founder_genotypes)
        # Apply QTL map
        scaled_dosages = scaled_dosages * self.qtl_map[None, None, :, :]  
        genetic_values = torch.sum(scaled_dosages * self.effects[None, None, :, :], dim=(2, 3))
        current_mean = genetic_values.mean()
        self.intercept = self.target_mean - current_mean
        initial_variance = torch.var(genetic_values)
        scaling_constant = torch.sqrt(self.target_variance / initial_variance)
        self.effects = self.effects * scaling_constant
        # Intercept is now fixed to the target mean
        
#         current_mean = self.calculate_genetic_values(self.sim_param.founder_pop).mean()
#         self.intercept = self.target_mean - current_mean

    def forward(self, genotypes: torch.Tensor) -> torch.Tensor:
        """
        Calculate the genetic value of individuals

        Args:
            genotypes (torch.Tensor): A tensor representing the genotypes of individuals.
                                     Shape: (n_individuals, ploidy, n_chromosomes, n_loci_per_chromosome).

        Returns:
            torch.Tensor: Genetic values of individuals. Shape: (n_individuals)
        """
        genotypes = genotypes.to(self.genome.device) # Ensure genotypes are on the same device as effects
        scaled_dosages = self._calculate_scaled_additive_dosages(genotypes)
        # Apply QTL map
        scaled_dosages = scaled_dosages * self.qtl_map
        genetic_values = torch.sum(scaled_dosages * self.effects[None, None, :, :], dim=(2, 3)) + self.intercept
        return genetic_values
    
    
#example
#core logic
genome = Genome(n_loci_per_chromosome=50)
founder_pop = Population()
founder_pop.create_random_founder_population(genome, n_founders=1000)


#trait logic
qtl_map = select_qtl_loci(50, genome)
t = TraitA(genome, founder_pop, 500, 450)
#example getting breeding values for this trait for this pop
t(founder_pop.get_dosages())
