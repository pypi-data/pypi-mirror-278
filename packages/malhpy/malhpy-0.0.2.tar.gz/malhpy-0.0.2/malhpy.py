class TaskDictionary:
    def __init__(self):
        self.tasks = {
            "1. Написать программу с интерактивным консольным меню "
            "(т.е. выводсписка действий по цифрам) по вычислению площади круга (родительский класс),"
            "длины окружности (подкласс) и объема шара (подкласс) по задаваемому склавиатуры радиусу. "
            "Содержание меню: 1. Вычислить площадь круга. "
            "2.Вычислить длину окружности. 3. "
            "Вычислить объем шара.":
                "import math"
                "p = math.pi"
                "class Circle:"
                    "def __init__(self, radius):"
                        "self.radius = radius"
                    "def area(self):"
                        "return p * (self.radius ** 2)"
                "class Circumference(Circle):"
                    "def circumference(self):"
                        "return 2 * p * self.radius"
                "class Sphere(Circle):"
                    "def volume(self):"
                        "return (4 / 3) * p * (self.radius ** 3)"
                "def main():"
                    "while True:"
                        "print('Меню:')"
                        "print('1. Вычислить площадь круга')"
                        "print('2. Вычислить длину окружности')"
                        "print('3. Вычислить объем шара')"
                        "print('4. Выход')"
                        "choice = input()"
                        "if choice == '4':"
                            "break"
                        "radius = float(input('Введите радиус: '))"
                        "if choice == '1':)"
                            "circle = Circle(radius)"
                            "print(f'Площадь круга: {circle.area()}')"
                        "elif choice == '2':"
                            "circumference = Circumference(radius)"
                            "print(f'Длина окружности: {circumference.circumference()}')"
                        "elif choice == '3':"
                            "sphere = Sphere(radius)"
                            "print(f'Объем шара: {sphere.volume()}')"
                "if __name__ == '__main__':"
                    "main()",

            "2. Создать класс стек. Использовать способ реализации стека через list."
            "Поменять местами первый и последний элементы стека":
                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"
                    "def push(self, item):"
                        "self.items.append(item)"
                    "def swap_first_last(self):"
                        "self.items[0], self.items[-1] = self.items[-1], self.items[0]"
                    "stack = Stack()"
                    "stack.push(1)"
                    "stack.push(2)"
                    "stack.push(4)"                                                 
                    "print('Стек перед изменением:', stack.items)"
                    "stack.swap_first_last()"
                    "print('Стек после изменения:', stack.items) ",


            "3. Дан список А3, состоящий из четного количества элементов. "
            "Используяфункцию (функции) высшего порядка разбейте его на списки В, С так, чтобы в"
            "одном были положительные элементы, а в другом отрицательные.":
                "def sels(A3):"
                    "B = list(filter(lambda x: x < 0, A3))"
                    "C = list(filter(lambda x: x > 0, A3))"
                    "return B,C"
                "A3 = [-1,2,4,-5]"
                "B,C= sels(A3)"
                "print(B)"
                "print(C)",


            "4. Создать класс стек. Использовать способ реализации стека через list"
            ".Удалить элемент, который находится в середине стека, если нечетное числоэлементов, "
            "а если четное, то два средних.":
                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"
                                            
                    "def push(self, item):"
                        "self.items.append(item)"
                                            
                    "def remove_middle(self):"
                        "n = 6"
                        "if n == 0:"
                            "return"
                            "middle_index = n // 2"
                            "self.items.pop(middle_index)"                                      
                    "stack = Stack()"
                    "for i in range(1, 7):"
                        "stack.push(i)"                                           
                    "print(stack.items)"
                    "stack.remove_middle()"
                    "print(stack.items)",


            "5. Создать класс Plane (самолетов), имеющий атрибуты: название самолета,"
            "количество пассажиров на борту, курс движения (откуда и куда). Методы: -"
            "определить загрузку самолета, если максимальная вместимость =200 пассажиров;"
            "– определить все имена самолетов, летящих по одному маршруту; - определить"
            "среднюю загрузку всех самолетов.":
                "class Plane:"
                "max_capacity = 200"
                "planes = []"
                "def __init__(self, name, passengers, route):"
                "self.name = name"
                "self.passengers = passengers"
                "self.route = route"
                "Plane.planes.append(self)"
                "def load_percentage(self):"
                "return (self.passengers / Plane.max_capacity) * 100"
                "def planes_on_route(route):"
                "return [plane.name for plane in Plane.planes if plane.route == route]"
                "def average_load():"
                "total_passengers = sum(plane.passengers for plane in Plane.planes)"
                "return (total_passengers / (len(Plane.planes) * Plane.max_capacity)) * 100 if Plane.planes else 0"
                "plane1 = Plane('Boeing 737', 150, 'NYC-LAX')"
                "plane2 = Plane('Airbus A320', 180, 'NYC-LAX')"
                "plane3 = Plane('Boeing 747', 20, 'NYC-LHR')  "
                "print('Загрузка самолета 1:', plane1.load_percentage(), '%')"
                "print('Загрузка самолета 2:', plane2.load_percentage(), '%')"
                "print('агрузка самолета 3:', plane3.load_percentage(), '%')"
                "print('Самолеты на маршруте NYC-LAX:', Plane.planes_on_route('NYC-LAX'))"
                "print('Средняя загрузка всех самолетов:', Plane.average_load(), '%')",




            "6. Создать класс стек. Использовать способ реализации стека через list."
            "Удалить каждый второй элемент стека.":
                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"
                                                        
                    "def push(self, item):"
                        "self.items.append(item)"
                                                        
                    "def remove_every_second(self):"
                        "self.items = [item for index, item in enumerate(self.items) if index % 2 == 0]"
                                                    
                "stack = Stack()"
                "for i in range(1, 11):"
                "stack.push(i)"
                                                    
                "print(stack.items)"
                "stack.remove_middle()"
                "print(stack.items)",


            "7. Дано предложение без знаков препинания. Превратить предложение в"
            "список слов. При помощи механизма map/filter/reduce отбросить у каждого слова"
            "последнюю букву и склеить в одну строку те обрезанные слова, длина которых"
            "больше 5.":
                "from functools import reduce"
                "def rezult(states):"
                "words = states.split()"
                "a = list(map(lambda x: x[:-1], words))"
                "b = list(filter(lambda x: len(x)>5, a))"
                "r = reduce(lambda x, y: x + y, b, "")"
                "return r"
                "states = 'This is an example sentence without punctuation'"
                "re = rezult(states)"
                "print(re)",

            "8. Создать класс стек. Использовать способ реализации стека через list. Найти"
            "минимальный элемент стека и вставить после него «0»":
                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"

                    "def push(self, item):"
                        "self.items.append(item)"

                    "def find_min_and_insert_zero(self):"
                        "min_value = min(self.items)"
                        "min_index = self.items.index(min_value)"
                        "self.items.insert(min_index + 1, 0)"


                "stack = Stack()"
                "for i in [5, 3, 8, 1, 2, 9]:"
                "stack.push(i)"

                "print(stack.items)"
                "stack.remove_middle()"
                "print(stack.items)",


            "9. Дан список S состоящий из N различных элементов. Вывести индексы"
            "четных элементов списка. Использовать встроенные функции высшего порядка.":
                "def rezult(S):"
                    "return list(map(lambda x:x[0], filter(lambda x:x[1]%2==0, enumerate(S))))"
                "S = [10, 12, 5, 6, 3, 8, 9, 10, 11]"
                "re = rezult(S)"
                "print(S)"
                "print(re)",


            "10. Реализовать декоратор с именем not_none, который генерирует"
            "исключительную ситуацию если декорируемая функция вернула значения None.":
                "def not_none(func):"
                    "def wrapper(*args, **kwargs):"
                        "result = func(*args, **kwargs)"
                        "if result is None:"
                            "raise ValueError('Function returned None')"
                        "return result"
                    "return wrapper"
                "@not_none"
                "def example_function(x):"
                    "if x > 0:"
                        "   return x"
                    "else:"
                        "return None"
                "try:"
                "print(example_function(5)) "
                "print(example_function(-1)) "
                "except ValueError as e:"
                "print(e)",

            "11. Создайте класс Speed (Скорость), имеющий атрибуты: value (значение),"
            "unit (единица измерения). При изменении единицы измерения значение должно"
            "соответственно меняться. Например, при переходе от км/ч к м/с и наоборот."
            "Например, 20 км/ч = 5.56 м/с. Допустимые значения свойства unit: ‘м/с’, ‘км/ч’."
            "Организуйте эту проверку. Продемонстрируйте работу с классом.":
                "class Speed:"
                    "def __init__(self, value, unit):"
                        "if unit not in ['м/с', 'км/ч']:"
                        "raise ValueError('Недопустимая единица измерения. Допустимые значения: 'м/с', 'км/ч')"
                        "self.value = value"
                        "self.unit = unit"
                    "def to_mps(self):"
                        "if self.unit == 'км/ч':"
                            "return self.value / 3.6"
                        "return self.value"
                    "def to_kph(self):"
                        "if self.unit == 'м/с':"
                            "return self.value * 3.6"
                        "return self.value"
                    "def set_unit(self, new_unit):"
                        "if new_unit not in ['м/с', 'км/ч']:"
                            "raise ValueError('Недопустимая единица измерения. Допустимые значения: 'м/с', 'км/ч')"
                        "if self.unit != new_unit:"
                            "if new_unit == 'м/с':"
                                "self.value = self.to_mps()"
                            "elif new_unit == 'км/ч':"
                                "self.value = self.to_kph()"
                                "self.unit = new_unit"
                    "def __str__(self):"
                        "return f'{self.value:.2f} {self.unit}'"
                "speed = Speed(20, 'км/ч')"
                "print(speed)  # Вывод: 20.00 км/ч"
                "speed.set_unit('м/с')"
                "print(speed) "
                "speed.set_unit('км/ч')"
                "print(speed)  ",

            "12. Реализовать декоратор с именем print_type, выводящий на печать тип"
            "значения, возвращаемого декорируемой функцией.":


                "def funs(f):"
                    "def w(*args, **kwargs):"
                        "rezult = f(*args, **kwargs)"
                        "print(type(rezult))"
                        "return rezult"
                    "return w"
                "@funs"
                "def f(x,y):"
                    "return x+y"
                "@funs"
                "def g():"
                    "return [1,2,3]"
                "print(f(5,6))"
                "print(g())",

            "13. Создать класс стек. Использовать способ реализации стека через list."
            "Удалить минимальный элемент стека":
                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"

                    "def push(self, item):"
                        "self.items.append(item)"
                    "def rezult(self):"
                        "m = min(self.item)"
                        "self.item.remove(m)"
               
                "stack = Stack()"
                "for i in [5, 3, 8, 1, 2, 9]:"
                "stack.push(i)"

                "print(stack.items)"
                "stack.remove_middle()"
                "print(stack.items)",


            "14. Задано положительное и отрицательное число в двоичной системе."
            "Составить программу вычисления суммы этих чисел, используя функцию"
            "сложения чисел в двоичной системе счисления. Использовать рекурсию.":
                "a = '1101'"
                "b = '1001'"
                "def rez(a,b):"
                    "a_10 = int(a, 2)"
                    "b_10 = int(b, 2)"
                    "c_10 = a_10 - b_10"
                    "c = bin(c_10)[2:]"
                    "return c"
                "print(rez(a,b))",

            "15. Вывести по убыванию количество всех предыдущих ремонтов машин"
            "'Жигули'. Реализовать с помощью алгоритма сортировки слиянием.":
                "def merge_sort(arr):"
                "if len(arr) > 1:"
                "mid = len(arr) // 2"
                "left_half = arr[:mid]"
                "right_half = arr[mid:]"
                "merge_sort(left_half)"
                "merge_sort(right_half)"
                "i = j = k = 0"
                "while i < len(left_half) and j < len(right_half):"
                "if left_half[i] > right_half[j]:"
                "arr[k] = left_half[i]"
                "i += 1"
                "else:"
                "arr[k] = right_half[j]"
                "j += 1"
                "k += 1"
                "while i < len(left_half):"
                "arr[k] = left_half[i]"
                "i += 1"
                "k += 1"
                "while j < len(right_half):"
                "arr[k] = right_half[j]"
                "j += 1"
                "k += 1"
                "def previous_repairs_count(cars):"
                "repairs = []"
                "for car in cars:"
                "if car[0] == 'Жигули':"
                "repairs.append(car[1])"
                "merge_sort(repairs)"
                "return repairs"
                "cars = ["
                "('Жигули', 5),"
                "('Лада', 3),"
                "('Жигули', 7),"
                "('Форд', 2),"
                "('Жигули', 6),"
                "('Жигули', 4)"
                "]"
                "sorted_repairs = previous_repairs_count(cars)"
                "print('Количество ремонтов машин 'Жигули' по убыванию:', sorted_repairs)",


            "16. Написать программу с интерактивным консольным меню (т.е. вывод"
            "списка действий по цифрам) по удалению из списка (задаем с клавиатуры) элемента"
            "с задаваемым с клавиатуры индексом (например, m). При решении задачи"
            "необходимо использовать функцию map. Содержание меню: 1. Удалить элемент из"
            "списка и вывести итоговый список. 2. Удалить элемент из списка и вывести его"
            "номер(а).":
                "def f(a,index ):"
                    "return list(map(lambda x: x[0], filter(lambda x: x[1]!= index , enumerate(a))))"
                "def s(a,index ):"
                    "return list(map(lambda x: x[0], filter(lambda x: x[0] == index , enumerate(a))))"
                "def main():"
                    "le = input().split()"
                    "le = [int(x) for x in le]"
                    "index = int(input())"
                    "do = int(input())"
                    "if do == 1:"
                        "cros_f = f(le, index)"
                        "print(cros_f)"
                    "else:"
                        "cros_s = f(le, index)"
                        "print(cros_s)"
                "if __name__ == '__main__':"
                "main()",


            "17. Задание: построить базовый класс с указанными в таблице полями иметодами:"
            "- конструктор; - функция, которая определяет «качество» объекта – Q позаданной формуле; - метод"
            "вывода информации об объекте.Построить дочерний класс (класс-потомок), который содержит:"
            "- дополнительное поле P;- функция, которая определяет «качество» объекта дочернего класса – Qp и"
            "перегружает функцию качества родительского класса (Q), выполняя вычисление по"
            "новой формуле.Создать проект для демонстрации работы: ввод и вывод информации обобъектах классов":


                "",
            "18. Написать программу с интерактивным консольным меню (т.е. вывод"
            "списка действий по цифрам) по вычислению площади прямоугольника"
            "(родительский класс), и периметра прямоугольника (дочерний класс) по"
            "задаваемой с клавиатуры длине сторон прямоугольника."
            "Содержание меню: 1. Вычислить площадь прямоугольника. 2. Вычислить периметр прямоугольника":

                "class Rectangle:"
                    "def __init__(self, a, b):"
                        "self.a = a"
                        "self.b = b"
                    "def S(self):"
                        "return self.a*self.b"
                "class Push(Rectangle):"
                    "def P(self):"
                        "return self.a*2+self.b*2"
                "def main():"
                    "while True:"
                        "print('Меню:')"
                        "print('1. Вычислить площадь круга')"
                        "print('2. Вычислить длину окружности')"
                        "choice = input()"
                        "a = float(input('Введите радиус: '))"
                        "b = float(input('Введите радиус: '))"
                        "if choice == '1':"
                            "print(f'Площадь круга: {Rectangle(a,b).S()}')"
                        "elif choice == '2':"
                            "print(f'Длина окружности: {Push(a,b).P()}')"
                "if __name__ ==  '__main__':"
                "main()",


            "20. С помощью функции reduce() вычислить двойной факториал заданного"
            "натурального числа n (для четного или нечетного n).":
                "from functools import reduce"
                "def f(n):"
                    "return reduce(lambda x, y: x*y, range(n,0,-2))"
                "n = 7"
                "rez =f(n)"
                "print(rez)",

            "21. Создайте класс Заказ(Order), у которого есть свойства код_товара(code),"
            "цена(price), количество(count) и методы __init__ и __str__. Создайте 2 класса-"
            "потомка: Опт(Opt) и Розница(Retail). В этих классах создайте методы __init__,"
            "__str__ и сумма_заказа (summa), позволяющий узнать стоимость заказа. Для опта"
            "стоимость единицы товара составляет 95% от цены, а при покупке более 500 штук"
            "– 90% цены. В розницу стоимость единицы товара составляет 100% цены."
            "Стоимость заказа равна произведению цены на количество. Создайте список,"
            "содержащий по 2 объекта каждого класса (Order, Opt, Retail). Для этого списка:•"
            "выведите информацию о каждом объекте с помощью метода __str__;•"
            "найдите общую стоимость заказов для объектов Opt и Retail.":
                "class Order:"
                "def __init__(self, code, price, count):"
                "self.code = code"
                "self.price = price"
                "self.count = count"
                "def __str__(self):"
                "return f'Код товара: {self.code}, Цена: {self.price}, Количество: {self.count}'"
                "class Opt(Order):"
                "def __init__(self, code, price, count):"
                "super().__init__(code, price, count)"
                "def summa(self):"
                "if self.count > 500:"
                "unit_price = self.price * 0.9"
                "else:"
                "unit_price = self.price * 0.95"
                "return unit_price * self.count"
                "def __str__(self):"
                "return super().__str__() + f', Сумма заказа: {self.summa()}('"
                "class Retail(Order):)"
                "def __init__(self, code, price, count):"
                "super().__init__(code, price, count)"
                "def summa(self):"
                "return self.price * self.count"
                "def __str__(self):"
                "return super().__str__() + f', Сумма заказа: {self.summa()}'"
                "orders = ["
                "Order('A001', 100, 10),"
                "Order('A002', 150, 5),"
                "Opt('B001', 200, 600),"
                "Opt('B002', 250, 300),"
                "Retail('C001', 50, 20),"
                "Retail('C002', 75, 10)"
                "]"
                "for order in orders:"
                "print(order)"
                "total_sum = sum(order.summa() for order in orders if isinstance(order, (Opt, Retail)))"
                "print(f'Общая стоимость заказов для объектов Opt и Retail: {total_sum}')",

            "22. Создать класс Деньги для работы с денежными суммами. Число должно"
            "быть представлено списком, состоящим из рублей и копеек. Реализовать сложение,"
            "вычитание, деление сумм, деление денежных сумм.":
                "class Money:"
                "def __init__(self, rubles, kopecks):"
                    "self.rubles = rubles"
                    "self.kopecks = kopecks"
                    "self.normalize()"
                "def normalize(self):"
                    "if self.kopecks >= 100:"
                        "self.rubles += self.kopecks // 100"
                        "self.kopecks = self.kopecks % 100"
                    "elif self.kopecks < 0:"
                        "self.rubles -= (-self.kopecks) // 100 + 1"
                        "self.kopecks = 100 - (-self.kopecks) % 100"
                "def __add__(self, other):"
                    "rubles = self.rubles + other.rubles"
                    "kopecks = self.kopecks + other.kopecks"
                    "return Money(rubles, kopecks)"
                "def __sub__(self, other):"
                    "rubles = self.rubles - other.rubles"
                    "kopecks = self.kopecks - other.kopecks"
                    "return Money(rubles, kopecks)"
                "def __truediv__(self, other):"
                    "total_kopecks_self = self.rubles * 100 + self.kopecks"
                    "total_kopecks_other = other.rubles * 100 + other.kopecks"
                    "result = total_kopecks_self / total_kopecks_other"
                    "return result"
                "def __floordiv__(self, number):"
                    "total_kopecks = self.rubles * 100 + self.kopecks"
                    "result_kopecks = total_kopecks // number"
                    "rubles = result_kopecks // 100"
                    "kopecks = result_kopecks % 100"
                    "return Money(rubles, kopecks)"
                "def __str__(self):"
                    "return f'{self.rubles} рублей {self.kopecks} копеек'"
                "money1 = Money(10, 150)"
                "money2 = Money(5, 75)"
                "print('Money 1:', money1)"
                "print('Money 2:', money2)"
                "sum_money = money1 + money2"
                "print('Сумма:', sum_money)"
                "diff_money = money1 - money2"
                "print('Разность:', diff_money)"
                "div_money = money1 / money2"
                "print('Частное:', div_money)"
                "div_by_number = money1 // 3"
                "print('Деление на число:', div_by_number)",


            "23. Дан кольцевой список из 20 фамилий студентов. Разбить студентов на 2"
            "группы по 10 человек. Во вторую группу попадает каждый 11-й человек.":
                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class CircularLinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                    "def append(self, data):"
                        "new_node = Node(data)"
                        "if not self.head:"
                            "self.head = new_node"
                            "new_node.next = self.head"
                        "else:"
                            "current = self.head"
                            "while current.next != self.head:"
                                "current = current.next"
                            "current.next = new_node"
                            "new_node.next = self.head"
                    "def to_list(self):"
                        "items = []"
                        "current = self.head"
                        "if not self.head:"
                            "return items"
                        "while True:"
                            "items.append(current.data)"
                            "current = current.next"
                            "if current == self.head:"
                                "break"
                        "return items"
                    "def split_students(students):"
                        "cll = CircularLinkedList()"
                        "for student in students:"
                            "cll.append(student)"
                        "group1 = []"
                        "group2 = []"
                        "current = cll.head"
                        "count = 0"
                        "while len(group1) < 10:"
                            "count += 1"
                            "if count % 11 == 0:"
                                "group2.append(current.data)"
                            "else:"
                                "group1.append(current.data)"
                            "current = current.next"
                        "while len(group2) < 10:"
                            "if current.data not in group1 and current.data not in group2:"
                                "group2.append(current.data)"
                            "current = current.next"
                        "return group1, group2"
                "students = ["
                "'Иванов', 'Петров', 'Сидоров', 'Кузнецов', 'Попов',"
                "'Васильев', 'Соколов', 'Михайлов', 'Новиков', 'Федоров',"
                "'Морозов', 'Волков', 'Алексеев', 'Лебедев', 'Семенов',"
                "'Егоров', 'Павлов', 'Козлов', 'Степанов', 'Никитин'"
                "]"
                "group1, group2 = split_students(students)"
                "print('Группа 1:', group1)"
                "print('Группа 2:', group2)",


            "24. Составить программу для нахождения числа, которое образуется из"
            "данного натурального числа при записи его цифр в обратном порядке. Например,"
            "для числа 1234 получаем результат 4321. Использовать рекурсию.":

                "def reverse_number(n, reversed_n=0):"
                    "if n == 0:"
                        "return reversed_n"
                    "else:"
                        "return reverse_number(n // 10, reversed_n * 10 + n % 10)"
                "original_number = 1234"
                "reversed_number = reverse_number(original_number)"
                "print( {original_number} , {reversed_number})",


            "25. Создать класс стек. Использовать способ реализации стека через list."
            "Сформировать стек с элементами - строками. Прочитать три нижних элемента"
            "стека и поменять местами верхний и нижний элементы.":

                "class Stec:"
                    "def __init__(self):"
                        "self.inul = []"
                        "self.inul1 = []"
                    "def push(self, n):"
                        "self.inul.append(n)"
                        "self.inul1.append(n)"
                    "def rezult(self):"
                        "self.inul[0], self.inul[-1] = self.inul[-1], self.inul[0]"
                    "def rezult1(self):"
                        "self.inul1 = self.inul1[0], self.inul1[1], self.inul1[2]"
                "stec = Stec()"
                "for i in ['apple', 'banana', 'cherry', 'date', 'elderberry']:"
                "stec.push(i)"
                "print(stec.inul)"
                "stec.rezult()"
                "print(stec.inul)"
                "stec.rezult1()"
                "print(stec.inul1)",


            "26. Дан список А3, состоящий из четного количества элементов. Используя"
            "функцию(функции) высшего порядка разбейте его на списки В, С так, чтобы в"
            "одном были положительные элементы, а в другом отрицательные.":

                "def functhen(A3):"
                    "C = (list(filter(lambda x : x > 0, A3)))"
                    "B = (list(filter(lambda x: x < 0, A3)))"
                    "return C , B"
                "A3 = [-2,1,4,5,-4,-5,--8,2,3,-10]"
                "pc = functhen(A3)"
                "print(pc)",

            "27. Создайте класс Студент, имеющий:"
            "•закрытый атрибут Имя – строка, содержащая фамилию;"
            "•метод __init__. При создании объекта указывается имя, списокДисциплины пустой"
            "•закрытый атрибут Дисциплины – словарь сданных дисциплин. Ключом"
            "является название дисциплины, значением – оценка."
            "•метод put добавляет новую дисциплину в атрибут Дисциплины."
            "Параметрами метода являются название дисциплины и оценка;"
            "•свойство Сдано возвращает список названий сданных дисциплин;"
            "Создайте экземпляр класса, продемонстрируйте работу с атрибутами, методами и свойствами.":

                "class Student:"
                "def __init__(self, name):"
                "self.__name = name"
                "self.__disciplines = {}"
                "def put(self, discipline, grade):"
                "self.__disciplines[discipline] = grade"
                "@property"
                "def disciplines(self):"
                "return list(self.__disciplines.keys())"
                "student = Student('Иванов')"
                "student.put('Математика', 5)"
                "student.put('Физика', 4)"
                "student.put('Химия', 3)"
                "print(f'Имя студента: {student._Student__name}')  # доступ к закрытому атрибуту"
                "print('Список дисциплин:', student.disciplines)"
                "print('Оценки:', student._Student__disciplines)",


            "28. Дан список S состоящий из N различных элементов. Вывести индексы"
            "четных элементов списка. Использовать функции высшего порядка.":

                "def rezult(S):"
                    "return list(map(lambda x:x[0], filter(lambda x:x[1] % 2 == 0, enumerate(S))))"
                "S = [10, 15, 20, 25, 30, 35, 40]"
                "print(S)"
                "re = rezult(S)"
                "print(re)",
            "29. Дан однонаправленный связный список. Вставить элемент после n-го"
            "элемента списка.":

                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class LinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                    "def append(self, data):"
                        "new_node = Node(data)"
                        "if self.head is None:"
                            "self.head = new_node"
                            "return"
                        "last = self.head"
                        "while last.next:"
                            "last = last.next"
                        "last.next = new_node"
                    "def insert_after_nth(self, n, data):"
                        "new_node = Node(data)"
                        "current = self.head"
                        "count = 0"
                        "while current is not None:"
                            "if count == n:"
                                "new_node.next = current.next"
                                "current.next = new_node"
                            "return"
                        "current = current.next"
                        "count += 1"
                        "raise IndexError('List index out of range')"
                    "def to_list(self):"
                        "result = []"
                        "current = self.head"
                        "while current:"
                            "result.append(current.data)"
                            "current = current.next"
                        "return result"
                "ll = LinkedList()"
                "for i in [1, 2, 3, 4, 5]:"
                "ll.append(i)"
                "print('Список перед вставкой:', ll.to_list())"
                "n = 2"
                "data = 99"
                "ll.insert_after_nth(n, data)"
                "print('Список после вставки:', ll.to_list())"
                "",

            "30. Создать декоратор tol(len, fill) с параметрами len и fill."
            " Декораторпревращает результат декорируемой функции в список состоящий из len"
            "элементов. Если исходная функция возвращает меньше заданного количества"
            "элементов, то оставшиеся места заполняются значениями fill, в случае, если"
            "количество возвращаемых элементов больше len, то хвост последовательности"
            "отбрасывается.":

                "def tol(length, fill):"
                    "def decorator(func):"
                        "def wrapper(*args, **kwargs):"
                            "result = func(*args, **kwargs)"
                            "if len(result) < length:"
                                "result.extend([fill] * (length - len(result)))"
                            "elif len(result) > length:"
                                "result = result[:length]"
                            "return result"
                        "return wrapper"
                    "return decorator"
                "@tol(5, 0)"
                "def example_function():"
                    "return [1, 2, 3]"
                "@tol(3, 'x')"
                "def another_function():"
                    "return [4, 5, 6, 7, 8]"
                "print(example_function())"
                "print(another_function())",

            "31. Реализовать однонаправленный связанный список (реализовать класс для"
            "элементов списка). Преобразовать строку 'Eeny, meeny, miney, moe; Catch a tiger by"
            "his toe.' в связный список символов строки и удалить из него все элементы"
            "содержащие гласные буквы.":
                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class SinglyLinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                    "def append(self, data):"
                        "new_node = Node(data)"
                        "if not self.head:"
                            "self.head = new_node"
                        "else:"
                            "current = self.head"
                            "while current.next:"
                                "current = current.next"
                            "current.next = new_node"
                    "def to_list(self):"
                        "items = []"
                        "current = self.head"
                        "while current:"
                            "items.append(current.data)"
                            "current = current.next"
                        "return items"
                    "def remove_vowels(self):"
                        "vowels = 'aeiouAEIOU'"
                        "current = self.head"
                        "prev = None"
                        "while current:"
                            "if current.data in vowels:"
                                "if prev:"
                                    "prev.next = current.next"
                                "else:"
                                    "self.head = current.next"
                                "else:"
                                    "prev = current"
                            "current = current.next"
                "input_string = 'Eeny, meeny, miney, moe; Catch a tiger by his toe.'"
                "linked_list = SinglyLinkedList()"
                "for char in input_string:"
                "linked_list.append(char)"
                "print('Связный список до удаления гласных:', ''.join(linked_list.to_list()))"
                "linked_list.remove_vowels()"
                "print('Связный список после удаления гласных:', ''.join(linked_list.to_list()))",

            "32. Создать базовый класс по следующей предметной области. Известны"
            "оклад (зарплата) и ставка процента подоходного налога. Определить размер"
            "подоходного налога и сумму, получаемую на руки. Исходными данными являются"
            "величина оклада (переменная oklad, выражаемая числом) и ставка подоходного"
            "налога (переменная procent, выражаемая числом). Размер налога (переменнаяnalog) определяется как oklad∗procent/100, а сумма, получаемая на руки"
            "(переменная summa) — как oklad-nalog.":


                "class Salary:"
                    "def __init__(self, oklad, procent):"
                        "self.oklad = oklad"
                        "self.procent = procent"
                        "def calculate_nalog(self):"
                        "return self.oklad * self.procent / 100"
                    "def calculate_summa(self):"
                        "nalog = self.calculate_nalog()"
                        "return self.oklad - nalog"
                    "def display_info(self):"
                        "nalog = self.calculate_nalog()"
                        "summa = self.calculate_summa()"
                        "print(f'Оклад: {self.oklad} рублей')"
                        "print(f'Ставка подоходного налога: {self.procent}%')"
                        "print(f'Размер налога: {nalog} рублей')"
                        "print(f'Сумма на руки: {summa} рублей')"
                "salary = Salary(50000, 13)"
                "salary.display_info()",


            "33. Вывести по убыванию количество всех предыдущих ремонтов машин"
            "'Жигули'. Реализовать с помощью алгоритма сортировки слиянием.":
                "def merge_sort(arr):"
                    "if len(arr) > 1:"
                        "mid = len(arr) // 2"
                        "left_half = arr[:mid]"
                        "right_half = arr[mid:]"
                        "merge_sort(left_half)"
                        "merge_sort(right_half)"
                        "i = j = k = 0"
                        "while i < len(left_half) and j < len(right_half):"
                            "if left_half[i] > right_half[j]:"
                                "arr[k] = left_half[i]"
                                "i += 1"
                            "else:"
                                "arr[k] = right_half[j]"
                                "j += 1"
                                "k += 1"
                            "while i < len(left_half):"
                                "arr[k] = left_half[i]"
                                "i += 1"
                                "k += 1"
                            "while j < len(right_half):"
                                "arr[k] = right_half[j]"
                                "j += 1"
                                "k += 1"
                "def previous_repairs_count(cars):"
                    "repairs = []"
                        "for car in cars:"
                            "if car[0] == 'Жигули':"
                                "repairs.append(car[1])"
                    "merge_sort(repairs)"
                    "return repairs"
                "cars = ["
                    "('Жигули', 5),"
                    "('Лада', 3),"
                    "('Жигули', 7),"
                    "('Форд', 2),"
                    "('Жигули', 6),"
                    "('Жигули', 4)"
                "]"
                "sorted_repairs = previous_repairs_count(cars)"
                "print('Количество ремонтов машин 'Жигули' по убыванию:', sorted_repairs)",

            "34. Описать рекурсивные функции Fact(N) и Fact2(N) вещественного типа,"
            "вычисляющие значения факториала N! и двойного факториала N!! соответственно"
            "(N > 0 — параметр целого типа)":

                "def Fact(N):"
                    "if N == 1:"
                        "return 1"
                    "else:"
                        "return N * Fact(N - 1)"
                "def Fact2(N):"
                    "if N <= 0:"
                        "return 1"
                    "elif N == 1:"
                        "return 1"
                    "else:"
                        "return N * Fact2(N - 2)"
                "N = 5"
                "fact_result = Fact(N)"
                "fact2_result = Fact2(N)"
                "print(f'Факториал числа {N}: {fact_result}')"
                "print(f'Двойной факториал числа {N}: {fact2_result}')",

            "35 Дан однонаправленный связный список. Удалить каждый второй элемент списка.":

                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class LinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                    "def append(self, data):"
                        "new_node = Node(data)"
                        "if self.head is None:"
                            "self.head = new_node"
                            "return"
                        "last = self.head"
                        "while last.next:"
                            "last = last.next"
                        "last.next = new_node"
                    "def to_list(self):"
                        "result = []"
                        "current = self.head"
                        "while current:"
                            "result.append(current.data)"
                            "current = current.next"
                        "return result"
                "ll = LinkedList()"
                "for i in range(1, 11):  # Добавим элементы от 1 до 10"
                    "ll.append(i)"
                "print('Список перед удалением каждого второго элемента:', ll.to_list())"
                "ll.delete_every_second()"
                "print('Список после удаления каждого второго элемента:', ll.to_list())",
            "36. Создать иерархию классов для фруктов, продающихся в магазине."
            "Иерархия должна содержать не менее 3 классов. Объекты должны содержать не"
            "менее 3-х атрибутов. Часть атрибутов должна быть защищена от изменения."
            "Необходимо заполнить список представителями всех классов (всего 5 объектов) и"
            "продемонстрировать созданную защиту.":
                "class Fruit:"
                "def __init__(self, name, color, price_per_kg):"
                "self._name = name"
                "self._color = color"
                "self._price_per_kg = price_per_kg"
                "def display_info(self):"
                "print(f'Название: {self._name}, Цвет: {self._color}, Цена за кг: {self._price_per_kg} рублей')"
                "class Citrus(Fruit):"
                "def __init__(self, name, color, price_per_kg, acidity):"
                "super().__init__(name, color, price_per_kg)"
                "self.acidity = acidity"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Кислотность: {self.acidity}')"
                "class Berry(Fruit):"
                "def __init__(self, name, color, price_per_kg, sweetness):"
                "super().__init__(name, color, price_per_kg)"
                "self.sweetness = sweetness"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Сладость: {self.sweetness}')"
                "class Tropical(Fruit):"
                "def __init__(self, name, color, price_per_kg, juiciness):"
                "super().__init__(name, color, price_per_kg)"
                "self.juiciness = juiciness"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Сочность: {self.juiciness}')"
                "fruits = ["
                "Citrus('Апельсин', 'Оранжевый', 120, 'Высокая'),"
                "Berry('Клубника', 'Красная', 300, 'Средняя'),"
                "Tropical('Манго', 'Желтый', 500, 'Высокая'),"
                "Citrus('Лимон', 'Желтый', 150, 'Очень высокая'),"
                "Berry('Черника', 'Синяя', 400, 'Высокая')"
                "]"
                "try:"
                "fruits[0]._name = 'Мандарин'"
                "except AttributeError as e:"
                "print(e)"
                "for fruit in fruits:"
                "fruit.display_info()"
                "print()"
                "",

            "37. Расположить по алфавиту имена владельцев и, соответственно, вывести"
            "информацию об их машинах. Использовать алгоритм сортировки выбором.":
                "cars = ["
                    "{'owner': 'Иван', 'car': 'Lada'},"
                    "{'owner': 'Алексей', 'car': 'BMW'},"
                    "{'owner': 'Мария', 'car': 'Audi'},"
                    "{'owner': 'Сергей', 'car': 'Mercedes'},"
                    "{'owner': 'Ольга', 'car': 'Toyota'}"
                "]"
                "def selection_sort(arr, key):"
                    "for i in range(len(arr)):"
                        "idx = i"
                        "for j in range(i + 1, len(arr)):"
                            "if arr[j][key] < arr[idx][key]:"
                                "idx = j"
                        "arr[i], arr[idx] = arr[idx], arr[i]"
                    "return arr"
                "sorted_cars = selection_sort(cars, key='owner')"
                "for car_info in sorted_cars:"
                    "print(f'Владелец: {car_info['owner']}, Автомобиль: {car_info['car']}')",


            "38. Описать рекурсивную функцию Root (а, b, ε), которая методом деления"
            "отрезка пополам находит с точностью ε корень уравнения f(x) = 0 на отрезке [а, b]"
            "(считать, что ε > 0, а < b, f(a) – f(b) < 0 и f(x) — непрерывная и монотонная на"
            "отрезке [а, b] функция).":
                "def f(x):"
                    "return x**2 - 4"
                "def root(a, b, epsilon):"
                    "if f(a) * f(b) >= 0:"
                        "raise ValueError('f(a) и f(b) должны иметь разные знаки')"
                    "mid = (a + b) / 2.0"
                    "if abs(f(mid)) <= epsilon:"
                        "return mid"
                    "elif f(a) * f(mid) < 0:"
                        "return root(a, mid, epsilon)"
                    "else:"
                        "return root(mid, b, epsilon)"
                "a = 1"
                "b = 3"
                "epsilon = 0.0001"
                "root_value = root(a, b, epsilon)"
                "print(f'Корень уравнения на отрезке [{a}, {b}] с точностью {epsilon}: {root_value}')",

            "39. Дан одномерный массив целых чисел размерности n, заданных"
            "случайным образом из интервала от -20 до 20. Если сумма отрицательных"
            "элементов по модулю превышает сумму положительных, то отсортировать массив"
            "по возрастанию, иначе – по убыванию. Реализовать сортировку алгоритмом"
            "сортировки выбором":
                "import random"
                "def selection_sort(arr, ascending=True):"
                    "for i in range(len(arr)):"
                        "idx = i"
                        "for j in range(i + 1, len(arr)):"
                            "if (arr[j] < arr[idx] and ascending) or (arr[j] > arr[idx] and not ascending):"
                                "idx = j"
                        "arr[i], arr[idx] = arr[idx], arr[i]"
                    "return arr"
                "def sum_positive_negative(arr):"
                    "positive_sum = sum(x for x in arr if x > 0)"
                    "negative_sum = sum(abs(x) for x in arr if x < 0)"
                    "return positive_sum, negative_sum"
                "n = 20"
                "arr = [random.randint(-20, 20) for _ in range(n)]"
                "positive_sum, negative_sum = sum_positive_negative(arr)"
                "sorted_arr = selection_sort(arr[:], ascending=negative_sum > positive_sum)"
                "print('Исходный массив:', arr)"
                "print('Сумма положительных элементов:', positive_sum)"
                "print('Сумма модулей отрицательных элементов:', negative_sum)"
                "print('Отсортированный массив:', sorted_arr)",


            "40. Создать декоратор dec(a, b) с параметрами a и b. Декоратор увеличивает"
            "результат декорируемой функции, которая вычисляет сумму произвольного"
            "количества чисел, на «a» элементов при условии положительного значения суммы."
            "Если исходная функция возвращает отрицательное значение суммы, то декоратор"
            "уменьшает результат декорируемой функции на значение «b».":
                "def dec(a, b):"
                    "def decorator(func):"
                        "def wrapper(*args):"
                        "result = func(*args)"
                            "if result > 0:"
                                "return result + a"
                            "else:"
                                "return result - b"
                        "return wrapper"
                    "return decorator"
                "@dec(5, 3)"
                "def sum_numbers(*args):"
                "   return sum(args)"
                "print(sum_numbers(1, 2, 3))"
                "print(sum_numbers(-1, -2, -3)) "
                "print(sum_numbers(10, -5, -2))"
                "print(sum_numbers(-10, 5, 1))",



            "41. Дан одномерный массив целых чисел размерности n, заданных"
            "случайным образом из интервала от -20 до 20. Если в массиве есть отрицательные"
            "элементы, то отсортировать массив по возрастанию, иначе - по убыванию."
            "Реализовать сортировку алгоритмом сортировки вставками.":

                "def insertion_sort(arr, ascending=True):"
                    "for i in range(1, len(arr)):"
                        "key = arr[i]"
                        "j = i - 1"
                        "if ascending:"
                            "while j >= 0 and key < arr[j]:"
                            "arr[j + 1] = arr[j]"
                            "j -= 1"
                        "else:"
                            "while j >= 0 and key > arr[j]:"
                            "arr[j + 1] = arr[j]"
                            "j -= 1"
                            "arr[j + 1] = key"
                "def sort_array_based_on_condition(arr):"
                    "if any(x < 0 for x in arr):"
                        "insertion_sort(arr, ascending=True)"
                    "else:"
                        "insertion_sort(arr, ascending=False)"
                        "return arr"
                "n = [-3, 12, -13, -6, 19, 15, -10, 5, 16, 17]"
                "print('Исходный массив:', n)"
                "sorted_array = sort_array_based_on_condition(n))"
                "print('Отсортированный массив:', sorted_array)",

            "42. Дан список целых чисел. При помощи механизма map/filter/reduce"
            "рассчитать остаток от деления на 7 для каждого из чисел списка и получить"
            "произведение тех остатков, величина которых больше 4":
                "from functools import reduce"
                "numbers = [34, 51, 68, 85, 102, 119, 136]"
                "remainders = list(map(lambda x: x % 7, numbers))"
                "filtered_remainders = list(filter(lambda x: x > 4, remainders))"
                "result_product = reduce(lambda x, y: x * y, filtered_remainders, 1)"
                "print('Остатки от деления на 7:', remainders)"
                "print('Отфильтрованные значения:', filtered_remainders)"
                "print('Произведение отфильтрованных значений:', result_product)",

            "43. Дан одномерный массив целых чисел размерности n, заданных"
            "случайным образом из интервала от 0 до 100. Если количество четных элементов,"
            "стоящих на нечетных местах, превышает количество нечетных элементов, стоящих"
            "на четных местах, то отсортировать массив по возрастанию, иначе по убыванию."
            "Реализовать алгоритм сортировки слиянием.":
                "import random"
                "def merge_sort(arr, ascending=True):"
                    "if len(arr) <= 1:"
                        "return arr"
                    "mid = len(arr) // 2"
                    "left_half = merge_sort(arr[:mid], ascending)"
                    "right_half = merge_sort(arr[mid:], ascending)"
                    "return merge(left_half, right_half, ascending)"
                "def merge(left, right, ascending=True):"
                    "sorted_array = []"
                    "while left and right:"
                        "if (left[0] < right[0] and ascending) or (left[0] > right[0] and not ascending):"
                            "sorted_array.append(left.pop(0))"
                        "else:"
                            "sorted_array.append(right.pop(0))"
                    "sorted_array.extend(left if left else right)"
                    "return sorted_array"
                "def count_even_odd_positions(arr):"
                    "even_on_odd = sum(1 for i in range(1, len(arr), 2) if arr[i] % 2 == 0)"
                    "odd_on_even = sum(1 for i in range(0, len(arr), 2) if arr[i] % 2 != 0)"
                    "return even_on_odd, odd_on_even"
                "n = 20"
                "arr = [random.randint(0, 100) for _ in range(n)]"
                "even_on_odd, odd_on_even = count_even_odd_positions(arr)"
                "sorted_arr = merge_sort(arr, ascending=even_on_odd > odd_on_even)"
                "print('Исходный массив:', arr)"
                "print('Количество четных элементов на нечетных местах:', even_on_odd)"
                "print('Количество нечетных элементов на четных местах:', odd_on_even)"
                "print('Отсортированный массив:', sorted_arr)",


            "44. Реализовать декоратор с именем not_sum, который генерирует"
            "исключительную ситуацию, если декорируемая функция вернула отрицательное"
            "значение суммы трех чисел.":
                "def not_sum(func):"
                    "def wrapper(a, b, c):"
                        "result = func(a, b, c)"
                        "if result < 0:"
                            "raise ValueError('Сумма трех чисел отрицательна')"
                        "return result"
                    "return wrapper"
                "@not_sum"
                "def sum_three_numbers(a, b, c):"
                    "return a + b + c"
                "try:"
                    "print(sum_three_numbers(1, 2, 3))"
                    "print(sum_three_numbers(5, 2, 1))"
                "except ValueError as e:"
                    "print(e)",

            "45. Дано два однонаправленных связных списка. Создать список,"
            "содержащий элементы общие для двух списков.":
                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class SinglyLinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                    "def append(self, data):"
                        "new_node = Node(data)"
                        "if not self.head:"
                            "self.head = new_node"
                        "else:"
                            "current = self.head"
                            "while current.next:"
                                "current = current.next"
                            "current.next = new_node"
                    "def to_set(self):"
                        "elements = set()"
                        "current = self.head"
                        "while current:"
                            "elements.add(current.data)"
                            "current = current.next"
                        "return elements"
                    "def to_list(self):"
                        "elements = []"
                        "current = self.head"
                        "while current:"
                            "elements.append(current.data)"
                            "current = current.next"
                        "return elements"
                "def find_common_elements(list1, list2):"
                    "set1 = list1.to_set()"
                    "set2 = list2.to_set()"
                    "common_elements_set = set1.intersection(set2)"
                    "common_list = SinglyLinkedList()"
                    "for element in common_elements_set:"
                        "common_list.append(element)"
                    "return common_list"
                "list1 = SinglyLinkedList()"
                "list2 = SinglyLinkedList()"
                "elements1 = [1, 2, 3, 4, 5]"
                "elements2 = [3, 4, 5, 6, 7]"
                "for elem in elements1:"
                    "list1.append(elem)"
                "for elem in elements2:"
                    "list2.append(elem)"
                "common_list = find_common_elements(list1, list2)"
                "print(common_list.to_list())",

            "46. Дан список целых чисел. При помощи механизма map/filter/reduce"
            "рассчитать остаток от деления на 17 для каждого из чисел списка и получить"
            "произведение тех остатков, величина которых меньше 7.":
                "from functools import reduce"
                "numbers = [34, 51, 68, 85, 102, 119, 136]"
                "remainders = list(map(lambda x: x % 17, numbers))"
                "filtered_remainders = list(filter(lambda x: x < 7, remainders))"
                "result_product = reduce(lambda x, y: x * y, filtered_remainders, 1)"
                "print(remainders)"
                "print(filtered_remainders)"
                "print(result_product)",



            "47. Создать класс Профиль местности, который хранит последовательность"
            "высот, вычисленных через равные промежутки по горизонтали. Методы:"
            "наибольшая высота, наименьшая высота, перепад высот (наибольший,"
            "суммарный), крутизна (тангенс угла наклона; наибольшая, средняя), сравнение"
            "двух профилей одинаковой длины (по перепаду, по крутизне).":
                "class TerrainProfile:"
                    "def __init__(self, heights):"
                        "self.heights = heights"
                    "def max_height(self):"
                        "return max(self.heights)"
                    "def min_height(self):"
                        "return min(self.heights)"
                    "def height_difference(self):"
                        "return self.max_height() - self.min_height()"
                    "def total_height_difference(self):"
                        "return sum(abs(self.heights[i] - self.heights[i - 1]) for i in range(1, len(self.heights)))"
                    "def max_slope(self):"
                        "return max(abs(self.heights[i] - self.heights[i - 1]) for i in range(1, len(self.heights)))"
                    "def average_slope(self):"
                        "return self.total_height_difference() / (len(self.heights) - 1)"
                    "def compare_by_difference(self, other):"
                        "return self.height_difference() - other.height_difference()"
                    "def compare_by_slope(self, other):"
                        "return self.average_slope() - other.average_slope()"
                    "def display_info(self):"
                        "print(f'Наибольшая высота: {self.max_height()}')"
                        "print(f'Наименьшая высота: {self.min_height()}')"
                        "print(f'Перепад высот (наибольший): {self.height_difference()}')"
                        "print(f'Перепад высот (суммарный): {self.total_height_difference()}')"
                        "print(f'Наибольшая крутизна: {self.max_slope()}')"
                        "print(f'Средняя крутизна: {self.average_slope()}')"
                "profile1 = TerrainProfile([100, 200, 150, 300, 250])"
                "profile2 = TerrainProfile([50, 100, 80, 150, 130])"
                "profile1.display_info()"
                "profile2.display_info()"
                "print('Сравнение по перепаду высот:', profile1.compare_by_difference(profile2))"
                "print('Сравнение по средней крутизне:', profile1.compare_by_slope(profile2))",


            "48. Дан список целых чисел. При помощи механизма map/filter/reduce"
            "рассчитать разность со значением 10 для каждого из чисел списка и получить"
            "сумму тех значений, величина которых меньше 0.":
                "from functools import reduce"
                "numbers = [15, 3, 20, 7, 11, 5, 25]"
                "difference = list(map(lambda x: x - 10, numbers))"
                "filtered_values = list(filter(lambda x: x < 0, difference))"
                "result_sum = reduce(lambda x, y: x + y, filtered_values, 0)"
                "print('Разности:', difference)"
                "print('Отфильтрованные значения:', filtered_values)"
                "print('Сумма отфильтрованных значений:', result_sum)",


            "49. Реализовать двоичное дерево в виде связанных объектов (реализовать"
            "класс для элементов двоичного дерева) и реализовать симметричную процедуру"
            "обхода двоичного дерева в виде рекурсивной функции.":
                "class TreeNode:"
                    "def __init__(self, value):"
                        "self.value = value"
                        "self.left = None"
                        "self.right = None"
                "class BinaryTree:"
                    "def __init__(self):"
                        "self.root = None"
                        "def insert(self, value):"
                        "if self.root is None:"
                            "self.root = TreeNode(value)"
                        "else:"
                            "self._insert(self.root, value)"
                    "def _insert(self, node, value):"
                        "if value < node.value:"
                            "if node.left is None:"
                                "node.left = TreeNode(value)"
                            "else:"
                                "self._insert(node.left, value)"
                        "else:"
                            "if node.right is None:"
                                "node.right = TreeNode(value)"
                            "else:"
                                "self._insert(node.right, value)"
                    "def inorder_traversal(self):"
                        "result = []"
                        "self._inorder_traversal(self.root, result)"
                        "return result"
                    "def _inorder_traversal(self, node, result):"
                        "if node:"
                            "self._inorder_traversal(node.left, result)"
                            "result.append(node.value)"
                            "self._inorder_traversal(node.right, result)"
                "tree = BinaryTree()"
                "values = [50, 30, 70, 20, 40, 60, 80]"
                "for value in values:"
                "tree.insert(value)"
                "inorder_result = tree.inorder_traversal()"
                "print('Симметричный обход дерева:', inorder_result)",

            "50. В одномерном массиве целых чисел найти количество пар элементов"
            "разного знака. (пара — это два рядом стоящих элемента)":

                "A = [12, -34, 7, -19, 23, -56, 78, -4, 9, -11, 25, -67, 89, -32, 45, -18, 21, -54, 6, -13]"
                "b = 0"
                "for i in range(len(A)-1):"
                    "if (A[i]<0 and A[i+1] > 0) or (A[i] > 0 and A[i+1] < 0):"
                "b+=1"
                "print(b)",


            "51. Задание: построить базовый класс с указанными в таблице полями иметодами:"
            "- конструктор; - функция, которая определяет «качество» объекта – Q по"
            "заданной формуле; - метод вывода информации об объекте."
            "Построить дочерний класс (класс-потомок), который содержит:- дополнительное поле P;"
            "- функция, которая определяет «качество» объекта дочернего класса – Qp и"
            "перегружает функцию качества родительского класса (Q), выполняя вычисление поновой формуле."
            "Создать проект для демонстрации работы: ввод и вывод информации обобъектах классов. (20 баллов)"
            "Поля и методы базового класса Компьютер: - наименование процессора; - тактовая частота процессора (МГц);"
            "- объем оперативной памяти (Мб); - Q = (0,1·частота) + память Поля и методы дочернего класса"
            "P: объем накопителя SSD (Гб)- Qp = Q +0,5P":
                "class Computer:"
                    "def __init__(self, processor_name, clock_speed, ram):"
                        "self.processor_name = processor_name"
                        "self.clock_speed = clock_speed"
                        "self.ram = ram"
                    "def quality(self):"
                        "return (0.1 * self.clock_speed) + self.ram"
                    "def display_info(self):"
                        "print(f'Наименование процессора: {self.processor_name}')"
                        "print(f'Тактовая частота процессора (МГц): {self.clock_speed}')"
                        "print(f'Объем оперативной памяти (Мб): {self.ram}')"
                        "print(f'Качество: {self.quality()}')"
                "class AdvancedComputer(Computer):"
                    "def __init__(self, processor_name, clock_speed, ram, ssd):"
                        "super().__init__(processor_name, clock_speed, ram)"
                        "self.ssd = ssd"
                    "def quality(self):"
                        "base_quality = super().quality()"
                        "return base_quality + (0.5 * self.ssd)"
                    "def display_info(self):"
                        "super().display_info()"
                        "print(f'Объем накопителя SSD (Гб): {self.ssd}')"
                        "print(f'Качество (с учетом SSD): {self.quality()}')"
                "comp = Computer('Intel Core i5', 3200, 8192)"
                "comp.display_info()"
                "adv_comp = AdvancedComputer('AMD Ryzen 7', 3600, 16384, 512)"
                "adv_comp.display_info()",



            "52. Создать иерархию классов для фруктов, продающихся в магазине."
            "Иерархия должна содержать не менее 3 классов. Объекты должны содержать не"
            "менее 2-х атрибутов и 2-х методов. Реализовать механизм автоматического"
            "подсчета количества всех созданных фруктов и автоматического присвоения"
            "каждому фрукту уникального идентификатора. Необходимо заполнить списокпредставителями"
            " всех классов (всего не менее 5 объектов) и продемонстрировать"
            "работу созданного механизма":

                "class Fruit:"
                "total_fruits = 0"
                "def __init__(self, name, color):"
                "self.name = name"
                "self.color = color"
                "Fruit.total_fruits += 1"
                "self.id = Fruit.total_fruits"
                "def display_info(self):"
                "print(f'ID: {self.id}, Name: {self.name}, Color: {self.color}')"
                "@classmethod"
                "def get_total_fruits(cls):"
                "return cls.total_fruits"
                "class Citrus(Fruit):"
                "def __init__(self, name, color, acidity):"
                "super().__init__(name, color)"
                "self.acidity = acidity"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Acidity: {self.acidity}')"
                "class Berry(Fruit):"
                "def __init__(self, name, color, sweetness):"
                "super().__init__(name, color)"
                "self.sweetness = sweetness"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Sweetness: {self.sweetness}')"
                "class Tropical(Fruit):"
                "def __init__(self, name, color, juiciness):"
                "super().__init__(name, color)"
                "self.juiciness = juiciness"
                "def display_info(self):"
                "super().display_info()"
                "print(f'Juiciness: {self.juiciness}')"
                "fruits = ["
                "Citrus('Orange', 'Orange', 'High'),"
                "Berry('Strawberry', 'Red', 'Medium'),"
                "Tropical('Mango', 'Yellow', 'High')"
                "]"
                "for fruit in fruits:"
                "fruit.display_info()"
                "print(f'Total number of fruits: {Fruit.get_total_fruits()}')",


            "53. Дано предложение без знаков препинания. Превратить предложение в"
            "список слов. При помощи механизма map/filter/reduce найти количество слов,"
            "длина которых больше 4 и склеить их в одну строку":

                "from functools import reduce"
                "def functure(sels):"
                "word = sels.split()"
                "t = list(filter(lambda words : len(words)>4, word))"
                "e = reduce(lambda x, y : x+y,t)"
                "return e"
                "sels = 'This is an example sentence without punctuation'"
                "re = functure(sels)"
                "print(re)",




            "54. В одномерном массиве (array) целых чисел найти количество пар, модуль"
            "разности элементов которых больше 10. (пара — это два рядом стоящих элемента).":

                "integer_array = [12, 34, 7, 19, 23, 56, 78, 4, 9, 11, 25, 67, 89, 32, 45, 18, 21, 54, 6, 13]"
                "def f(array):"
                    "k = 0"
                    "for i in range(len(array)-1):"
                        "if (((array[i] - array[i+1])**2))>100:"
                        "k+=1"
                    "return k"
                "re = f(integer_array)"
                "print(re)",

            "55. Реализовать функцию st_reverse(a_string), которая при помощи стека"
            "инвертирует строку (меняет порядок букв на обратный). Пример: st_reverse(‘abcd’)"
            "-> ‘dcba’.":

                "class Stack:"
                    "def __init__(self):"
                        "self.items = []"

                    "def push(self, item):"
                        "self.items.append(item)"
                    "def pop(self):"
                        "return self.items.pop()"
                "def rezult(n):"
                    "re = ''"
                    "for i in range(len(n)):"
                    "re += stec.pop()"
                    "return re"
                "stec = Stec()"
                "n = 'ksndojb'"
                "for i in n:"
                "stec.push(i)"
                "rez = rezult(n)"
                "print(rez)",

            "56. Дан двунаправленный связный список. Вставить элемент после n-гоэлемента списка.":
            "",
            "59. Соединить два однонаправленных связных списка.":

                "class Node:"
                    "def __init__(self, data):"
                        "self.data = data"
                        "self.next = None"
                "class LinkedList:"
                    "def __init__(self):"
                        "self.head = None"
                        "def append(self, data):"
                            "new_node = Node(data)"
                            "if not self.head:"
                                "self.head = new_node"
                            "else:"
                                "current = self.head"
                                "while current.next:"
                                    "current = current.next"
                                "current.next = new_node"
                        "def to_list(self):"
                            "result = []"
                            "current = self.head"
                            "while current:"
                                "result.append(current.data)"
                                "current = current.next"
                            "return result"
                        "def extend(self, other_list):"
                            "if not self.head:"
                                "self.head = other_list.head"
                            "else:"
                                "current = self.head"
                                "while current.next:"
                                    "current = current.next"
                                "current.next = other_list.head"
                "ll1 = LinkedList()"
                "ll2 = LinkedList()"
                "for i in range(1, 6):"
                    "ll1.append(i)"
                "for i in range(6, 11):"
                    "ll2.append(i)"
                "print('Первый список:', ll1.to_list())"
                "print(;Второй список:', ll2.to_list())"
                "ll1.extend(ll2)"
                "print('Объединенный список:', ll1.to_list())",


            "Найти НОД двух чисел": "def gcd(a, b): while b: a, b = b, a % b; return a"

        }

    def find(self, keyword):
        # Ищем задачи по ключевому слову
        results = {}
        for task_text, solution in self.tasks.items():
            if keyword.lower() in task_text.lower():
                results[task_text] = solution
        return results

