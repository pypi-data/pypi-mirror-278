import json
import os
from typing import List, Optional
from urllib.parse import urlparse

import click
from outpostkit import Client, Endpoint, Endpoints
from outpostkit._types.endpoint import (
    EndpointAutogeneratedHFModelDetails,
    EndpointAutogeneratedOutpostModelDetails,
    EndpointAutogeneratedTemplateConfig,
    EndpointCustomTemplateConfig,
    EndpointPrebuiltContainerDetails,
    ReplicaScalingConfig,
)
from outpostkit._utils.constants import OutpostSecret, ServiceVisibility
from outpostkit.endpoints import scaffold
from outpostkit.exceptions import OutpostError
from outpostkit.utils import convert_outpost_date_str_to_date
from rich.table import Table

from .exceptions import SourceNotSupportedError
from .utils import (
    add_options,
    api_token_opt,
    click_group,
    condense_endpt_autogen_configs,
    console,
    entity_opt,
    get_log_level_style_info,
    output_style_opt,
)


@click_group()
def endpoints():
    """
    Manage Endpoints
    """
    pass


@endpoints.command(name="list")
@add_options([api_token_opt, entity_opt])
def list_endpoints(api_token, entity):
    client = Client(api_token=api_token)
    infs_resp = Endpoints(client=client, entity=entity).list()
    inf_table = Table(
        title=f"Endpoints ({infs_resp.total})",
    )
    # "primary_endpoint",
    inf_table.add_column("name")
    inf_table.add_column("model")
    inf_table.add_column("status")
    inf_table.add_column("hardware_instance")
    inf_table.add_column("visibility")
    inf_table.add_column("updated_at", justify="right")
    for inf in infs_resp.endpoints:
        inf_table.add_row(
            inf.name,
            (
                condense_endpt_autogen_configs(inf.autogeneratedTemplateConfig)
                if inf.autogeneratedTemplateConfig is not None
                else "custom"
            ),
            inf.status,
            inf.hardwareInstance.name,
            inf.visibility,
            convert_outpost_date_str_to_date(inf.updatedAt).isoformat(),
        )

    console.print(inf_table)


@endpoints.command(name="scaffold")
@click.option(
    "--path",
    "-p",
    type=str,
    default=None,
    required=False,
    help="path to the file to create.",
)
def scaffold_endpoint(path: Optional[str]):
    if path is None:
        path = "template.py"
    scaffold(path)


@endpoints.command(name="create")
@click.argument("model-data", type=str, nargs=1, required=False)
@click.option(
    "--name",
    "-n",
    type=str,
    default=None,
    required=False,
    help="name of the endpoint to create.",
)
@click.option(
    "--huggingface-token-id",
    type=str,
    default=None,
    required=False,
    help="huggingface token id to connect private models.",
)
@click.option(
    "--hardware-instance",
    "-h",
    type=str,
    required=True,
    help="hardware instance type to use",
)
@click.option(
    "--template-path",
    "-p",
    type=str,
    help="template path",
    required=False,
)
@click.option(
    "--task-type",
    "-t",
    type=str,
    default="custom",
    help="task type",
    required=False,
)
@click.option(
    "--prebuilt-container",
    type=click.Choice(
        [
            "transformers",
            "python",
            "tensorflow",
            "diffusers",
        ]
    ),
    # type=str,
    help="base image",
    required=False,
)
@click.option(
    "--prebuilt-container-config",
    type=str,
    help="prebuilt container config (JSON)",
    required=False,
)
@click.option(
    "--visibility",
    type=click.Choice(["private", "public", "internal"]),
    # type=str,
    default="private",
    help="visibility of the endpoint",
    required=False,
)
@click.option(
    "--replica-scaling-min",
    type=int,
    default=0,
    help="minimum number of replicas",
    required=False,
)
@click.option(
    "--secret",
    "--env",
    "-e",
    type=str,
    multiple=True,
    default=None,
    help="minimum number of replicas",
    required=False,
)
@click.option(
    "--replica-scaling-max",
    type=int,
    default=1,
    help="maximum number of replicas",
    required=False,
)
@click.option(
    "--replica-scaling-scaledown-period",
    type=int,
    default=900,
    help="number of seconds to wait before scaling down.",
    required=False,
)
@click.option(
    "--replica-scaling-target-pending-req",
    type=int,
    default=20,
    help="threshold of number of requests in pending before scaling up.",
    required=False,
)
@add_options([api_token_opt, entity_opt])
def create_endpoint(
    api_token: str,
    entity: str,
    model_data: Optional[str],
    hardware_instance: str,
    huggingface_token_id,
    name: Optional[str],
    template_path: Optional[str],
    task_type: str,
    replica_scaling_min: int,
    replica_scaling_max: int,
    visibility: str,
    replica_scaling_scaledown_period: int,
    replica_scaling_target_pending_req: int,
    prebuilt_container: Optional[str],
    prebuilt_container_config: Optional[str],
    secret: Optional[List[str]],
):
    client = Client(api_token=api_token)
    try:
        visibility = ServiceVisibility[visibility]
    except KeyError as e:
        raise OutpostError(
            "Invalid visibility choice. choices are, `private`, `public` and `internal`.",
        ) from e
    if template_path:
        [actual_path, class_name] = template_path.rsplit(":", 1)
        if not actual_path or not class_name:
            click.echo(
                "Please specify the template classname along with the path.", err=True
            )
            return
        if not prebuilt_container:
            click.echo("Please specify the base image you want to use.", err=True)
            return
        try:
            result = urlparse(actual_path)
            if all([result.scheme, result.netloc]):
                custom_template_config = EndpointCustomTemplateConfig(type="url",path=actual_path, className=class_name)
                if prebuilt_container_config is not None:
                    try:
                        config = json.loads(prebuilt_container_config)
                    except json.JSONDecodeError as e:
                        raise OutpostError(
                            f"Invalid JSON: prebuilt_container_config: {str(e)}"
                        ) from e
                prebuilt_container_details = EndpointPrebuiltContainerDetails(name=prebuilt_container, config=config)
                replica_scaling_config=  ReplicaScalingConfig(
                        min= replica_scaling_min,
                        max= replica_scaling_max,
                        scaledownPeriod= replica_scaling_scaledown_period,
                        targetPendingRequests= replica_scaling_target_pending_req,
                )
                secrets = None
                if(secret is not None):
                    secrets = []
                    for s in secret:
                        name,value = s.split('=',maxsplit=1)
                        if name == "":
                            raise OutpostError("Invalid secret config: name empty.")
                        secrets.append(OutpostSecret(name=name, value=value))
                create_resp = Endpoints(client=client, entity=entity).create(
                    template=custom_template_config,
                    container=prebuilt_container_details,
                    hardware_instance=hardware_instance,
                    task_type=task_type,
                    name=name,
                    visibility=visibility,
                    replica_scaling_config=replica_scaling_config,
                    secrets=secrets,
                )
            else:
                raise ValueError("Not an url.")
        except ValueError:
            if os.path.exists(actual_path) and os.path.isfile(actual_path):
                custom_template_config = EndpointCustomTemplateConfig(type="file",path=actual_path, className=class_name)
                config = None
                if prebuilt_container_config is not None:
                    try:
                        config = json.loads(prebuilt_container_config)
                    except json.JSONDecodeError as e:
                        raise OutpostError(
                            f"Invalid JSON: prebuilt_container_config: {str(e)}"
                        ) from e
                prebuilt_container_details = EndpointPrebuiltContainerDetails(name=prebuilt_container, config=config)
                replica_scaling_config=  ReplicaScalingConfig(
                        min= replica_scaling_min,
                        max= replica_scaling_max,
                        scaledownPeriod= replica_scaling_scaledown_period,
                        targetPendingRequests= replica_scaling_target_pending_req,
                )
                secrets = None
                if(secret is not None):
                    secrets = []
                    for s in secret:
                        name,value = s.split('=',maxsplit=1)
                        if name == "":
                            raise OutpostError(
                                "Invalid secret config: name empty"
                            ) from None
                        secrets.append(OutpostSecret(name=name, value=value))

                create_resp = Endpoints(client=client, entity=entity).create(
                    template=custom_template_config,
                    container=prebuilt_container_details,
                    hardware_instance=hardware_instance,
                    task_type=task_type,
                    name=name,
                    visibility=visibility,
                    replica_scaling_config=replica_scaling_config,
                    secrets=secrets,
                )
            else:
                click.echo("Invalid template file path.", err=True)
                return
        except Exception as e:
            click.echo(f"could not parse the template, error: {e}", err=True)
            return
    else:
        # do the other thing
        if not model_data:
            click.echo("Please provided the model name.", err=True)
            return
        m_splits = model_data.split(":", 1)
        template_config = None
        if len(m_splits) == 1:
            [model_name, revision] = model_data.split("@", 1)
            template_config = EndpointAutogeneratedTemplateConfig(modelSource= "outpost",
                outpostModel= EndpointAutogeneratedOutpostModelDetails(fullName= model_name),
                revision=revision
            )
        else:
            if m_splits[0] == "hf" or m_splits[0] == "huggingface":
                [model_name, revision] = model_data.split("@", 1)
                template_config = EndpointAutogeneratedTemplateConfig(modelSource= 'huggingface',
                outpostModel= EndpointAutogeneratedHFModelDetails(id= model_name,keyId=huggingface_token_id),
                revision=revision
            )
            else:
                raise SourceNotSupportedError(f"source {m_splits[0]} not supported.")
        prebuilt_container_details = EndpointPrebuiltContainerDetails(name=prebuilt_container, config=config) if prebuilt_container else None
        replica_scaling_config=  ReplicaScalingConfig(
                min= replica_scaling_min,
                max= replica_scaling_max,
                scaledownPeriod= replica_scaling_scaledown_period,
                targetPendingRequests= replica_scaling_target_pending_req,
        )
        secrets = None
        if(secret is not None):
            secrets = []
            for s in secret:
                name,value = s.split('=',maxsplit=1)
                if name == "":
                    raise OutpostError("Invalid secret config: name empty.") from None
                secrets.append(OutpostSecret(name=name, value=value))

        create_resp = Endpoints(client=client, entity=entity).create(
            template=template_config,
            container=prebuilt_container_details,
            hardware_instance=hardware_instance,
            task_type=task_type,
            name=name,
            visibility=visibility,
            replica_scaling_config=replica_scaling_config,
            secrets=secrets,
        )
    click.echo(f"Endpoint created.\nname: {create_resp.name}")


@endpoints.command("get")
@add_options([api_token_opt, entity_opt])
@click.argument("name", type=str, nargs=1)
def get_endpoint(api_token, entity, name):
    client = Client(api_token=api_token)
    inf_data = Endpoint(
        client=client,
        name=name,
        entity=entity,
    ).get()
    click.echo(inf_data.__dict__)


@endpoints.command(name="deploy")
@click.argument("name", type=str, nargs=1)
@add_options([api_token_opt, entity_opt])
def deploy_endpoint(api_token, entity, name):
    client = Client(api_token=api_token)
    deploy_data = Endpoint(client=client, name=name, entity=entity).deploy()
    click.echo(f"Deployment successful. id: {deploy_data.id}")


@endpoints.command(name="deployments")
@add_options([api_token_opt, entity_opt])
@click.argument("name", type=str, nargs=1)
def list_endpoint_deployments(api_token, entity, name):
    client = Client(api_token=api_token)
    deployments_resp = Endpoint(
        client=client, name=name, entity=entity
    ).list_deploymets(params={})

    inf_table = Table(
        title=f"Deployments ({deployments_resp.total})",
    )
    # "primary_endpoint",
    inf_table.add_column("id")
    inf_table.add_column("status")
    inf_table.add_column("created_at", justify="right")
    inf_table.add_column("concluded_at", justify="right")
    for inf in deployments_resp.deployments:
        inf_table.add_row(
            inf.id,
            inf.status,
            convert_outpost_date_str_to_date(inf.createdAt).isoformat(),
            (
                convert_outpost_date_str_to_date(inf.concludedAt).isoformat()
                if inf.concludedAt
                else "Not concluded yet."
            ),
        )

    console.print(inf_table)


@endpoints.command(name="delete")
@click.argument("name", type=str, nargs=1)
@add_options([api_token_opt, entity_opt])
def delete_endpoint(api_token, entity, name):
    fullName = f"{entity}/{name}"
    if click.confirm(
        f"do you really want to delete this endpoint: {fullName} ?", abort=True
    ):
        client = Client(api_token=api_token)
        delete_resp = Endpoint(client=client, name=name, entity=entity).delete()
        return "endpoint deleted."

    return "Aborted"


@endpoints.command(name="replica-status")
@click.argument("name", type=str, nargs=1)
@add_options([api_token_opt, entity_opt])
def inf_dep_status(api_token, entity, name):
    client = Client(api_token=api_token)
    status_data = Endpoint(
        client=client, api_token=api_token, name=name, entity=entity
    ).replica_status()
    click.echo(status_data)

@endpoints.command(name="status")
@click.argument("name", type=str, nargs=1)
@add_options([api_token_opt, entity_opt])
def inf_status(api_token, entity, name):
    client = Client(api_token=api_token)
    status_data = Endpoint(
        client=client, api_token=api_token, name=name, entity=entity
    ).status()
    click.echo(status_data)


@endpoints.command(name="logs")
@click.argument("name", type=str, nargs=1)
@click.option(
    "--deployment-id",
    "--deployment_id",
    "--dep_id",
    "--dep-id",
    type=str,
    default=None,
    help="filter by deployment ID",
    required=False,
)
@click.option(
    "--log-type",
    "--log_type",
    type=click.Choice(["event", "dep", "runtime"]),
    default=None,
    help="filter by log type.",
    required=False,
)
@click.option(
    "--start",
    type=str,
    default=None,
    help="log start timestamp.",
    required=False,
)
@click.option(
    "--end",
    type=str,
    default=None,
    help="log end timestamp.",
    required=False,
)
@click.option(
    "--limit",
    type=int,
    default=None,
    help="max number of logs.",
    required=False,
)
@click.option(
    "--hide-timestamp",
    "--hide_timestamp",
    is_flag=True,
    help="hide timestamp from text log.",
    required=False,
)
@add_options([api_token_opt, entity_opt, output_style_opt])
def logs(
    api_token: str,
    entity: str,
    name: str,
    log_type: str,
    deployment_id: str,
    start: str,
    end: str,
    limit: int,
    output_style: str,
    hide_timestamp: bool,  # noqa: FBT001
):
    client = Client(api_token=api_token)
    logs_data = Endpoint(client=client, name=name, entity=entity).get_logs(
        log_type=log_type,
        deployment_id=deployment_id,
        start=start,
        end=end,
        limit=limit,
    )
    logs = sorted(logs_data, key=lambda x: int(x.timestamp))

    if output_style == "JSON":
        for log in logs:
            click.echo(
                json.dumps({"timestamp": log.timestamp, "data": log.data.__dict__})
            )
    elif output_style == "PLAIN":
        for log in logs:
            click.echo(
                f'{"" if hide_timestamp else log.timestamp+ " "}[{log.data.level}]{" "+ log.data.replica if log.data.replica else ""} {log.data.message}{" " +log.exc_info if log.data.exc_info else ""}{" "+log.stack_info if log.data.stack_info else ""}'
            )
    else:
        for log in logs:
            style_info = get_log_level_style_info(log.data.level)
            click.echo(
                (
                    ""
                    if hide_timestamp
                    else click.style(log.timestamp, fg=(128, 128, 128)) + " "
                )
                + click.style(
                    f'[{log.data.level}]{" "+ log.data.replica if log.data.replica else ""} {log.data.message}{" " +log.exc_info if log.data.exc_info else ""}{" "+log.stack_info if log.data.stack_info else ""}',
                    **style_info,
                ),
            )
