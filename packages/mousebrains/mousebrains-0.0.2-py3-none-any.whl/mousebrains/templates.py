#    This script is part of mousebrains (http://www.github.com/schlegelp/navis-mousebrains).
#    Copyright (C) 2020 Philipp Schlegel
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

"""Module constructing templatebrains"""

import json
import navis
import os

import trimesh as tm

from textwrap import dedent

from navis import transforms
from navis.transforms.templates import TemplateBrain


__all__ = ['AllenCCF', 'register_templates']

# Read in meta data
fp = os.path.dirname(__file__)

meta_filepath = os.path.join(fp, 'data/template_meta.json')
mesh_filepath = os.path.join(fp, 'meshes')

with open(meta_filepath, 'r', encoding='utf-8') as f:
    template_meta = json.load(f)

# Index by short label
template_meta = {e['label']: e for e in template_meta}


class MouseTemplateBrain(TemplateBrain):
    """Base Class for mouse template brains.

    This is mostly syntactic sugar to:
        1. Produce a nicely formatted string representation
        2. On-demand mesh-loading from ./data

    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        units = getattr(self, 'units', 'units NA')

        if isinstance(units, list):
            units = units[0]

        if getattr(self, 'boundingbox'):
            bbox = f"""\
            Bounding box ({units}):
              x = {self.boundingbox[0]}, y = {self.boundingbox[2]}, z = {self.boundingbox[4]},
              x = {self.boundingbox[1]}, y = {self.boundingbox[3]}, z = {self.boundingbox[5]},"""
        else:
            bbox = f"""\
            Bounding box ({units}):
              NA"""

        if getattr(self, 'dims'):
            dims = f"{self.dims[0]} x {self.dims[1]} x {self.dims[2]} voxels"
        else:
            dims = "NA"

        if getattr(self, 'voxdims'):
            units = getattr(self, 'units', None)

            if not units:
                units = ['dimensionless', 'dimensionless', 'dimensionless']
            elif not navis.utils.is_iterable(units):
                units = [units, units, units]

            vxsize = f"""\
            Voxel size:
              x = {self.voxdims[0]} {units[0]}
              y = {self.voxdims[1]} {units[1]}
              z = {self.voxdims[2]} {units[2]}"""
        else:
            vxsize = """\
            Voxel size:
              NA"""

        # Can't use f-strings here because we need to dedent before we can
        # fill in the values
        msg = """\
        Template brain
        --------------
        Name: {name}
        Short Name: {label}
        Type: {type}
        Sex:  {sex}
        Dimensions: {dims}
        {vxsize}
        {bbox}
        Description: {description}
        DOI: {doi}"""

        msg = dedent(msg).format(name=getattr(self, 'name', 'NA'),
                                 label=getattr(self, 'label', 'NA'),
                                 type=getattr(self, 'type', 'NA'),
                                 sex=getattr(self, 'sex', 'NA'),
                                 dims=dims,
                                 vxsize=dedent(vxsize),
                                 bbox=dedent(bbox),
                                 description=getattr(self, 'description', 'NA'),
                                 doi=getattr(self, 'doi', 'NA'))
        return msg

    @property
    def mesh(self):
        """On-demand loading of surface mesh."""
        if not hasattr(self, '_mesh'):
            fp = os.path.join(mesh_filepath, f'{self.label}.ply')

            if not os.path.isfile(fp):
                raise ValueError(f'{self.label} does not appear to have a mesh')

            self._mesh = tm.load_mesh(fp)

        return self._mesh


class _AllenCCF(MouseTemplateBrain):
    """Allen Mouse Brain Common Coordinate Framework.

    The Allen CCF is an average template brain at 10 μm voxel resolution
    by interpolating high resolution in-plane serial two-photon tomography
    images with 100 μm z-sampling from 1,675 young adult C57BL/6J mice.

    The surafce mesh was generated by running marching cubes on the
    20um resolution image stack.

    References
    ----------
    Quanxin Wang, Song-Lin Ding, Yang Li, Josh Royall, David Feng, Phil Lesnar,
    Nile Graddis, Maitham Naeemi, Benjamin Facer, Anh Ho, Tim Dolbeare,
    Brandon Blanchard, Nick Dee, Wayne Wakeman, Karla E. Hirokawa, Aaron Szafer,
    Susan M. Sunkin, Seung Wook Oh, Amy Bernard, John W. Phillips, Michael Hawrylycz,
    Christof Koch, Hongkui Zeng, Julie A. Harris, Lydia Ng (2020).
    The Allen Mouse Brain Common Coordinate Framework: A 3D Reference Atlas.
    Cell, doi:/10.1016/j.cell.2020.04.007

    The atlas is accessible at https://atlas.brain-map.org/.

    """

AllenCCF = _AllenCCF(**template_meta['AllenCCF'])


def register_templates():
    """Register template brains with navis."""
    templates = (AllenCCF,)

    for tmp in templates:
        transforms.registry.register_templatebrain(tmp, skip_existing=True)
