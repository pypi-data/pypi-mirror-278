Index: src/camera_management/tools/system_analyzer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nunit for analyzing the system for windows and Linux\n-> not platform independent!\n\"\"\"\nimport platform\nfrom dataclasses import dataclass\n\nimport cv2 as cv\n\nfrom camera_management.tools.types import VideoDevice\n\ntry:\n    import vmbpy\n\n    vmbpy_import = True\nexcept ImportError:\n    vmbpy_import = False\n    print(\"system_analyzer: (Ignore if you do not want to use AVT Cameras) Could not import vmbpy. See the readme for more information.\")\n\nfrom pypylon import pylon\n\n# from image_measurement.tools.logger import get# _logger\n\n# # _logger = get_logger(\"tools.sysAnalyzer\")\n\nif platform.system() == \"Windows\":\n    from pygrabber.dshow_graph import FilterGraph\nelif platform.system() == \"Linux\":\n    import pyudev\nelif platform.system() == \"Darwin\":\n    # ------------------------------------------- ffmpeg / AVFoundation\n    import plistlib\n\n    # ----------------------------------------------------------------- system_profiler\n    import re\n\n    import AVFoundation\n\n    # ---------------------------------------------------------------- libusb\n    import libusb_package\n\n    # ----------------------------------------------------------------- pyusb\n    import usb\n    import usb.backend.libusb1\n    import usb.core\n    import usb.util\n\nelse:\n    raise NotImplementedError(f\"Only Windows and Linux are supported currently. Active platform is {platform.system()}\")\n\n\ndef check_sys_config(verbose=False):\n    \"\"\"\n    function to detect for system and os the current version and features\n    :param verbose:\n    :return:\n    \"\"\"\n    os = platform.system()\n    pc_name = platform.node()\n    os_version = platform.version()\n    cpu = platform.processor()\n    machine_type = platform.machine()\n    python_version = platform.python_version()\n    # --------------------------------------------------------------------------------------------------------\n    ocv_version = cv.version.opencv_version\n    gpu_count = cv.cuda.getCudaEnabledDeviceCount()\n    if gpu_count != 0:\n        print(cv.cuda_DeviceInfo.deviceID(0))  # all GPU's or NVIDIA only?\n    cpu_count = cv.getNumberOfCPUs()\n    thread_count = cv.getNumThreads()\n    cuda_devices = cv.cuda.getCudaEnabledDeviceCount()\n    # cv.cuda_DeviceInfo.majorVersion(cv.cuda_DeviceInfo.deviceID()) )#, cv.cuda_DeviceInfo.deviceID() )\n    # ---------------------------------------------------------------------------------------------------------\n    availableBackends = [cv.videoio_registry.getBackendName(b) for b in cv.videoio_registry.getBackends()]\n\n    # -------------------------------------------------- create iterable output-dictionary\n    sys_config = {\n        \"hostname\": pc_name,\n        \"system\": {\"os\": os, \"os version\": os_version},\n        \"cpu\": cpu,\n        \"machine type\": machine_type,\n        \"CPU count\": cpu_count,\n        \"thread count\": thread_count,\n        \"cuda devices\": cuda_devices,\n        \"python version\": python_version,\n        \"opencv version\": ocv_version,\n        \"video-camera_backends\": availableBackends,\n    }\n    if verbose:\n        print(\"\\n---------------------------------------------------------------------------------------------------------- get system configuration\")\n        print(\n            f\"current system configuration:\\n\"\n            f\"       Hostname:       {pc_name}\\n\"\n            f\"       System:         {os} - {os_version}\\n\"\n            f\"       CPU info:       {cpu} - type: {machine_type}\\n\"\n            f\"       CPU count:      {cpu_count} - threads: {thread_count}\\n\"\n            f\"       cuda devices:   {cuda_devices}\\n\"\n            f\"       Python version: {python_version}\\n\"\n            f\"       OpenCV version: {ocv_version}\\n\"\n            f\"       video-camera_backends: {availableBackends}\\n\\n\"\n        )\n\n    return sys_config\n\n\n# ----------------------------------------------------------------------------------------------------------------------------------------------------\ndef get_connected_cams(verbose: bool = False) -> list[VideoDevice]:\n    \"\"\"\n    returns for all supported platforms a uniform list of connected cameras\n    return: list of Videodevice\n    \"\"\"\n    current_system = platform.system()\n    if current_system == \"Windows\":\n        device_list = __get_cam_names_windows(verbose=False)\n    elif current_system == \"Linux\":\n        device_list = __get_cam_names_linux(verbose=False)\n    elif current_system == \"Darwin\":\n        device_list = __get_cam_names_mac(verbose=False)\n    else:\n        raise NotImplementedError(f\"Only Windows, Darwin and Linux are supported currently. Active platform is {current_system}\")\n\n    if vmbpy_import:\n        avt_devices = __get_cam_names_vimba()\n        device_list.extend(avt_devices)\n    basler_devices = __get_cam_names_basler(verbose=False)\n    device_list.extend(basler_devices)\n\n    if (verbose) and device_list is not None:\n        print(\"\\n---------------------------------------------------------------------------------------------------------- get system configuration\")\n        print(\"current system: \\t\", current_system)\n        for idx, device in enumerate(device_list):\n            print(f\"\\t{idx} - {device.product} - {device.serial} @ {device.path}\")\n\n    return device_list\n\n\ndef __get_cam_names_windows(verbose: bool = False) -> list[VideoDevice]:\n    \"\"\"\n    for Windows (based on DirectShow!):\n    ->  https://github.com/bunkahle/pygrabber\n    -> returns all video devices of the DShow filter graph\n    \"\"\"\n    graph = FilterGraph()\n\n    # ------------------------------------------------------------- force a list of strings\n    device_list: list[VideoDevice] = []\n    for i, device in enumerate(graph.get_input_devices()):\n        dev = VideoDevice(\n            path=i,\n            serial=str(device),\n            vendor_id=None,\n            product_id=None,\n            vendor=\"\",\n            product=str(device),\n            backend=cv.CAP_DSHOW,\n        )\n        device_list.append(dev)\n\n    if verbose:\n        print(\"With pygrabber and DSHOW detected camera streams:\")\n        for idx, device in enumerate(device_list):\n            print(f\"\\t{idx} - {device.serial} @ {device.path}\")\n\n    return device_list\n\n\ndef __get_cam_names_linux(verbose: bool = False) -> list[VideoDevice]:\n    \"\"\"\n    for Linux (pure Python binding for libudev)\n    -> https://pypi.org/project/pyudev/\n    \"\"\"\n    streams: list[VideoDevice] = list()\n    context = pyudev.Context()\n    for device in context.list_devices(subsystem=\"video4linux\"):\n        dpath = device.get(\"DEVNAME\", \"unknown device.path\")\n        vendor = device.get(\"ID_VENDOR\", \"vendor not found\")\n        vid = device.get(\"ID_VENDOR_ID\", \"vendorId not found\")\n        product = device.get(\"ID_MODEL\", \"product not found\")\n        pid = device.get(\"ID_MODEL_ID\", \"productId not found\")\n        serial = device.get(\"ID_SERIAL\", \"serial not found\")\n        caps = device.get(\"ID_V4L_CAPABILITIES\", \"capabilities not found\")\n\n        # _logger.debug(f\"Capabilities: {caps}\")\n        if \"capture\" in caps:\n            dev = VideoDevice(dpath, vid, pid, vendor, product, serial, backend=cv.CAP_V4L2)\n            streams.append(dev)\n            # _logger.debug(dev)\n\n    if len(streams) < 1:\n        raise RuntimeError(\"Could not find valid devices.\")\n\n    if verbose:\n        print(\"With udev detected capturing camera streams:\")\n        for idx, device in enumerate(streams):\n            print(f\"\\t{idx} - {device.serial} @ {device.path}\")\n\n    return streams\n\n\ndef __get_cam_names_mac(verbose: bool = False) -> list[VideoDevice]:\n    \"\"\"\n    Python:   -> https://pypi.org/project/pyobjc-framework-AVFoundation/\n    Framework -> https://developer.apple.com/documentation/avfoundation/avcapturedevice\n    ffmpeg -> https://trac.ffmpeg.org/wiki/Capture/Webcam\n    -> terminal command:  ffmpeg -f avfoundation -list_devices true -i \"\"\n    -> gets a correct list of video devices, python list is equal to the terminal output\n    -> the ORDER OF THE stream list is not equal to the opencv stream list (even with the same backend)!\n\n    \"\"\"\n\n    streams: list[VideoDevice] = list()\n    backend = cv.CAP_AVFOUNDATION  # backend is for mac: AV-Foundation for opencv\n    transp_type: list = []\n\n    # -> https://developer.apple.com/documentation/avfoundation/avcapturedevice\n    # the session is the data sink for the AVCaptureDevice\n    # session = AVFoundation.AVCaptureSession.alloc().init()\n    # session.discoverySessionWithDeviceTypes(AVFoundation.AVMediaTypeVideo)\n\n    # -------------------------------------------------------------------------------------------------------- get a device list\n    AVF_devices = AVFoundation.AVCaptureDevice.devicesWithMediaType_(AVFoundation.AVMediaTypeVideo)  # only video      - Deprecated function\n    # dev = AVFoundation.AVCaptureDevice.devices()                                                           # video and audio - Deprecated function\n\n    # AVF_devices = AVFoundation.AVCaptureDevice.DiscoverySession()\n\n    # AVF_device = None\n    for idx, AVF_device in enumerate(AVF_devices):\n        AVF_device.init()  # is possible but without any result\n        product = AVF_device.localizedName()\n        vendor = AVF_device.manufacturer()\n        serial = AVF_device.uniqueID()\n\n        model_ID = AVF_device.modelID()\n        match = re.search(r\"VendorID_(\\d+) ProductID_(\\d+)\", model_ID)\n\n        if match:\n            vid = match.group(1)\n            pid = match.group(2)\n\n            vid = hex(int(vid))\n            pid = hex(int(pid))\n        else:\n            vid = None\n            pid = None\n\n        transp_type = AVF_device.transportType().to_bytes(4, \"big\").decode()\n        device_type = AVF_device.deviceType()\n        is_used = AVF_device.isInUseByAnotherApplication()\n        # -> https://github.com/phracker/MacOSX-SDKs/blob/master/MacOSX10.5.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/audio/IOAudioTypes.h\n        # -> https://developer.apple.com/documentation/avfoundation/avcapturedevice/1390520-deviceswithmediatype\n\n        dev = VideoDevice(None, vid, pid, vendor, product, None, backend, transp_type, serial, device_type, is_used)\n        streams.append(dev)\n\n    # magic line, comes from:\n    #    -> https://github.com/opencv/opencv/blob/224dac9427cfa1b3f1ba8787f681a3fe7f253e87/modules/videoio/src/cap_avfoundation_mac.mm#L392\n    streams.sort(key=lambda x: x.unique_id)\n    for idx, device in enumerate(streams):\n        device.path = idx\n\n    if verbose:\n        print(\"\\nWith mac_AVFoundation identified capturing camera streams:\")\n        for idx, device in enumerate(streams):\n            print(device)\n\n    return streams\n\n\ndef __get_cam_names_basler(verbose=False) -> list[VideoDevice]:\n    \"\"\"\n    get all the connected basler cameras. Can't be found with __get_cam_names_mac_AVFoundation() since it uses a different backend\n    TODO: Only the first connected cam can be found, if there are more cams connected this will have to be fixed\n    \"\"\"\n\n    tlf = pylon.TlFactory.GetInstance()\n    devices = tlf.EnumerateDevices()\n    ret_devices = []\n    for idx, d in enumerate(devices):\n        if verbose:\n            print(d.GetModelName(), d.GetSerialNumber(), dir(d))\n            print(d.GetAddress(), d.GetDeviceClass(), d.GetDeviceID(), d.GetFullName())\n        ret_devices.append(VideoDevice(f\"BAS_{idx}\", None, None, \"Basler\", d.GetModelName(), d.GetSerialNumber(), None))\n    return ret_devices\n\n\ndef __get_cam_names_vimba(verbose=False) -> list[VideoDevice]:\n    ret_devices = []\n    with vmbpy.VmbSystem.get_instance() as vmb:\n        devices = vmb.get_all_cameras()\n\n    for idx, d in enumerate(devices):\n        if verbose:\n            d.set_access_mode(vmbpy.AccessMode.Full)\n            print(d.get_name(), d.get_model(), d.get_access_mode(), d.get_permitted_access_modes(), d.is_streaming())\n            print(d.get_id(), d.get_serial(), d.get_interface_id())\n        ret_devices.append(VideoDevice(d.get_id(), None, None, \"Allied Vision\", d.get_name(), d.get_serial(), d.get_interface_id()))\n    return ret_devices\n\n\n# ====================================================================================================================================================\nif __name__ == \"__main__\":\n    get_connected_cams(verbose=True)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/camera_management/tools/system_analyzer.py b/src/camera_management/tools/system_analyzer.py
--- a/src/camera_management/tools/system_analyzer.py	
+++ b/src/camera_management/tools/system_analyzer.py	
@@ -3,7 +3,6 @@
 -> not platform independent!
 """
 import platform
-from dataclasses import dataclass
 
 import cv2 as cv
 
@@ -28,22 +27,10 @@
 elif platform.system() == "Linux":
     import pyudev
 elif platform.system() == "Darwin":
-    # ------------------------------------------- ffmpeg / AVFoundation
-    import plistlib
-
     # ----------------------------------------------------------------- system_profiler
     import re
-
     import AVFoundation
 
-    # ---------------------------------------------------------------- libusb
-    import libusb_package
-
-    # ----------------------------------------------------------------- pyusb
-    import usb
-    import usb.backend.libusb1
-    import usb.core
-    import usb.util
 
 else:
     raise NotImplementedError(f"Only Windows and Linux are supported currently. Active platform is {platform.system()}")
Index: src/camera_management/camera_management_app/manager_interface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import atexit\nimport json\nimport pathlib\nimport subprocess\nimport threading\nimport time\n\nimport requests\nimport tabulate\nfrom flask import Flask, jsonify, render_template, request\nfrom waitress import serve\n\nfrom camera_management.tools.camera_dataclasses import CameraList\nfrom camera_management.tools.create_config import get_configs\nfrom camera_management.tools.network_tools import check_config\nfrom camera_management.tools.system_analyzer import get_connected_cams\nfrom camera_management.tools.types import ImageResolution, VideoDevice\n\n\nclass ManagerApp(threading.Thread):\n    \"\"\"\n    This is the main backend class.\n\n    It tries to connect to all physically connected camera devices and creates sockets for each device.\n    This class runs on port 8090. Each socket for each camera runs on the nextmost port (8091+).\n    \"\"\"\n\n    def __init__(self, path_to_configs: pathlib.Path, autostart: bool = True, chose_cameras=False):\n        \"\"\"\n        This is the main backend class.\n\n        It tries to connect to all physically connected camera devices and creates sockets for each device.\n        This class runs on port 8090. Each socket for each camera runs on the nextmost port (8091+).\n\n        :param path_to_configs: The path to the configs of the camera you want to use.\n        :param autostart: If set to true the manager will automatically start sockets for all cameras that are configured (meaning: all cameras it finds a config file for)\n        :param chose_cameras: If set to true the manager will ask which cameras you want to start.\n        \"\"\"\n        super().__init__(name=\"Manager\")\n\n        self._flask = Flask(__name__)\n        self._subprocess_dict = {}\n        self._port = 8090\n        self._path = path_to_configs\n        self._configs = {}\n        self._chosen_cameras = None\n\n        self.cam_status = []\n        self.cameras_with_type_config = CameraList()\n        self.available_cameras = None\n\n        if autostart and chose_cameras:\n            raise ValueError(\"You can not use autostart and chose_cameras in conjunction.\")\n\n        if not autostart:\n            if chose_cameras:\n                self.available_cameras = self._get_video_device()\n            else:\n                while self.available_cameras is None:\n                    time.sleep(1)\n        else:\n            self.available_cameras = get_connected_cams()\n\n        @atexit.register\n        def __exit():\n            for key, value in self._subprocess_dict.items():\n                requests.post(f\"http://localhost:{key}/kill\", data=\"now\")\n\n        @self._flask.route(\"/info\", methods=[\"GET\"])\n        def get_camera_info():\n            method = request.method\n            if method != \"GET\":\n                print(\"WTF?\")\n            return jsonify(self.cam_status)\n\n        @self._flask.get(\"/config\")\n        def get_cam_config():\n            port = request.args.get(\"port\", default=None, type=int)\n            return jsonify(self._configs[port])\n\n        @self._flask.route(\"/\", methods=[\"GET\", \"POST\"])\n        def index():\n            \"\"\"\n            Start page.\n            \"\"\"\n            method = request.method\n            if method != \"GET\":\n                print(\"WTF?\")\n            return render_template(\"index.html\")\n\n        @self._flask.route(\"/available_cams\", methods=[\"GET\"])\n        def available_cams():\n            \"\"\"\n            Start page.\n            \"\"\"\n            method = request.method\n            if method != \"GET\":\n                print(\"WTF?\")\n            cams = get_connected_cams()\n            return jsonify([cam.to_dict() for cam in cams])\n\n        @self._flask.route(\"/config/calibration\", methods=[\"GET\"])\n        def config_calibration():\n            \"\"\"\n            Start page.\n            \"\"\"\n            method = request.method\n            if method != \"GET\":\n                print(\"WTF\")\n            print(jsonify({key: value.to_dict() for key, value in self._configs.items()}).json)\n            return render_template(\n                \"calibration.html\", configs=self._configs, configs_json=jsonify({key: value.to_dict() for key, value in self._configs.items()}).json\n            )\n\n    def __rotate_file_bkup(self, filename: pathlib.Path, max_bkup=5):\n        bkup_filename = filename.parent / f\"{filename.name}.{max_bkup}\"\n        if bkup_filename.exists():\n            # Delete latest bkup, which is \"shifted out\"\n            bkup_filename.unlink()\n\n        for i in range(max_bkup, 0, -1):\n            if i > 1:\n                bkup_filename = filename.parent / f\"{filename.name}.{i-1}\"\n            else:\n                bkup_filename = filename\n\n            target_filename = filename.parent / f\"{filename.name}.{i}\"\n            if bkup_filename.exists():\n                bkup_filename.rename(target_filename)\n                # print(f\"Renaming {bkup_filename.name} -> {target_filename.name}\")\n\n    def __write_configuration_file(self, filename: pathlib.Path, content: str, max_bkup=4):\n        self.__rotate_file_bkup(filename, max_bkup)\n\n        with open(filename, \"w\") as config_file:\n            config_file.write(content)\n\n    def _get_video_device(self) -> list[VideoDevice]:\n        streams: list[VideoDevice] = get_connected_cams(verbose=True)\n        idx = [int(x) for x in input(\"\\nEnter the stream indeces seperated by whitespace: \").split()]\n        return [streams[i] for i in idx]\n\n    def run(self):\n        \"\"\"\n        Runs the manager application.\n        \"\"\"\n\n        type_configs = get_configs(self._path / \"type_configs/\")\n        model_configs = get_configs(self._path / \"model_configs/\")\n        ignored_configs = []\n        i = 1\n\n        for cam in self.available_cameras:\n            status = {\n                \"CAM TYPE\": cam.product,\n                \"CAM SERIAL\": cam.serial,\n                \"CONFIG TYPE\": False,\n                \"CALIBRATION INDIVIDUAL\": False,\n                \"PORT\": None,\n                \"PORT ACTIVE\": False,\n                \"TYPE CALIBRATION AVAILABLE\": False,\n            }\n            for tconfig in type_configs:\n                if tconfig in ignored_configs:\n                    continue\n                with open(tconfig) as tcfg:\n                    json_tcfg = json.load(tcfg)\n\n                    if not check_config(json_tcfg, mode=\"type\", config_path=tconfig):\n                        status[\"CONFIG TYPE\"] = False\n                        ignored_configs.append(tconfig)\n                        continue\n\n                    if json_tcfg[\"cam_product\"] == cam.product:\n                        status[\"CONFIG TYPE\"] = True\n                        if json_tcfg[\"type_calib_available\"]:\n                            status[\"TYPE CALIBRATION AVAILABLE\"] = True\n                            self.cameras_with_type_config.add_device(\n                                device=cam,\n                                calibration_file=json_tcfg[\"type_calibration\"],\n                                resolution=ImageResolution(json_tcfg[\"standard_resolution\"][0], json_tcfg[\"standard_resolution\"][1]),\n                                name=cam.product,\n                                last_updated=json_tcfg[\"last_updated\"],\n                                type_calibration_available=json_tcfg[\"type_calib_available\"],\n                            )\n                        else:\n                            status[\"TYPE CALIBRATION AVAILABLE\"] = False\n                            self.cameras_with_type_config.add_device(\n                                device=cam,\n                                calibration_file=None,\n                                resolution=ImageResolution(json_tcfg[\"standard_resolution\"][0], json_tcfg[\"standard_resolution\"][1]),\n                                name=cam.product,\n                                last_updated=json_tcfg[\"last_updated\"],\n                                type_calibration_available=json_tcfg[\"type_calib_available\"],\n                            )\n\n                        port = self._port + i\n                        i += 1\n                        tm_cam = self.cameras_with_type_config.para_set_list[-1]\n                        already_open = False\n\n                        for mconfig in model_configs:\n                            with open(mconfig) as mcfg:\n                                json_mcfg = json.load(mcfg)\n                                if json_mcfg[\"cam_product\"] == cam.product and json_mcfg[\"cam_serial\"] == cam.serial:\n                                    self._configs[port] = {\"CONFIG TYPE\": json_tcfg, \"CONFIG MODEL\": json_mcfg}\n\n                                    self.__write_configuration_file(\n                                        pathlib.Path(__file__).parent.parent / f\"camera_app/temp/model_configs/{port}.json\", json_mcfg\n                                    )\n                                    self.__write_configuration_file(\n                                        pathlib.Path(__file__).parent.parent / f\"camera_app/temp/type_configs/{port}.json\",\n                                        json.dumps(tm_cam.to_dict(), default=str),\n                                    )\n\n                                    self._subprocess_dict[port] = subprocess.Popen(\n                                        [\n                                            f\"{pathlib.Path(__file__).parent.parent.parent.parent / 'venv/bin/python'}\",\n                                            f\"{pathlib.Path(__file__).parent.parent / 'camera_app/camera_interface.py'}\",\n                                            f\"{port}\",\n                                        ]\n                                    )\n                                    already_open = True\n                                    status[\"CALIBRATION INDIVIDUAL\"] = True\n                                    status[\"PORT\"] = port\n                                    status[\"PORT ACTIVE\"] = True\n                                    break\n\n                        if not already_open:\n                            self._configs[port] = {\"CONFIG TYPE\": json_tcfg, \"CONFIG MODEL\": None}\n                            self.__write_configuration_file(\n                                pathlib.Path(__file__).parent.parent / f\"camera_app/temp/type_configs/{port}.json\",\n                                json.dumps(tm_cam.to_dict(), default=str),\n                            )\n                            self._subprocess_dict[port] = subprocess.Popen(\n                                [\n                                    f\"{pathlib.Path(__file__).parent.parent.parent.parent / 'venv/bin/python'}\",\n                                    f\"{pathlib.Path(__file__).parent.parent / 'camera_app/camera_interface.py'}\",\n                                    f\"{port}\",\n                                ]\n                            )\n                            status[\"CALIBRATION INDIVIDUAL\"] = False\n                            status[\"PORT\"] = port\n                            status[\"PORT ACTIVE\"] = True\n                        break\n                    else:\n                        status[\"CONFIG TYPE\"] = False\n            self.cam_status.append(status)\n\n        header = self.cam_status[0].keys()\n        rows = [x.values() for x in self.cam_status]\n        print(tabulate.tabulate(rows, header))\n\n        serve(self._flask, host=\"0.0.0.0\", port=self._port)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/camera_management/camera_management_app/manager_interface.py b/src/camera_management/camera_management_app/manager_interface.py
--- a/src/camera_management/camera_management_app/manager_interface.py	
+++ b/src/camera_management/camera_management_app/manager_interface.py	
@@ -44,6 +44,7 @@
         self._path = path_to_configs
         self._configs = {}
         self._chosen_cameras = None
+        self.__cam_config_path = pathlib.Path(__file__).parent.parent / "camera_app/temp/"
 
         self.cam_status = []
         self.cameras_with_type_config = CameraList()
@@ -129,12 +130,20 @@
                 bkup_filename.rename(target_filename)
                 # print(f"Renaming {bkup_filename.name} -> {target_filename.name}")
 
-    def __write_configuration_file(self, filename: pathlib.Path, content: str, max_bkup=4):
-        self.__rotate_file_bkup(filename, max_bkup)
+    def __write_configuration_file(self, path: pathlib.Path, filename: str, mode: str, content: str, max_bkup=4):
 
-        with open(filename, "w") as config_file:
+        if mode == 'type_config':
+            dest = 'type_configs'
+        elif mode == 'model_config':
+            dest = 'model_configs'
+        else:
+            raise ValueError(f'{mode} is not a valid mode. Valid modes are "type_config" and "model_config".')
+        self.__rotate_file_bkup(path / dest / filename, max_bkup)
+
+        with open(path / dest / filename, "w") as config_file:
             config_file.write(content)
 
+
     def _get_video_device(self) -> list[VideoDevice]:
         streams: list[VideoDevice] = get_connected_cams(verbose=True)
         idx = [int(x) for x in input("\nEnter the stream indeces seperated by whitespace: ").split()]
@@ -205,13 +214,8 @@
                                 if json_mcfg["cam_product"] == cam.product and json_mcfg["cam_serial"] == cam.serial:
                                     self._configs[port] = {"CONFIG TYPE": json_tcfg, "CONFIG MODEL": json_mcfg}
 
-                                    self.__write_configuration_file(
-                                        pathlib.Path(__file__).parent.parent / f"camera_app/temp/model_configs/{port}.json", json_mcfg
-                                    )
-                                    self.__write_configuration_file(
-                                        pathlib.Path(__file__).parent.parent / f"camera_app/temp/type_configs/{port}.json",
-                                        json.dumps(tm_cam.to_dict(), default=str),
-                                    )
+                                    self.__write_configuration_file(self.__cam_config_path, mode='model_config', filename=f"{port}.json", content=json_mcfg)
+                                    self.__write_configuration_file(self.__cam_config_path, mode='type_config', filename=f"{port}.json", content=json.dumps(tm_cam.to_dict(), default=str))
 
                                     self._subprocess_dict[port] = subprocess.Popen(
                                         [
@@ -228,10 +232,9 @@
 
                         if not already_open:
                             self._configs[port] = {"CONFIG TYPE": json_tcfg, "CONFIG MODEL": None}
-                            self.__write_configuration_file(
-                                pathlib.Path(__file__).parent.parent / f"camera_app/temp/type_configs/{port}.json",
-                                json.dumps(tm_cam.to_dict(), default=str),
-                            )
+                            self.__write_configuration_file(self.__cam_config_path, mode='type_config',
+                                                            filename=f"{port}.json",
+                                                            content=json.dumps(tm_cam.to_dict(), default=str))
                             self._subprocess_dict[port] = subprocess.Popen(
                                 [
                                     f"{pathlib.Path(__file__).parent.parent.parent.parent / 'venv/bin/python'}",
