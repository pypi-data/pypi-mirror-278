

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)

class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("uniffi_iroh")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 24
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_iroh_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_iroh_checksum_func_key_to_path() != 1201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_func_path_to_key() != 27769:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_func_set_log_level() != 52296:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_func_start_metrics_collection() != 17691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_as_abort() != 64540:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_as_all_done() != 24629:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_as_done() != 65369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_as_found() != 14508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_as_progress() != 54075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addprogress_type() != 63416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_author_id() != 49771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_author_to_string() != 53120:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_authorid_equal() != 53671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_authorid_to_string() != 42389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_blobticket_as_download_request() != 22131:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_blobticket_format() != 22598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_blobticket_hash() != 5648:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_blobticket_node_addr() != 28080:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_blobs() != 26191:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_is_empty() != 46151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_len() != 3727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_links() != 52333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_names() != 17514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_collection_push() != 50200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_connectiontype_as_direct() != 27175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_connectiontype_as_mixed() != 41300:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_connectiontype_as_relay() != 40210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_connectiontype_type() != 1057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_directaddrinfo_addr() != 41252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_directaddrinfo_last_control() != 46706:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_directaddrinfo_last_payload() != 16797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_directaddrinfo_latency() != 62303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_close() != 23013:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_del() != 22285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_export_file() != 34185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_get_download_policy() != 13666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_get_exact() != 48441:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_get_many() != 58857:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_get_one() != 25151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_id() != 32607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_import_file() != 33349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_leave() != 55816:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_set_bytes() != 46067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_set_download_policy() != 13428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_set_hash() != 20311:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_share() != 32184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_start_sync() != 54158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_status() != 59550:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_doc_subscribe() != 2866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docexportprogress_as_abort() != 39226:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docexportprogress_as_found() != 11254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docexportprogress_as_progress() != 8859:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docexportprogress_type() != 43844:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_as_abort() != 45779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_as_all_done() != 7478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_as_found() != 55008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done() != 37186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_as_progress() != 35401:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportprogress_type() != 49227:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_abort() != 13741:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_all_done() != 51121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_done() != 54270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found() != 13482:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq() != 64232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found_local() != 2930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_as_progress() != 7204:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadprogress_type() != 8349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_author() != 26124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_content_bytes() != 26896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_content_hash() != 39306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_content_len() != 60107:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_key() != 19122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_entry_namespace() != 52248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_filterkind_matches() != 35187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_hash_equal() != 52326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_hash_to_bytes() != 29465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_hash_to_hex() != 27622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_hash_to_string() != 61408:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_author_create() != 31148:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_author_delete() != 38335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_author_export() != 18180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_author_import() != 35274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_author_list() != 12499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes() != 39803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path() != 38440:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection() != 15721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob() != 24766:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_download() != 50921:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_export() != 24742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection() != 45730:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list() != 49039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections() != 28497:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete() != 39285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes() != 40980:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes() != 6512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_share() != 44444:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_size() != 9420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path() != 9029:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_connection_info() != 31037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_connections() != 37352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_doc_create() != 64213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_doc_drop() != 49858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_doc_join() != 48292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_doc_list() != 44252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_doc_open() != 47317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_node_id() != 31962:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_stats() != 16158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_status() != 32660:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_tags_delete() != 19876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_irohnode_tags_list() != 6726:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_content_ready() != 15237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_local() != 431:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_remote() != 17302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down() != 154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up() != 25727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_as_sync_finished() != 14329:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_liveevent_type() != 35533:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses() != 44368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodeaddr_equal() != 40672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodeaddr_relay_url() != 52692:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs() != 43813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr() != 37017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_nodestatusresponse_version() != 50257:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_publickey_equal() != 13922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_publickey_fmt_short() != 33947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_publickey_to_bytes() != 54334:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_publickey_to_string() != 48998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_query_limit() != 6405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_query_offset() != 5309:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_rangespec_is_all() != 17079:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_rangespec_is_empty() != 55537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_author_from_string() != 52919:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_authorid_from_string() != 14210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new() != 40776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_blobticket_new() != 38754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_collection_new() != 41716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_everything() != 38497:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except() != 43304:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing() != 1427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except() != 28298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_filterkind_exact() != 52030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_filterkind_prefix() != 40434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_hash_from_bytes() != 19134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_hash_from_string() != 30790:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_hash_new() != 22809:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_irohnode_new() != 22562:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_irohnode_with_options() != 40905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_nodeaddr_new() != 30442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_publickey_from_bytes() != 65104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_publickey_from_string() != 18975:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_all() != 18362:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_author() != 5981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_author_key_exact() != 34711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_author_key_prefix() != 20638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_key_exact() != 32100:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_key_prefix() != 44412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_query_single_latest_per_key() != 42778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_settagoption_auto() != 13040:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_settagoption_named() != 61876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap() != 60952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_constructor_wrapoption_wrap() != 59295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_addcallback_progress() != 42266:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docexportfilecallback_progress() != 20951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_docimportfilecallback_progress() != 18783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_downloadcallback_progress() != 64403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_checksum_method_subscribecallback_event() != 18725:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_iroh_fn_free_addprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_addprogress.restype = None
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_addprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_addprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_author.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_author_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_author_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_author_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_author_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_author_to_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_author_to_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_authorid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_authorid.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_authorid_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_authorid_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_authorid_to_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_authorid_to_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_free_blobticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_blobticket.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_blobticket_format.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_blobticket_format.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_blobticket_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_blobticket_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_free_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_collection.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_collection_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_collection_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_collection_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_blobs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_collection_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_collection_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_fn_method_collection_links.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_links.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_collection_names.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_names.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_collection_push.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_collection_push.restype = None
_UniffiLib.uniffi_iroh_fn_free_connectiontype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_connectiontype.restype = None
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_connectiontype_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_connectiontype_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_directaddrinfo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_directaddrinfo.restype = None
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_doc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_doc.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_close.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_del.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_del.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_fn_method_doc_export_file.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_export_file.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_doc_get_exact.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_get_exact.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_get_many.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_get_many.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_get_one.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_get_one.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_import_file.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_import_file.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_leave.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_leave.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_set_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_set_hash.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_share.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_share.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_start_sync.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_start_sync.restype = None
_UniffiLib.uniffi_iroh_fn_method_doc_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_doc_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_doc_subscribe.restype = None
_UniffiLib.uniffi_iroh_fn_free_docexportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_docexportprogress.restype = None
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_docimportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_docimportprogress.restype = None
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_downloadpolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_downloadpolicy.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_free_downloadprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_downloadprogress.restype = None
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_entry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_entry.restype = None
_UniffiLib.uniffi_iroh_fn_method_entry_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_entry_content_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_content_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_entry_content_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_content_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_fn_method_entry_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_entry_namespace.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_entry_namespace.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_filterkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_filterkind.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_filterkind_matches.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_filterkind_matches.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_free_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_hash.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_hash_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_hash_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_hash_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_hash_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_hash_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_hash_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_hash_to_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_hash_to_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_irohnode.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_irohnode.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_delete.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_delete.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_export.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_export.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_import.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_import.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_connections.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_connections.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_stats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_stats.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_irohnode_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_status.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete.restype = None
_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_liveevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_liveevent.restype = None
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_liveevent_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_liveevent_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_nodeaddr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_nodeaddr.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse.restype = None
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_publickey.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_publickey_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_publickey_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_publickey_to_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_publickey_to_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_free_query.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_query.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_query_all.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_author.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_method_query_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_query_limit.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_method_query_offset.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_query_offset.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_fn_free_rangespec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_rangespec.restype = None
_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_fn_free_settagoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_settagoption.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_free_wrapoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_free_wrapoption.restype = None
_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_fn_init_callback_addcallback.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_init_callback_addcallback.restype = None
_UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback.restype = None
_UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback.restype = None
_UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback.restype = None
_UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback.restype = None
_UniffiLib.uniffi_iroh_fn_func_key_to_path.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_func_key_to_path.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_func_path_to_key.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_func_path_to_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_fn_func_set_log_level.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_func_set_log_level.restype = None
_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection.restype = None
_UniffiLib.ffi_iroh_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rustbuffer_free.restype = None
_UniffiLib.ffi_iroh_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_rust_future_continuation_callback_set.argtypes = (
    _UNIFFI_FUTURE_CONTINUATION_T,
)
_UniffiLib.ffi_iroh_rust_future_continuation_callback_set.restype = None
_UniffiLib.ffi_iroh_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_u8.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_iroh_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_u8.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_iroh_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_i8.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_iroh_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_i8.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_iroh_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_u16.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_iroh_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_u16.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_iroh_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_i16.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_iroh_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_i16.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_iroh_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_u32.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_iroh_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_u32.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_iroh_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_i32.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_iroh_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_i32.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_iroh_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_u64.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_iroh_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_u64.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_iroh_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_i64.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_iroh_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_i64.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_iroh_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_f32.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_iroh_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_f32.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_iroh_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_f64.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_iroh_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_f64.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_iroh_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_iroh_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_pointer.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_iroh_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_iroh_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_iroh_rust_future_poll_void.restype = None
_UniffiLib.ffi_iroh_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_cancel_void.restype = None
_UniffiLib.ffi_iroh_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_iroh_rust_future_free_void.restype = None
_UniffiLib.ffi_iroh_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_rust_future_complete_void.restype = None
_UniffiLib.uniffi_iroh_checksum_func_key_to_path.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_func_key_to_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_func_path_to_key.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_func_path_to_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_func_set_log_level.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_func_set_log_level.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_func_start_metrics_collection.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_func_start_metrics_collection.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_author_id.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_author_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_author_to_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_author_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_authorid_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_authorid_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_authorid_to_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_authorid_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_blobticket_as_download_request.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_blobticket_as_download_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_blobticket_format.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_blobticket_format.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_blobticket_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_blobticket_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_blobticket_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_blobticket_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_blobs.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_blobs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_is_empty.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_len.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_links.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_links.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_names.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_names.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_collection_push.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_collection_push.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_direct.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_direct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_mixed.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_mixed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_relay.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_connectiontype_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_control.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_control.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_payload.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_payload.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_latency.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_latency.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_close.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_del.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_del.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_export_file.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_export_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_get_download_policy.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_get_download_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_get_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_get_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_get_many.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_get_many.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_get_one.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_get_one.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_id.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_import_file.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_import_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_leave.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_leave.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_set_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_set_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_set_download_policy.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_set_download_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_set_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_set_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_share.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_share.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_start_sync.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_start_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_status.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_doc_subscribe.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_doc_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_done.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_local.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_local.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_author.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_content_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_content_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_content_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_content_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_content_len.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_content_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_key.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_entry_namespace.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_entry_namespace.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_filterkind_matches.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_filterkind_matches.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_hash_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_hash_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_hash_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_hash_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_hash_to_hex.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_hash_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_hash_to_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_hash_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_create.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_delete.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_export.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_export.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_import.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_import.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_list.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_download.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_download.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_export.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_export.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_share.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_share.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_size.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_connection_info.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_connection_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_connections.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_connections.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_create.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_drop.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_drop.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_join.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_join.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_list.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_open.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_open.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_node_id.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_stats.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_stats.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_status.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_delete.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_list.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_content_ready.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_content_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_local.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_local.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_liveevent_type.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_liveevent_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_relay_url.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_version.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_publickey_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_publickey_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_publickey_fmt_short.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_publickey_fmt_short.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_publickey_to_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_publickey_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_query_limit.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_query_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_query_offset.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_query_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_all.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_empty.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_author_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_author_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_authorid_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_authorid_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_blobticket_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_blobticket_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_collection_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_collection_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_hash_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_hash_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_with_options.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_with_options.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_nodeaddr_new.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_nodeaddr_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_all.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_author.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_key_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_key_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_key_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_key_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_query_single_latest_per_key.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_query_single_latest_per_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_auto.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_auto.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_named.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_named.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_wrap.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_addcallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_addcallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docexportfilecallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docexportfilecallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_docimportfilecallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_docimportfilecallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_downloadcallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_downloadcallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_checksum_method_subscribecallback_event.argtypes = (
)
_UniffiLib.uniffi_iroh_checksum_method_subscribecallback_event.restype = ctypes.c_uint16
_UniffiLib.ffi_iroh_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_iroh_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def write(value, buf):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))
        buf.write_i32(len(value))
        buf.write(value)

# The Timestamp type.
Timestamp = datetime.datetime

# There is a loss of precision when converting from Rust timestamps,
# which are accurate to the nanosecond,
# to Python datetimes, which have a variable precision due to the use of float as representation.
class _UniffiConverterTimestamp(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_i64()
        microseconds = buf.read_u32() / 1000
        # Use fromtimestamp(0) then add the seconds using a timedelta.  This
        # ensures that we get OverflowError rather than ValueError when
        # seconds is too large.
        if seconds >= 0:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) + datetime.timedelta(seconds=seconds, microseconds=microseconds)
        else:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) - datetime.timedelta(seconds=-seconds, microseconds=microseconds)

    @staticmethod
    def write(value, buf):
        if value >= datetime.datetime.fromtimestamp(0, datetime.timezone.utc):
            sign = 1
            delta = value - datetime.datetime.fromtimestamp(0, datetime.timezone.utc)
        else:
            sign = -1
            delta = datetime.datetime.fromtimestamp(0, datetime.timezone.utc) - value

        seconds = delta.seconds + delta.days * 24 * 3600
        nanoseconds = delta.microseconds * 1000
        buf.write_i64(sign * seconds)
        buf.write_u32(nanoseconds)

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class _UniffiConverterDuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_u64()
        microseconds = buf.read_u32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")
        buf.write_i64(seconds)
        buf.write_u32(nanoseconds)



class AddProgress:
    '''Progress updates for the add operation.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_addprogress, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "AddProgressAbort":
        '''Return the `AddProgressAbort`'''
        return _UniffiConverterTypeAddProgressAbort.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort,self._pointer,)
        )






    def as_all_done(self, ) -> "AddProgressAllDone":
        '''Return the `AddAllDone`'''
        return _UniffiConverterTypeAddProgressAllDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done,self._pointer,)
        )






    def as_done(self, ) -> "AddProgressDone":
        '''Return the `AddProgressDone` event'''
        return _UniffiConverterTypeAddProgressDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done,self._pointer,)
        )






    def as_found(self, ) -> "AddProgressFound":
        '''Return the `AddProgressFound` event'''
        return _UniffiConverterTypeAddProgressFound.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found,self._pointer,)
        )






    def as_progress(self, ) -> "AddProgressProgress":
        '''Return the `AddProgressProgress` event'''
        return _UniffiConverterTypeAddProgressProgress.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress,self._pointer,)
        )






    def type(self, ) -> "AddProgressType":
        '''Get the type of event'''
        return _UniffiConverterTypeAddProgressType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_type,self._pointer,)
        )






class _UniffiConverterTypeAddProgress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AddProgress):
            raise TypeError("Expected AddProgress instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AddProgress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Author:
    '''
    Author key to insert entries in a document

    Internally, an author is a `SigningKey` which is used to sign entries.
    '''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_author, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, str: "str"):
        '''Get an [`Author`] from a String'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_author_from_string,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def id(self, ) -> "AuthorId":
        '''Get the [`AuthorId`] of this Author'''
        return _UniffiConverterTypeAuthorId.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_author_id,self._pointer,)
        )






    def to_string(self, ) -> "str":
        '''Return the AuthorId as a string'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_author_to_string,self._pointer,)
        )






class _UniffiConverterTypeAuthor:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Author):
            raise TypeError("Expected Author instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Author._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class AuthorId:
    '''Identifier for an [`Author`]'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_authorid, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, str: "str"):
        '''Get an [`AuthorId`] from a String'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def equal(self, other: "AuthorId") -> "bool":
        '''Returns true when both AuthorId's have the same value'''
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_authorid_equal,self._pointer,
        _UniffiConverterTypeAuthorId.lower(other))
        )






    def to_string(self, ) -> "str":
        '''Return the AuthorId as a string'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_authorid_to_string,self._pointer,)
        )






class _UniffiConverterTypeAuthorId:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AuthorId):
            raise TypeError("Expected AuthorId instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AuthorId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class BlobDownloadRequest:
    '''A request to the node to download and share the data specified by the hash.'''

    _pointer: ctypes.c_void_p
    def __init__(self, hash: "Hash",format: "BlobFormat",node: "NodeAddr",tag: "SetTagOption"):
        
        
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new,
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterTypeBlobFormat.lower(format),
        _UniffiConverterTypeNodeAddr.lower(node),
        _UniffiConverterTypeSetTagOption.lower(tag))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeBlobDownloadRequest:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BlobDownloadRequest):
            raise TypeError("Expected BlobDownloadRequest instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BlobDownloadRequest._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class BlobTicket:
    '''
    A token containing everything to get a file from the provider.

    It is a single item which can be easily serialized and deserialized.
    '''

    _pointer: ctypes.c_void_p
    def __init__(self, ticket: "str"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new,
        _UniffiConverterString.lower(ticket))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_blobticket, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_download_request(self, ) -> "BlobDownloadRequest":
        '''Turn this ticket into parameters for blobs_download.'''
        return _UniffiConverterTypeBlobDownloadRequest.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request,self._pointer,)
        )






    def format(self, ) -> "BlobFormat":
        '''The format of the blob.'''
        return _UniffiConverterTypeBlobFormat.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_format,self._pointer,)
        )






    def hash(self, ) -> "Hash":
        '''The hash to retrieve.'''
        return _UniffiConverterTypeHash.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_hash,self._pointer,)
        )






    def node_addr(self, ) -> "NodeAddr":
        '''The provider to get a file from.'''
        return _UniffiConverterTypeNodeAddr.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr,self._pointer,)
        )






class _UniffiConverterTypeBlobTicket:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BlobTicket):
            raise TypeError("Expected BlobTicket instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BlobTicket._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Collection:
    '''
    A collection of blobs

    Note that the format is subject to change.
    '''

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        '''Create a new empty collection'''
        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_collection_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_collection, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def blobs(self, ) -> "typing.List[LinkAndName]":
        '''Returns a [`Link`] (the name and the hash), for each blob in the collection.'''
        return _UniffiConverterSequenceTypeLinkAndName.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_blobs,self._pointer,)
        )






    def is_empty(self, ) -> "bool":
        '''Check if the collection is empty'''
        return _UniffiConverterBool.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_is_empty,self._pointer,)
        )






    def len(self, ) -> "int":
        '''Returns the number of blobs in this collection'''
        return _UniffiConverterUInt64.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_len,self._pointer,)
        )






    def links(self, ) -> "typing.List[Hash]":
        '''Get the links to the blobs in this collection'''
        return _UniffiConverterSequenceTypeHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_links,self._pointer,)
        )






    def names(self, ) -> "typing.List[str]":
        '''Get the names of the blobs in this collection'''
        return _UniffiConverterSequenceString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_names,self._pointer,)
        )






    def push(self, name: "str",hash: "Hash"):
        '''Add the given blob to the collection'''
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_push,self._pointer,
        _UniffiConverterString.lower(name),
        _UniffiConverterTypeHash.lower(hash))







class _UniffiConverterTypeCollection:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Collection):
            raise TypeError("Expected Collection instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Collection._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ConnectionType:
    '''The type of connection we have to the node'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_connectiontype, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_direct(self, ) -> "str":
        '''Return the socket address if this is a direct connection'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct,self._pointer,)
        )






    def as_mixed(self, ) -> "ConnectionTypeMixed":
        '''Return the socket address and relay url if this is a mixed connection'''
        return _UniffiConverterTypeConnectionTypeMixed.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed,self._pointer,)
        )






    def as_relay(self, ) -> "str":
        '''Return the relay url if this is a relay connection'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay,self._pointer,)
        )






    def type(self, ) -> "ConnType":
        '''Whether connection is direct, relay, mixed, or none'''
        return _UniffiConverterTypeConnType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_type,self._pointer,)
        )






class _UniffiConverterTypeConnectionType:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ConnectionType):
            raise TypeError("Expected ConnectionType instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ConnectionType._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DirectAddrInfo:
    '''Information about a direct address.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_directaddrinfo, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def addr(self, ) -> "str":
        '''Get the reported address'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr,self._pointer,)
        )






    def last_control(self, ) -> "typing.Optional[LatencyAndControlMsg]":
        '''Get the last control message received by this node'''
        return _UniffiConverterOptionalTypeLatencyAndControlMsg.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control,self._pointer,)
        )






    def last_payload(self, ) -> "typing.Optional[Duration]":
        '''Get how long ago the last payload message was received for this node'''
        return _UniffiConverterOptionalDuration.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload,self._pointer,)
        )






    def latency(self, ) -> "typing.Optional[Duration]":
        '''Get the reported latency, if it exists'''
        return _UniffiConverterOptionalDuration.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency,self._pointer,)
        )






class _UniffiConverterTypeDirectAddrInfo:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DirectAddrInfo):
            raise TypeError("Expected DirectAddrInfo instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DirectAddrInfo._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Doc:
    '''A representation of a mutable, synchronizable key-value store.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_doc, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def close(self, ):
        '''Close the document.'''
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_close,self._pointer,)







    def _del(self, author_id: "AuthorId",prefix: "bytes") -> "int":
        '''
        Delete entries that match the given `author` and key `prefix`.

        This inserts an empty entry with the key set to `prefix`, effectively clearing all other
        entries whose key starts with or is equal to the given `prefix`.

        Returns the number of entries deleted.
        '''
        
        
        return _UniffiConverterUInt64.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_del,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author_id),
        _UniffiConverterBytes.lower(prefix))
        )






    def export_file(self, entry: "Entry",path: "str",cb: "typing.Optional[DocExportFileCallback]"):
        '''Export an entry as a file to a given absolute path'''
        
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_export_file,self._pointer,
        _UniffiConverterTypeEntry.lower(entry),
        _UniffiConverterString.lower(path),
        _UniffiConverterOptionalCallbackInterfaceDocExportFileCallback.lower(cb))







    def get_download_policy(self, ) -> "DownloadPolicy":
        '''Get the download policy for this document'''
        return _UniffiConverterTypeDownloadPolicy.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy,self._pointer,)
        )






    def get_exact(self, author: "AuthorId",key: "bytes",include_empty: "bool") -> "typing.Optional[Entry]":
        '''
        Get an entry for a key and author.

        Optionally also get the entry if it is empty (i.e. a deletion marker)
        '''
        
        
        
        return _UniffiConverterOptionalTypeEntry.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_exact,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterBool.lower(include_empty))
        )






    def get_many(self, query: "Query") -> "typing.List[Entry]":
        '''
        Get entries.

        Note: this allocates for each `Entry`, if you have many `Entry`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        '''
        
        return _UniffiConverterSequenceTypeEntry.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_many,self._pointer,
        _UniffiConverterTypeQuery.lower(query))
        )






    def get_one(self, query: "Query") -> "typing.Optional[Entry]":
        '''Get the latest entry for a key and author.'''
        
        return _UniffiConverterOptionalTypeEntry.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_one,self._pointer,
        _UniffiConverterTypeQuery.lower(query))
        )






    def id(self, ) -> "str":
        '''Get the document id of this doc.'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_doc_id,self._pointer,)
        )






    def import_file(self, author: "AuthorId",key: "bytes",path: "str",in_place: "bool",cb: "typing.Optional[DocImportFileCallback]"):
        '''Add an entry from an absolute file path'''
        
        
        
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_import_file,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterString.lower(path),
        _UniffiConverterBool.lower(in_place),
        _UniffiConverterOptionalCallbackInterfaceDocImportFileCallback.lower(cb))







    def leave(self, ):
        '''Stop the live sync for this document.'''
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_leave,self._pointer,)







    def set_bytes(self, author: "AuthorId",key: "bytes",value: "bytes") -> "Hash":
        '''Set the content of a key to a byte array.'''
        
        
        
        return _UniffiConverterTypeHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterBytes.lower(value))
        )






    def set_download_policy(self, policy: "DownloadPolicy"):
        '''Set the download policy for this document'''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy,self._pointer,
        _UniffiConverterTypeDownloadPolicy.lower(policy))







    def set_hash(self, author: "AuthorId",key: "bytes",hash: "Hash",size: "int"):
        '''Set an entries on the doc via its key, hash, and size.'''
        
        
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_hash,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterUInt64.lower(size))







    def share(self, mode: "ShareMode",addr_options: "AddrInfoOptions") -> "str":
        '''Share this document with peers over a ticket.'''
        
        
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_share,self._pointer,
        _UniffiConverterTypeShareMode.lower(mode),
        _UniffiConverterTypeAddrInfoOptions.lower(addr_options))
        )






    def start_sync(self, peers: "typing.List[NodeAddr]"):
        '''Start to sync this document with a list of peers.'''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_start_sync,self._pointer,
        _UniffiConverterSequenceTypeNodeAddr.lower(peers))







    def status(self, ) -> "OpenState":
        '''Get status info for this document'''
        return _UniffiConverterTypeOpenState.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_status,self._pointer,)
        )






    def subscribe(self, cb: "SubscribeCallback"):
        '''Subscribe to events for this document.'''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_subscribe,self._pointer,
        _UniffiConverterCallbackInterfaceSubscribeCallback.lower(cb))







class _UniffiConverterTypeDoc:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Doc):
            raise TypeError("Expected Doc instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Doc._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DocExportProgress:
    '''Progress updates for the doc import file operation.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_docexportprogress, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DocExportProgressAbort":
        '''Return the `DocExportProgressAbort`'''
        return _UniffiConverterTypeDocExportProgressAbort.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort,self._pointer,)
        )






    def as_found(self, ) -> "DocExportProgressFound":
        '''Return the `DocExportProgressFound` event'''
        return _UniffiConverterTypeDocExportProgressFound.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found,self._pointer,)
        )






    def as_progress(self, ) -> "DocExportProgressProgress":
        '''Return the `DocExportProgressProgress` event'''
        return _UniffiConverterTypeDocExportProgressProgress.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress,self._pointer,)
        )






    def type(self, ) -> "DocExportProgressType":
        '''Get the type of event'''
        return _UniffiConverterTypeDocExportProgressType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type,self._pointer,)
        )






class _UniffiConverterTypeDocExportProgress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DocExportProgress):
            raise TypeError("Expected DocExportProgress instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DocExportProgress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DocImportProgress:
    '''Progress updates for the doc import file operation.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_docimportprogress, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DocImportProgressAbort":
        '''Return the `DocImportProgressAbort`'''
        return _UniffiConverterTypeDocImportProgressAbort.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort,self._pointer,)
        )






    def as_all_done(self, ) -> "DocImportProgressAllDone":
        '''Return the `DocImportProgressAllDone`'''
        return _UniffiConverterTypeDocImportProgressAllDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done,self._pointer,)
        )






    def as_found(self, ) -> "DocImportProgressFound":
        '''Return the `DocImportProgressFound` event'''
        return _UniffiConverterTypeDocImportProgressFound.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found,self._pointer,)
        )






    def as_ingest_done(self, ) -> "DocImportProgressIngestDone":
        '''Return the `DocImportProgressDone` event'''
        return _UniffiConverterTypeDocImportProgressIngestDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done,self._pointer,)
        )






    def as_progress(self, ) -> "DocImportProgressProgress":
        '''Return the `DocImportProgressProgress` event'''
        return _UniffiConverterTypeDocImportProgressProgress.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress,self._pointer,)
        )






    def type(self, ) -> "DocImportProgressType":
        '''Get the type of event'''
        return _UniffiConverterTypeDocImportProgressType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type,self._pointer,)
        )






class _UniffiConverterTypeDocImportProgress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DocImportProgress):
            raise TypeError("Expected DocImportProgress instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DocImportProgress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DownloadPolicy:
    '''Download policy to decide which content blobs shall be downloaded.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_downloadpolicy, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def everything(cls, ):
        '''Download everything'''
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything,)
        return cls._make_instance_(pointer)


    @classmethod
    def everything_except(cls, filters: "typing.List[FilterKind]"):
        '''Download everything except keys that match the given filters'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except,
        _UniffiConverterSequenceTypeFilterKind.lower(filters))
        return cls._make_instance_(pointer)


    @classmethod
    def nothing(cls, ):
        '''Download nothing'''
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing,)
        return cls._make_instance_(pointer)


    @classmethod
    def nothing_except(cls, filters: "typing.List[FilterKind]"):
        '''Download nothing except keys that match the given filters'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except,
        _UniffiConverterSequenceTypeFilterKind.lower(filters))
        return cls._make_instance_(pointer)



class _UniffiConverterTypeDownloadPolicy:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DownloadPolicy):
            raise TypeError("Expected DownloadPolicy instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DownloadPolicy._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class DownloadProgress:
    '''Progress updates for the get operation.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_downloadprogress, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DownloadProgressAbort":
        '''Return the `DownloadProgressAbort`'''
        return _UniffiConverterTypeDownloadProgressAbort.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort,self._pointer,)
        )






    def as_all_done(self, ) -> "DownloadProgressAllDone":
        '''Return the `DownloadProgressAllDone` event'''
        return _UniffiConverterTypeDownloadProgressAllDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done,self._pointer,)
        )






    def as_done(self, ) -> "DownloadProgressDone":
        '''Return the `DownloadProgressDone` event'''
        return _UniffiConverterTypeDownloadProgressDone.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done,self._pointer,)
        )






    def as_found(self, ) -> "DownloadProgressFound":
        '''Return the `DownloadProgressFound` event'''
        return _UniffiConverterTypeDownloadProgressFound.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found,self._pointer,)
        )






    def as_found_hash_seq(self, ) -> "DownloadProgressFoundHashSeq":
        '''Return the `DownloadProgressFoundHashSeq` event'''
        return _UniffiConverterTypeDownloadProgressFoundHashSeq.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq,self._pointer,)
        )






    def as_found_local(self, ) -> "DownloadProgressFoundLocal":
        '''Return the `DownloadProgressFoundLocal` event'''
        return _UniffiConverterTypeDownloadProgressFoundLocal.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local,self._pointer,)
        )






    def as_progress(self, ) -> "DownloadProgressProgress":
        '''Return the `DownloadProgressProgress` event'''
        return _UniffiConverterTypeDownloadProgressProgress.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress,self._pointer,)
        )






    def type(self, ) -> "DownloadProgressType":
        '''
        Get the type of event
        note that there is no `as_connected` method, as the `Connected` event has no associated data
        '''
        return _UniffiConverterTypeDownloadProgressType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type,self._pointer,)
        )






class _UniffiConverterTypeDownloadProgress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, DownloadProgress):
            raise TypeError("Expected DownloadProgress instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return DownloadProgress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Entry:
    '''
    A single entry in a [`Doc`]

    An entry is identified by a key, its [`AuthorId`], and the [`Doc`]'s
    namespace id. Its value is the 32-byte BLAKE3 [`hash`]
    of the entry's content data, the size of this content data, and a timestamp.
    '''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_entry, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def author(self, ) -> "AuthorId":
        '''Get the [`AuthorId`] of this entry.'''
        return _UniffiConverterTypeAuthorId.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_author,self._pointer,)
        )






    def content_bytes(self, doc: "Doc") -> "bytes":
        '''
        Read all content of an [`Entry`] into a buffer.
        This allocates a buffer for the full entry. Use only if you know that the entry you're
        reading is small. If not sure, use [`Self::content_len`] and check the size with
        before calling [`Self::content_bytes`].
        '''
        
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes,self._pointer,
        _UniffiConverterTypeDoc.lower(doc))
        )






    def content_hash(self, ) -> "Hash":
        '''Get the content_hash of this entry.'''
        return _UniffiConverterTypeHash.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_content_hash,self._pointer,)
        )






    def content_len(self, ) -> "int":
        '''Get the content_length of this entry.'''
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_content_len,self._pointer,)
        )






    def key(self, ) -> "bytes":
        '''Get the key of this entry.'''
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_key,self._pointer,)
        )






    def namespace(self, ) -> "str":
        '''Get the namespace id of this entry.'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_namespace,self._pointer,)
        )






class _UniffiConverterTypeEntry:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Entry):
            raise TypeError("Expected Entry instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Entry._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class FilterKind:
    '''Filter strategy used in download policies.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_filterkind, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def exact(cls, key: "bytes"):
        '''Returns a FilterKind that matches if the contained bytes and the key are the same.'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact,
        _UniffiConverterBytes.lower(key))
        return cls._make_instance_(pointer)


    @classmethod
    def prefix(cls, prefix: "bytes"):
        '''Returns a FilterKind that matches if the contained bytes are a prefix of the key.'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix,
        _UniffiConverterBytes.lower(prefix))
        return cls._make_instance_(pointer)



    def matches(self, key: "bytes") -> "bool":
        '''Verifies whether this filter matches a given key'''
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_filterkind_matches,self._pointer,
        _UniffiConverterBytes.lower(key))
        )






class _UniffiConverterTypeFilterKind:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, FilterKind):
            raise TypeError("Expected FilterKind instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return FilterKind._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Hash:
    '''Hash type used throughout Iroh. A blake3 hash.'''

    _pointer: ctypes.c_void_p
    def __init__(self, buf: "bytes"):
        '''Calculate the hash of the provide bytes.'''
        
        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_hash_new,
        _UniffiConverterBytes.lower(buf))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_hash, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        '''Create a Hash from its raw bytes representation.'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, s: "str"):
        '''Make a Hash from hex string'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def equal(self, other: "Hash") -> "bool":
        '''Returns true if the Hash's have the same value'''
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_equal,self._pointer,
        _UniffiConverterTypeHash.lower(other))
        )






    def to_bytes(self, ) -> "bytes":
        '''Bytes of the hash.'''
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes,self._pointer,)
        )






    def to_hex(self, ) -> "str":
        '''Convert the hash to a hex string.'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_hex,self._pointer,)
        )






    def to_string(self, ) -> "str":
        '''Write the hash to a string'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_string,self._pointer,)
        )






class _UniffiConverterTypeHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Hash):
            raise TypeError("Expected Hash instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Hash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class IrohNode:
    '''An Iroh node. Allows you to sync, store, and transfer data.'''

    _pointer: ctypes.c_void_p
    def __init__(self, path: "str"):
        '''
        Create a new iroh node. The `path` param should be a directory where we can store or load
        iroh data from a previous session.
        '''
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new,
        _UniffiConverterString.lower(path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_irohnode, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def with_options(cls, path: "str",opts: "NodeOptions"):
        '''Create a new iroh node with options.'''
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options,
        _UniffiConverterString.lower(path),
        _UniffiConverterTypeNodeOptions.lower(opts))
        return cls._make_instance_(pointer)



    def author_create(self, ) -> "AuthorId":
        '''Create a new author.'''
        return _UniffiConverterTypeAuthorId.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create,self._pointer,)
        )






    def author_delete(self, author: "AuthorId"):
        '''
        Deletes the given author by id.

        Warning: This permanently removes this author.
        '''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_delete,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author))







    def author_export(self, author: "AuthorId") -> "Author":
        '''
        Export the given author.

        Warning: This contains sensitive data.
        '''
        
        return _UniffiConverterTypeAuthor.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_export,self._pointer,
        _UniffiConverterTypeAuthorId.lower(author))
        )






    def author_import(self, author: "Author") -> "AuthorId":
        '''
        Import the given author.

        Warning: This contains sensitive data.
        '''
        
        return _UniffiConverterTypeAuthorId.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_import,self._pointer,
        _UniffiConverterTypeAuthor.lower(author))
        )






    def author_list(self, ) -> "typing.List[AuthorId]":
        '''List all the AuthorIds that exist on this node.'''
        return _UniffiConverterSequenceTypeAuthorId.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list,self._pointer,)
        )






    def blobs_add_bytes(self, bytes: "bytes") -> "BlobAddOutcome":
        '''Write a blob by passing bytes.'''
        
        return _UniffiConverterTypeBlobAddOutcome.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes,self._pointer,
        _UniffiConverterBytes.lower(bytes))
        )






    def blobs_add_from_path(self, path: "str",in_place: "bool",tag: "SetTagOption",wrap: "WrapOption",cb: "AddCallback"):
        '''
        Import a blob from a filesystem path.

        `path` should be an absolute path valid for the file system on which
        the node runs.
        If `in_place` is true, Iroh will assume that the data will not change and will share it in
        place without copying to the Iroh data directory.
        '''
        
        
        
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path,self._pointer,
        _UniffiConverterString.lower(path),
        _UniffiConverterBool.lower(in_place),
        _UniffiConverterTypeSetTagOption.lower(tag),
        _UniffiConverterTypeWrapOption.lower(wrap),
        _UniffiConverterCallbackInterfaceAddCallback.lower(cb))







    def blobs_create_collection(self, collection: "Collection",tag: "SetTagOption",tags_to_delete: "typing.List[str]") -> "HashAndTag":
        '''
        Create a collection from already existing blobs.

        To automatically clear the tags for the passed in blobs you can set
        `tags_to_delete` on those tags, and they will be deleted once the collection is created.
        '''
        
        
        
        return _UniffiConverterTypeHashAndTag.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection,self._pointer,
        _UniffiConverterTypeCollection.lower(collection),
        _UniffiConverterTypeSetTagOption.lower(tag),
        _UniffiConverterSequenceString.lower(tags_to_delete))
        )






    def blobs_delete_blob(self, hash: "Hash"):
        '''Delete a blob.'''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob,self._pointer,
        _UniffiConverterTypeHash.lower(hash))







    def blobs_download(self, req: "BlobDownloadRequest",cb: "DownloadCallback"):
        '''Download a blob from another node and add it to the local database.'''
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download,self._pointer,
        _UniffiConverterTypeBlobDownloadRequest.lower(req),
        _UniffiConverterCallbackInterfaceDownloadCallback.lower(cb))







    def blobs_export(self, hash: "Hash",destination: "str",format: "BlobExportFormat",mode: "BlobExportMode"):
        '''Download a blob from another node and add it to the local database.'''
        
        
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export,self._pointer,
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterString.lower(destination),
        _UniffiConverterTypeBlobExportFormat.lower(format),
        _UniffiConverterTypeBlobExportMode.lower(mode))







    def blobs_get_collection(self, hash: "Hash") -> "Collection":
        '''Read the content of a collection'''
        
        return _UniffiConverterTypeCollection.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






    def blobs_list(self, ) -> "typing.List[Hash]":
        '''
        List all complete blobs.

        Note: this allocates for each `BlobListResponse`, if you have many `BlobListReponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        '''
        return _UniffiConverterSequenceTypeHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list,self._pointer,)
        )






    def blobs_list_collections(self, ) -> "typing.List[BlobListCollectionsResponse]":
        '''
        List all collections.

        Note: this allocates for each `BlobListCollectionsResponse`, if you have many `BlobListCollectionsResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        '''
        return _UniffiConverterSequenceTypeBlobListCollectionsResponse.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections,self._pointer,)
        )






    def blobs_list_incomplete(self, ) -> "typing.List[BlobListIncompleteResponse]":
        '''
        List all incomplete (partial) blobs.

        Note: this allocates for each `BlobListIncompleteResponse`, if you have many `BlobListIncompleteResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        '''
        return _UniffiConverterSequenceTypeBlobListIncompleteResponse.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete,self._pointer,)
        )






    def blobs_read_at_to_bytes(self, hash: "Hash",offset: "int",len: "typing.Optional[int]") -> "bytes":
        '''
        Read all bytes of single blob at `offset` for length `len`.

        This allocates a buffer for the full length `len`. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_at_to_bytes`].
        '''
        
        
        
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes,self._pointer,
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterUInt64.lower(offset),
        _UniffiConverterOptionalUInt64.lower(len))
        )






    def blobs_read_to_bytes(self, hash: "Hash") -> "bytes":
        '''
        Read all bytes of single blob.

        This allocates a buffer for the full blob. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_to_bytes`].
        '''
        
        return _UniffiConverterBytes.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






    def blobs_share(self, hash: "Hash",blob_format: "BlobFormat",ticket_options: "AddrInfoOptions") -> "str":
        '''Create a ticket for sharing a blob or collection from this node.'''
        
        
        
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share,self._pointer,
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterTypeBlobFormat.lower(blob_format),
        _UniffiConverterTypeAddrInfoOptions.lower(ticket_options))
        )






    def blobs_size(self, hash: "Hash") -> "int":
        '''Get the size information on a single blob.'''
        
        return _UniffiConverterUInt64.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






    def blobs_write_to_path(self, hash: "Hash",path: "str"):
        '''
        Export the blob contents to a file path
        The `path` field is expected to be the absolute path.
        '''
        
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path,self._pointer,
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterString.lower(path))







    def connection_info(self, node_id: "PublicKey") -> "typing.Optional[ConnectionInfo]":
        
        return _UniffiConverterOptionalTypeConnectionInfo.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info,self._pointer,
        _UniffiConverterTypePublicKey.lower(node_id))
        )






    def connections(self, ) -> "typing.List[ConnectionInfo]":
        '''Return `ConnectionInfo`s for each connection we have to another iroh node.'''
        return _UniffiConverterSequenceTypeConnectionInfo.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_connections,self._pointer,)
        )






    def doc_create(self, ) -> "Doc":
        '''Create a new doc.'''
        return _UniffiConverterTypeDoc.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create,self._pointer,)
        )






    def doc_drop(self, doc_id: "str"):
        '''
        Delete a document from the local node.

        This is a destructive operation. Both the document secret key and all entries in the
        document will be permanently deleted from the node's storage. Content blobs will be
        deleted through garbage collection unless they are referenced from another document or tag.
        '''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop,self._pointer,
        _UniffiConverterString.lower(doc_id))







    def doc_join(self, ticket: "str") -> "Doc":
        '''Join and sync with an already existing document.'''
        
        return _UniffiConverterTypeDoc.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join,self._pointer,
        _UniffiConverterString.lower(ticket))
        )






    def doc_list(self, ) -> "typing.List[NamespaceAndCapability]":
        '''List all the docs we have access to on this node.'''
        return _UniffiConverterSequenceTypeNamespaceAndCapability.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list,self._pointer,)
        )






    def doc_open(self, id: "str") -> "typing.Optional[Doc]":
        '''
        Get a [`Doc`].

        Returns None if the document cannot be found.
        '''
        
        return _UniffiConverterOptionalTypeDoc.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open,self._pointer,
        _UniffiConverterString.lower(id))
        )






    def node_id(self, ) -> "str":
        '''The string representation of the PublicKey of this node.'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id,self._pointer,)
        )






    def stats(self, ) -> "dict":
        '''Get statistics of the running node.'''
        return _UniffiConverterMapStringTypeCounterStats.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_stats,self._pointer,)
        )






    def status(self, ) -> "NodeStatusResponse":
        '''Get status information about a node'''
        return _UniffiConverterTypeNodeStatusResponse.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_status,self._pointer,)
        )






    def tags_delete(self, name: "bytes"):
        '''Delete a tag.'''
        
        _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete,self._pointer,
        _UniffiConverterBytes.lower(name))







    def tags_list(self, ) -> "typing.List[ListTagsResponse]":
        '''
        List all tags

        Note: this allocates for each `ListTagsResponse`, if you have many `Tags`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        '''
        return _UniffiConverterSequenceTypeListTagsResponse.lift(
            _rust_call_with_error(
    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list,self._pointer,)
        )






class _UniffiConverterTypeIrohNode:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, IrohNode):
            raise TypeError("Expected IrohNode instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return IrohNode._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class LiveEvent:
    '''Events informing about actions of the live sync progress'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_liveevent, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_content_ready(self, ) -> "Hash":
        '''For `LiveEventType::ContentReady`, returns a Hash'''
        return _UniffiConverterTypeHash.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready,self._pointer,)
        )






    def as_insert_local(self, ) -> "Entry":
        '''For `LiveEventType::InsertLocal`, returns an Entry'''
        return _UniffiConverterTypeEntry.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local,self._pointer,)
        )






    def as_insert_remote(self, ) -> "InsertRemoteEvent":
        '''For `LiveEventType::InsertRemote`, returns an InsertRemoteEvent'''
        return _UniffiConverterTypeInsertRemoteEvent.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote,self._pointer,)
        )






    def as_neighbor_down(self, ) -> "PublicKey":
        '''For `LiveEventType::NeighborDown`, returns a PublicKey'''
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down,self._pointer,)
        )






    def as_neighbor_up(self, ) -> "PublicKey":
        '''For `LiveEventType::NeighborUp`, returns a PublicKey'''
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up,self._pointer,)
        )






    def as_sync_finished(self, ) -> "SyncEvent":
        '''For `LiveEventType::SyncFinished`, returns a SyncEvent'''
        return _UniffiConverterTypeSyncEvent.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished,self._pointer,)
        )






    def type(self, ) -> "LiveEventType":
        '''The type LiveEvent'''
        return _UniffiConverterTypeLiveEventType.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_type,self._pointer,)
        )






class _UniffiConverterTypeLiveEvent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, LiveEvent):
            raise TypeError("Expected LiveEvent instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return LiveEvent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NodeAddr:
    '''A peer and it's addressing information.'''

    _pointer: ctypes.c_void_p
    def __init__(self, node_id: "PublicKey",relay_url: "typing.Optional[str]",addresses: "typing.List[str]"):
        '''Create a new [`NodeAddr`] with empty [`AddrInfo`].'''
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new,
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterOptionalString.lower(relay_url),
        _UniffiConverterSequenceString.lower(addresses))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_nodeaddr, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def direct_addresses(self, ) -> "typing.List[str]":
        '''Get the direct addresses of this peer.'''
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses,self._pointer,)
        )






    def equal(self, other: "NodeAddr") -> "bool":
        '''Returns true if both NodeAddr's have the same values'''
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal,self._pointer,
        _UniffiConverterTypeNodeAddr.lower(other))
        )






    def relay_url(self, ) -> "typing.Optional[str]":
        '''Get the relay url of this peer.'''
        return _UniffiConverterOptionalString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url,self._pointer,)
        )






class _UniffiConverterTypeNodeAddr:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NodeAddr):
            raise TypeError("Expected NodeAddr instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NodeAddr._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NodeStatusResponse:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def listen_addrs(self, ) -> "typing.List[str]":
        '''The bound listening addresses of the node'''
        return _UniffiConverterSequenceString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs,self._pointer,)
        )






    def node_addr(self, ) -> "NodeAddr":
        '''The node id and socket addresses of this node.'''
        return _UniffiConverterTypeNodeAddr.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr,self._pointer,)
        )






    def version(self, ) -> "str":
        '''The version of the node'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version,self._pointer,)
        )






class _UniffiConverterTypeNodeStatusResponse:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NodeStatusResponse):
            raise TypeError("Expected NodeStatusResponse instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NodeStatusResponse._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PublicKey:
    '''A public key'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_publickey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        '''Get a PublicKey from a byte slice'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, s: "str"):
        '''Get a PublicKey from a string'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def equal(self, other: "PublicKey") -> "bool":
        '''Returns true when both PublicKeys have the same value'''
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_equal,self._pointer,
        _UniffiConverterTypePublicKey.lower(other))
        )






    def fmt_short(self, ) -> "str":
        '''The first 10 bytes of the PublicKey represented as a string'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short,self._pointer,)
        )






    def to_bytes(self, ) -> "bytes":
        '''Represent a PublicKey as a byte slice'''
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes,self._pointer,)
        )






    def to_string(self, ) -> "str":
        '''Represent a PublicKey as a string'''
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_to_string,self._pointer,)
        )






class _UniffiConverterTypePublicKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PublicKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Query:
    '''
    Build a Query to search for an entry or entries in a doc.

    Use this with `QueryOptions` to determine sorting, grouping, and pagination.
    '''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_query, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def all(cls, opts: "typing.Optional[QueryOptions]"):
        '''
        Query all records.

        If `opts` is `None`, the default values will be used:
            sort_by: SortBy::AuthorKey
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_all,
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)


    @classmethod
    def author(cls, author: "AuthorId",opts: "typing.Optional[QueryOptions]"):
        '''
        Query all entries for by a single author.

        If `opts` is `None`, the default values will be used:
            sort_by: SortBy::AuthorKey
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)


    @classmethod
    def author_key_exact(cls, author: "AuthorId",key: "bytes"):
        '''Create a Query for a single key and author.'''
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key))
        return cls._make_instance_(pointer)


    @classmethod
    def author_key_prefix(cls, author: "AuthorId",prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
        '''
        Create a query for all entries of a single author with a given key prefix.

        If `opts` is `None`, the default values will be used:
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(prefix),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)


    @classmethod
    def key_exact(cls, key: "bytes",opts: "typing.Optional[QueryOptions]"):
        '''
        Query all entries that have an exact key.

        If `opts` is `None`, the default values will be used:
            sort_by: SortBy::AuthorKey
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact,
        _UniffiConverterBytes.lower(key),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)


    @classmethod
    def key_prefix(cls, prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
        '''
        Create a query for all entries with a given key prefix.

        If `opts` is `None`, the default values will be used:
            sort_by: SortBy::AuthorKey
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix,
        _UniffiConverterBytes.lower(prefix),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)


    @classmethod
    def single_latest_per_key(cls, opts: "typing.Optional[QueryOptions]"):
        '''
        Query only the latest entry for each key, omitting older entries if the entry was written
        to by multiple authors.

        If `opts` is `None`, the default values will be used:
            direction: SortDirection::Asc
            offset: None
            limit: None
        '''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key,
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)



    def limit(self, ) -> "typing.Optional[int]":
        '''Get the limit for this query (max. number of entries to emit).'''
        return _UniffiConverterOptionalUInt64.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_query_limit,self._pointer,)
        )






    def offset(self, ) -> "int":
        '''Get the offset for this query (number of entries to skip at the beginning).'''
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_query_offset,self._pointer,)
        )






class _UniffiConverterTypeQuery:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Query):
            raise TypeError("Expected Query instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Query._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RangeSpec:
    '''A chunk range specification as a sequence of chunk offsets'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_rangespec, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def is_all(self, ) -> "bool":
        '''Check if this [`RangeSpec`] selects all chunks in the blob'''
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all,self._pointer,)
        )






    def is_empty(self, ) -> "bool":
        '''Checks if this [`RangeSpec`] does not select any chunks in the blob'''
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty,self._pointer,)
        )






class _UniffiConverterTypeRangeSpec:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RangeSpec):
            raise TypeError("Expected RangeSpec instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RangeSpec._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SetTagOption:
    '''An option for commands that allow setting a tag'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_settagoption, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def auto(cls, ):
        '''Indicate you want an automatically generated tag'''
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto,)
        return cls._make_instance_(pointer)


    @classmethod
    def named(cls, tag: "bytes"):
        '''Indicate you want a named tag'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named,
        _UniffiConverterBytes.lower(tag))
        return cls._make_instance_(pointer)



class _UniffiConverterTypeSetTagOption:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SetTagOption):
            raise TypeError("Expected SetTagOption instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SetTagOption._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class WrapOption:
    '''Whether to wrap the added data in a collection.'''

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_iroh_fn_free_wrapoption, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def no_wrap(cls, ):
        '''Indicate you do not wrap the file or directory.'''
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap,)
        return cls._make_instance_(pointer)


    @classmethod
    def wrap(cls, name: "typing.Optional[str]"):
        '''Indicate you want to wrap the file or directory in a colletion, with an optional name'''
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap,
        _UniffiConverterOptionalString.lower(name))
        return cls._make_instance_(pointer)



class _UniffiConverterTypeWrapOption:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, WrapOption):
            raise TypeError("Expected WrapOption instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return WrapOption._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AddProgressAbort:
    '''An AddProgress event indicating we got an error and need to abort'''

    error: "str";

    @typing.no_type_check
    def __init__(self, error: "str"):
        self.error = error
        '''The error message'''

    def __str__(self):
        return "AddProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeAddProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class AddProgressAllDone:
    '''An AddProgress event indicating we are done with the the whole operation'''

    hash: "Hash";format: "BlobFormat";tag: "bytes";

    @typing.no_type_check
    def __init__(self, hash: "Hash", format: "BlobFormat", tag: "bytes"):
        self.hash = hash
        '''The hash of the created data.'''
        self.format = format
        '''The format of the added data.'''
        self.tag = tag
        '''The tag of the added data.'''

    def __str__(self):
        return "AddProgressAllDone(hash={}, format={}, tag={})".format(self.hash, self.format, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.format != other.format:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeAddProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressAllDone(
            hash=_UniffiConverterTypeHash.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class AddProgressDone:
    '''An AddProgress event indicated we are done with `id` and now have a hash `hash`'''

    id: "int";hash: "Hash";

    @typing.no_type_check
    def __init__(self, id: "int", hash: "Hash"):
        self.id = id
        '''The unique id of the entry.'''
        self.hash = hash
        '''The hash of the entry.'''

    def __str__(self):
        return "AddProgressDone(id={}, hash={})".format(self.id, self.hash)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeAddProgressDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressDone(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class AddProgressFound:
    '''An AddProgress event indicating an item was found with name `name`, that can be referred to by `id`'''

    id: "int";name: "str";size: "int";

    @typing.no_type_check
    def __init__(self, id: "int", name: "str", size: "int"):
        self.id = id
        '''A new unique id for this entry.'''
        self.name = name
        '''The name of the entry.'''
        self.size = size
        '''The size of the entry in bytes.'''

    def __str__(self):
        return "AddProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeAddProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterString.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class AddProgressProgress:
    '''An AddProgress event indicating we got progress ingesting item `id`.'''

    id: "int";offset: "int";

    @typing.no_type_check
    def __init__(self, id: "int", offset: "int"):
        self.id = id
        '''The unique id of the entry.'''
        self.offset = offset
        '''The offset of the progress, in bytes.'''

    def __str__(self):
        return "AddProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeAddProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class BlobAddOutcome:
    '''Outcome of a blob add operation.'''

    hash: "Hash";format: "BlobFormat";size: "int";tag: "bytes";

    @typing.no_type_check
    def __init__(self, hash: "Hash", format: "BlobFormat", size: "int", tag: "bytes"):
        self.hash = hash
        '''The hash of the blob'''
        self.format = format
        '''The format the blob'''
        self.size = size
        '''The size of the blob'''
        self.tag = tag
        '''The tag of the blob'''

    def __str__(self):
        return "BlobAddOutcome(hash={}, format={}, size={}, tag={})".format(self.hash, self.format, self.size, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.format != other.format:
            return False
        if self.size != other.size:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeBlobAddOutcome(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobAddOutcome(
            hash=_UniffiConverterTypeHash.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class BlobListCollectionsResponse:
    '''A response to a list collections request'''

    tag: "bytes";hash: "Hash";total_blobs_count: "typing.Optional[int]";total_blobs_size: "typing.Optional[int]";

    @typing.no_type_check
    def __init__(self, tag: "bytes", hash: "Hash", total_blobs_count: "typing.Optional[int]", total_blobs_size: "typing.Optional[int]"):
        self.tag = tag
        '''Tag of the collection'''
        self.hash = hash
        '''Hash of the collection'''
        self.total_blobs_count = total_blobs_count
        '''
        Number of children in the collection

        This is an optional field, because the data is not always available.
        '''
        self.total_blobs_size = total_blobs_size
        '''
        Total size of the raw data referred to by all links

        This is an optional field, because the data is not always available.
        '''

    def __str__(self):
        return "BlobListCollectionsResponse(tag={}, hash={}, total_blobs_count={}, total_blobs_size={})".format(self.tag, self.hash, self.total_blobs_count, self.total_blobs_size)

    def __eq__(self, other):
        if self.tag != other.tag:
            return False
        if self.hash != other.hash:
            return False
        if self.total_blobs_count != other.total_blobs_count:
            return False
        if self.total_blobs_size != other.total_blobs_size:
            return False
        return True

class _UniffiConverterTypeBlobListCollectionsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobListCollectionsResponse(
            tag=_UniffiConverterBytes.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            total_blobs_count=_UniffiConverterOptionalUInt64.read(buf),
            total_blobs_size=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.tag, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterOptionalUInt64.write(value.total_blobs_count, buf)
        _UniffiConverterOptionalUInt64.write(value.total_blobs_size, buf)


class BlobListIncompleteResponse:
    '''A response to a list blobs request'''

    size: "int";expected_size: "int";hash: "Hash";

    @typing.no_type_check
    def __init__(self, size: "int", expected_size: "int", hash: "Hash"):
        self.size = size
        '''The size we got'''
        self.expected_size = expected_size
        '''The size we expect'''
        self.hash = hash
        '''The hash of the blob'''

    def __str__(self):
        return "BlobListIncompleteResponse(size={}, expected_size={}, hash={})".format(self.size, self.expected_size, self.hash)

    def __eq__(self, other):
        if self.size != other.size:
            return False
        if self.expected_size != other.expected_size:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeBlobListIncompleteResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobListIncompleteResponse(
            size=_UniffiConverterUInt64.read(buf),
            expected_size=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterUInt64.write(value.expected_size, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class BlobListResponse:
    '''A response to a list blobs request'''

    path: "str";hash: "Hash";size: "int";

    @typing.no_type_check
    def __init__(self, path: "str", hash: "Hash", size: "int"):
        self.path = path
        '''Location of the blob'''
        self.hash = hash
        '''The hash of the blob'''
        self.size = size
        '''The size of the blob'''

    def __str__(self):
        return "BlobListResponse(path={}, hash={}, size={})".format(self.path, self.hash, self.size)

    def __eq__(self, other):
        if self.path != other.path:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeBlobListResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobListResponse(
            path=_UniffiConverterString.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.path, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class ConnectionInfo:
    '''Information about a connection'''

    node_id: "PublicKey";relay_url: "typing.Optional[str]";addrs: "typing.List[DirectAddrInfo]";conn_type: "ConnectionType";latency: "typing.Optional[Duration]";last_used: "typing.Optional[Duration]";

    @typing.no_type_check
    def __init__(self, node_id: "PublicKey", relay_url: "typing.Optional[str]", addrs: "typing.List[DirectAddrInfo]", conn_type: "ConnectionType", latency: "typing.Optional[Duration]", last_used: "typing.Optional[Duration]"):
        self.node_id = node_id
        '''The node identifier of the endpoint. Also a public key.'''
        self.relay_url = relay_url
        '''Relay url, if available.'''
        self.addrs = addrs
        '''
        List of addresses at which this node might be reachable, plus any latency information we
        have about that address and the last time the address was used.
        '''
        self.conn_type = conn_type
        '''The type of connection we have to the peer, either direct or over relay.'''
        self.latency = latency
        '''The latency of the `conn_type`.'''
        self.last_used = last_used
        '''Duration since the last time this peer was used.'''

    def __str__(self):
        return "ConnectionInfo(node_id={}, relay_url={}, addrs={}, conn_type={}, latency={}, last_used={})".format(self.node_id, self.relay_url, self.addrs, self.conn_type, self.latency, self.last_used)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.addrs != other.addrs:
            return False
        if self.conn_type != other.conn_type:
            return False
        if self.latency != other.latency:
            return False
        if self.last_used != other.last_used:
            return False
        return True

class _UniffiConverterTypeConnectionInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectionInfo(
            node_id=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalString.read(buf),
            addrs=_UniffiConverterSequenceTypeDirectAddrInfo.read(buf),
            conn_type=_UniffiConverterTypeConnectionType.read(buf),
            latency=_UniffiConverterOptionalDuration.read(buf),
            last_used=_UniffiConverterOptionalDuration.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.node_id, buf)
        _UniffiConverterOptionalString.write(value.relay_url, buf)
        _UniffiConverterSequenceTypeDirectAddrInfo.write(value.addrs, buf)
        _UniffiConverterTypeConnectionType.write(value.conn_type, buf)
        _UniffiConverterOptionalDuration.write(value.latency, buf)
        _UniffiConverterOptionalDuration.write(value.last_used, buf)


class ConnectionTypeMixed:
    '''The socket address and url id of the mixed connection'''

    addr: "str";relay_url: "str";

    @typing.no_type_check
    def __init__(self, addr: "str", relay_url: "str"):
        self.addr = addr
        '''Address of the node'''
        self.relay_url = relay_url
        '''Url of the relay node to which the node is connected'''

    def __str__(self):
        return "ConnectionTypeMixed(addr={}, relay_url={})".format(self.addr, self.relay_url)

    def __eq__(self, other):
        if self.addr != other.addr:
            return False
        if self.relay_url != other.relay_url:
            return False
        return True

class _UniffiConverterTypeConnectionTypeMixed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectionTypeMixed(
            addr=_UniffiConverterString.read(buf),
            relay_url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.addr, buf)
        _UniffiConverterString.write(value.relay_url, buf)


class CounterStats:
    '''Stats counter'''

    value: "int";description: "str";

    @typing.no_type_check
    def __init__(self, value: "int", description: "str"):
        self.value = value
        '''The counter value'''
        self.description = description
        '''The counter description'''

    def __str__(self):
        return "CounterStats(value={}, description={})".format(self.value, self.description)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeCounterStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CounterStats(
            value=_UniffiConverterUInt32.read(buf),
            description=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)
        _UniffiConverterString.write(value.description, buf)


class DocExportProgressAbort:
    '''A DocExportProgress event indicating we got an error and need to abort'''

    error: "str";

    @typing.no_type_check
    def __init__(self, error: "str"):
        self.error = error
        '''The error message'''

    def __str__(self):
        return "DocExportProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDocExportProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DocExportProgressFound:
    '''A DocExportProgress event indicating a file was found with name `name`, from now on referred to via `id`'''

    id: "int";hash: "Hash";size: "int";outpath: "str";

    @typing.no_type_check
    def __init__(self, id: "int", hash: "Hash", size: "int", outpath: "str"):
        self.id = id
        '''A new unique id for this entry.'''
        self.hash = hash
        '''The hash of the entry.'''
        self.size = size
        '''The size of the entry in bytes.'''
        self.outpath = outpath
        '''The path where we are writing the entry'''

    def __str__(self):
        return "DocExportProgressFound(id={}, hash={}, size={}, outpath={})".format(self.id, self.hash, self.size, self.outpath)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        if self.outpath != other.outpath:
            return False
        return True

class _UniffiConverterTypeDocExportProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            outpath=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterString.write(value.outpath, buf)


class DocExportProgressProgress:
    '''A DocExportProgress event indicating we've made progress exporting item `id`.'''

    id: "int";offset: "int";

    @typing.no_type_check
    def __init__(self, id: "int", offset: "int"):
        self.id = id
        '''The unique id of the entry.'''
        self.offset = offset
        '''The offset of the progress, in bytes.'''

    def __str__(self):
        return "DocExportProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDocExportProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class DocImportProgressAbort:
    '''A DocImportProgress event indicating we got an error and need to abort'''

    error: "str";

    @typing.no_type_check
    def __init__(self, error: "str"):
        self.error = error
        '''The error message'''

    def __str__(self):
        return "DocImportProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDocImportProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DocImportProgressAllDone:
    '''A DocImportProgress event indicating we are done setting the entry to the doc'''

    key: "bytes";

    @typing.no_type_check
    def __init__(self, key: "bytes"):
        self.key = key
        '''The key of the entry'''

    def __str__(self):
        return "DocImportProgressAllDone(key={})".format(self.key)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeDocImportProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressAllDone(
            key=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.key, buf)


class DocImportProgressFound:
    '''A DocImportProgress event indicating a file was found with name `name`, from now on referred to via `id`'''

    id: "int";name: "str";size: "int";

    @typing.no_type_check
    def __init__(self, id: "int", name: "str", size: "int"):
        self.id = id
        '''A new unique id for this entry.'''
        self.name = name
        '''The name of the entry.'''
        self.size = size
        '''The size of the entry in bytes.'''

    def __str__(self):
        return "DocImportProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeDocImportProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterString.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class DocImportProgressIngestDone:
    '''A DocImportProgress event indicating we are finished adding `id` to the data store and the hash is `hash`.'''

    id: "int";hash: "Hash";

    @typing.no_type_check
    def __init__(self, id: "int", hash: "Hash"):
        self.id = id
        '''The unique id of the entry.'''
        self.hash = hash
        '''The hash of the entry.'''

    def __str__(self):
        return "DocImportProgressIngestDone(id={}, hash={})".format(self.id, self.hash)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeDocImportProgressIngestDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressIngestDone(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class DocImportProgressProgress:
    '''A DocImportProgress event indicating we've made progress ingesting item `id`.'''

    id: "int";offset: "int";

    @typing.no_type_check
    def __init__(self, id: "int", offset: "int"):
        self.id = id
        '''The unique id of the entry.'''
        self.offset = offset
        '''The offset of the progress, in bytes.'''

    def __str__(self):
        return "DocImportProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDocImportProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class DownloadProgressAbort:
    '''A DownloadProgress event indicating we got an error and need to abort'''

    error: "str";

    @typing.no_type_check
    def __init__(self, error: "str"):
        self.error = error
        '''The error message'''

    def __str__(self):
        return "DownloadProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDownloadProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DownloadProgressAllDone:
    '''A DownloadProgress event indicating we are done with the whole operation'''

    bytes_written: "int";bytes_read: "int";elapsed: "Duration";

    @typing.no_type_check
    def __init__(self, bytes_written: "int", bytes_read: "int", elapsed: "Duration"):
        self.bytes_written = bytes_written
        '''The number of bytes written'''
        self.bytes_read = bytes_read
        '''The number of bytes read'''
        self.elapsed = elapsed
        '''The time it took to transfer the data'''

    def __str__(self):
        return "DownloadProgressAllDone(bytes_written={}, bytes_read={}, elapsed={})".format(self.bytes_written, self.bytes_read, self.elapsed)

    def __eq__(self, other):
        if self.bytes_written != other.bytes_written:
            return False
        if self.bytes_read != other.bytes_read:
            return False
        if self.elapsed != other.elapsed:
            return False
        return True

class _UniffiConverterTypeDownloadProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressAllDone(
            bytes_written=_UniffiConverterUInt64.read(buf),
            bytes_read=_UniffiConverterUInt64.read(buf),
            elapsed=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.bytes_written, buf)
        _UniffiConverterUInt64.write(value.bytes_read, buf)
        _UniffiConverterDuration.write(value.elapsed, buf)


class DownloadProgressDone:
    '''A DownloadProgress event indicated we are done with `id`'''

    id: "int";

    @typing.no_type_check
    def __init__(self, id: "int"):
        self.id = id
        '''The unique id of the entry.'''

    def __str__(self):
        return "DownloadProgressDone(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class _UniffiConverterTypeDownloadProgressDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressDone(
            id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)


class DownloadProgressFound:
    '''A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`'''

    id: "int";child: "int";hash: "Hash";size: "int";

    @typing.no_type_check
    def __init__(self, id: "int", child: "int", hash: "Hash", size: "int"):
        self.id = id
        '''A new unique id for this entry.'''
        self.child = child
        '''child offset'''
        self.hash = hash
        '''The hash of the entry.'''
        self.size = size
        '''The size of the entry in bytes.'''

    def __str__(self):
        return "DownloadProgressFound(id={}, child={}, hash={}, size={})".format(self.id, self.child, self.hash, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.child != other.child:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            child=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.child, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class DownloadProgressFoundHashSeq:
    '''A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`'''

    children: "int";hash: "Hash";

    @typing.no_type_check
    def __init__(self, children: "int", hash: "Hash"):
        self.children = children
        '''Number of children in the collection, if known.'''
        self.hash = hash
        '''The hash of the entry.'''

    def __str__(self):
        return "DownloadProgressFoundHashSeq(children={}, hash={})".format(self.children, self.hash)

    def __eq__(self, other):
        if self.children != other.children:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFoundHashSeq(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFoundHashSeq(
            children=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.children, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class DownloadProgressFoundLocal:
    '''A DownloadProgress event indicating an entry was found locally'''

    child: "int";hash: "Hash";size: "int";valid_ranges: "RangeSpec";

    @typing.no_type_check
    def __init__(self, child: "int", hash: "Hash", size: "int", valid_ranges: "RangeSpec"):
        self.child = child
        '''child offset'''
        self.hash = hash
        '''The hash of the entry.'''
        self.size = size
        '''The size of the entry in bytes.'''
        self.valid_ranges = valid_ranges
        '''The ranges that are available locally.'''

    def __str__(self):
        return "DownloadProgressFoundLocal(child={}, hash={}, size={}, valid_ranges={})".format(self.child, self.hash, self.size, self.valid_ranges)

    def __eq__(self, other):
        if self.child != other.child:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        if self.valid_ranges != other.valid_ranges:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFoundLocal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFoundLocal(
            child=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            valid_ranges=_UniffiConverterTypeRangeSpec.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.child, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterTypeRangeSpec.write(value.valid_ranges, buf)


class DownloadProgressProgress:
    '''A DownloadProgress event indicating we got progress ingesting item `id`.'''

    id: "int";offset: "int";

    @typing.no_type_check
    def __init__(self, id: "int", offset: "int"):
        self.id = id
        '''The unique id of the entry.'''
        self.offset = offset
        '''The offset of the progress, in bytes.'''

    def __str__(self):
        return "DownloadProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDownloadProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class HashAndTag:
    '''The Hash and associated tag of a newly created collection'''

    hash: "Hash";tag: "bytes";

    @typing.no_type_check
    def __init__(self, hash: "Hash", tag: "bytes"):
        self.hash = hash
        '''The hash of the collection'''
        self.tag = tag
        '''The tag of the collection'''

    def __str__(self):
        return "HashAndTag(hash={}, tag={})".format(self.hash, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeHashAndTag(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HashAndTag(
            hash=_UniffiConverterTypeHash.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class InsertRemoteEvent:
    '''Outcome of an InsertRemove event.'''

    _from: "PublicKey";entry: "Entry";content_status: "ContentStatus";

    @typing.no_type_check
    def __init__(self, _from: "PublicKey", entry: "Entry", content_status: "ContentStatus"):
        self._from = _from
        '''The peer that sent us the entry.'''
        self.entry = entry
        '''The inserted entry.'''
        self.content_status = content_status
        '''If the content is available at the local node'''

    def __str__(self):
        return "InsertRemoteEvent(_from={}, entry={}, content_status={})".format(self._from, self.entry, self.content_status)

    def __eq__(self, other):
        if self._from != other._from:
            return False
        if self.entry != other.entry:
            return False
        if self.content_status != other.content_status:
            return False
        return True

class _UniffiConverterTypeInsertRemoteEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InsertRemoteEvent(
            _from=_UniffiConverterTypePublicKey.read(buf),
            entry=_UniffiConverterTypeEntry.read(buf),
            content_status=_UniffiConverterTypeContentStatus.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value._from, buf)
        _UniffiConverterTypeEntry.write(value.entry, buf)
        _UniffiConverterTypeContentStatus.write(value.content_status, buf)


class LatencyAndControlMsg:
    '''The latency and type of the control message'''

    latency: "Duration";control_msg: "str";

    @typing.no_type_check
    def __init__(self, latency: "Duration", control_msg: "str"):
        self.latency = latency
        '''The latency of the control message'''
        self.control_msg = control_msg
        '''The type of control message, represented as a string'''

    def __str__(self):
        return "LatencyAndControlMsg(latency={}, control_msg={})".format(self.latency, self.control_msg)

    def __eq__(self, other):
        if self.latency != other.latency:
            return False
        if self.control_msg != other.control_msg:
            return False
        return True

class _UniffiConverterTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LatencyAndControlMsg(
            latency=_UniffiConverterDuration.read(buf),
            control_msg=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.latency, buf)
        _UniffiConverterString.write(value.control_msg, buf)


class LinkAndName:
    '''A `Link` includes a name and a hash for a blob in a collection'''

    name: "str";link: "Hash";

    @typing.no_type_check
    def __init__(self, name: "str", link: "Hash"):
        self.name = name
        '''The name associated with this [`Hash`]'''
        self.link = link
        '''The [`Hash`] of the blob'''

    def __str__(self):
        return "LinkAndName(name={}, link={})".format(self.name, self.link)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.link != other.link:
            return False
        return True

class _UniffiConverterTypeLinkAndName(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LinkAndName(
            name=_UniffiConverterString.read(buf),
            link=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterTypeHash.write(value.link, buf)


class ListTagsResponse:
    '''A response to a list collections request'''

    name: "bytes";format: "BlobFormat";hash: "Hash";

    @typing.no_type_check
    def __init__(self, name: "bytes", format: "BlobFormat", hash: "Hash"):
        self.name = name
        '''The tag'''
        self.format = format
        '''The format of the associated blob'''
        self.hash = hash
        '''The hash of the associated blob'''

    def __str__(self):
        return "ListTagsResponse(name={}, format={}, hash={})".format(self.name, self.format, self.hash)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.format != other.format:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeListTagsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListTagsResponse(
            name=_UniffiConverterBytes.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.name, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class NamespaceAndCapability:
    '''The namespace id and CapabilityKind (read/write) of the doc'''

    namespace: "str";capability: "CapabilityKind";

    @typing.no_type_check
    def __init__(self, namespace: "str", capability: "CapabilityKind"):
        self.namespace = namespace
        '''The namespace id of the doc'''
        self.capability = capability
        '''The capability you have for the doc (read/write)'''

    def __str__(self):
        return "NamespaceAndCapability(namespace={}, capability={})".format(self.namespace, self.capability)

    def __eq__(self, other):
        if self.namespace != other.namespace:
            return False
        if self.capability != other.capability:
            return False
        return True

class _UniffiConverterTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NamespaceAndCapability(
            namespace=_UniffiConverterString.read(buf),
            capability=_UniffiConverterTypeCapabilityKind.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.namespace, buf)
        _UniffiConverterTypeCapabilityKind.write(value.capability, buf)


class NodeOptions:
    '''Options passed to [`IrohNode.new`]. Controls the behaviour of an iroh node.'''

    gc_interval_millis: "typing.Optional[int]";

    @typing.no_type_check
    def __init__(self, gc_interval_millis: "typing.Optional[int]"):
        self.gc_interval_millis = gc_interval_millis
        '''
        How frequently the blob store should clean up unreferenced blobs, in milliseconds.
        Set to 0 to disable gc
        '''

    def __str__(self):
        return "NodeOptions(gc_interval_millis={})".format(self.gc_interval_millis)

    def __eq__(self, other):
        if self.gc_interval_millis != other.gc_interval_millis:
            return False
        return True

class _UniffiConverterTypeNodeOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeOptions(
            gc_interval_millis=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.gc_interval_millis, buf)


class OpenState:
    '''The state for an open replica.'''

    sync: "bool";subscribers: "int";handles: "int";

    @typing.no_type_check
    def __init__(self, sync: "bool", subscribers: "int", handles: "int"):
        self.sync = sync
        '''Whether to accept sync requests for this replica.'''
        self.subscribers = subscribers
        '''How many event subscriptions are open'''
        self.handles = handles
        '''By how many handles the replica is currently held open'''

    def __str__(self):
        return "OpenState(sync={}, subscribers={}, handles={})".format(self.sync, self.subscribers, self.handles)

    def __eq__(self, other):
        if self.sync != other.sync:
            return False
        if self.subscribers != other.subscribers:
            return False
        if self.handles != other.handles:
            return False
        return True

class _UniffiConverterTypeOpenState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenState(
            sync=_UniffiConverterBool.read(buf),
            subscribers=_UniffiConverterUInt64.read(buf),
            handles=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.sync, buf)
        _UniffiConverterUInt64.write(value.subscribers, buf)
        _UniffiConverterUInt64.write(value.handles, buf)


class QueryOptions:
    '''Options for sorting and pagination for using [`Query`]s.'''

    sort_by: "SortBy";direction: "SortDirection";offset: "int";limit: "int";

    @typing.no_type_check
    def __init__(self, sort_by: "SortBy", direction: "SortDirection", offset: "int", limit: "int"):
        self.sort_by = sort_by
        '''
        Sort by author or key first.

        Default is [`SortBy::AuthorKey`], so sorting first by author and then by key.
        '''
        self.direction = direction
        '''
        Direction by which to sort the entries

        Default is [`SortDirection::Asc`]
        '''
        self.offset = offset
        '''Offset'''
        self.limit = limit
        '''
        Limit to limit the pagination.

        When the limit is 0, the limit does not exist.
        '''

    def __str__(self):
        return "QueryOptions(sort_by={}, direction={}, offset={}, limit={})".format(self.sort_by, self.direction, self.offset, self.limit)

    def __eq__(self, other):
        if self.sort_by != other.sort_by:
            return False
        if self.direction != other.direction:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class _UniffiConverterTypeQueryOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return QueryOptions(
            sort_by=_UniffiConverterTypeSortBy.read(buf),
            direction=_UniffiConverterTypeSortDirection.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
            limit=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSortBy.write(value.sort_by, buf)
        _UniffiConverterTypeSortDirection.write(value.direction, buf)
        _UniffiConverterUInt64.write(value.offset, buf)
        _UniffiConverterUInt64.write(value.limit, buf)


class SyncEvent:
    '''Outcome of a sync operation'''

    peer: "PublicKey";origin: "Origin";started: "Timestamp";finished: "Timestamp";result: "typing.Optional[str]";

    @typing.no_type_check
    def __init__(self, peer: "PublicKey", origin: "Origin", started: "Timestamp", finished: "Timestamp", result: "typing.Optional[str]"):
        self.peer = peer
        '''Peer we synced with'''
        self.origin = origin
        '''Origin of the sync exchange'''
        self.started = started
        '''Timestamp when the sync finished'''
        self.finished = finished
        '''Timestamp when the sync started'''
        self.result = result
        '''Result of the sync operation. `None` if successfull.'''

    def __str__(self):
        return "SyncEvent(peer={}, origin={}, started={}, finished={}, result={})".format(self.peer, self.origin, self.started, self.finished, self.result)

    def __eq__(self, other):
        if self.peer != other.peer:
            return False
        if self.origin != other.origin:
            return False
        if self.started != other.started:
            return False
        if self.finished != other.finished:
            return False
        if self.result != other.result:
            return False
        return True

class _UniffiConverterTypeSyncEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SyncEvent(
            peer=_UniffiConverterTypePublicKey.read(buf),
            origin=_UniffiConverterTypeOrigin.read(buf),
            started=_UniffiConverterTimestamp.read(buf),
            finished=_UniffiConverterTimestamp.read(buf),
            result=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.peer, buf)
        _UniffiConverterTypeOrigin.write(value.origin, buf)
        _UniffiConverterTimestamp.write(value.started, buf)
        _UniffiConverterTimestamp.write(value.finished, buf)
        _UniffiConverterOptionalString.write(value.result, buf)





class AddProgressType(enum.Enum):
    '''The different types of AddProgress events'''
    FOUND = 1
    '''An item was found with name `name`, from now on referred to via `id`'''
    PROGRESS = 2
    '''We got progress ingesting item `id`.'''
    DONE = 3
    '''We are done with `id`, and the hash is `hash`.'''
    ALL_DONE = 4
    '''We are done with the whole operation.'''
    ABORT = 5
    '''
    We got an error and need to abort.

    This will be the last message in the stream.
    '''
    


class _UniffiConverterTypeAddProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddProgressType.FOUND
        if variant == 2:
            return AddProgressType.PROGRESS
        if variant == 3:
            return AddProgressType.DONE
        if variant == 4:
            return AddProgressType.ALL_DONE
        if variant == 5:
            return AddProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AddProgressType.FOUND:
            buf.write_i32(1)
        if value == AddProgressType.PROGRESS:
            buf.write_i32(2)
        if value == AddProgressType.DONE:
            buf.write_i32(3)
        if value == AddProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == AddProgressType.ABORT:
            buf.write_i32(5)







class AddrInfoOptions(enum.Enum):
    '''Options when creating a ticket'''
    ID = 1
    '''
    Only the Node ID is added.

    This usually means that iroh-dns discovery is used to find address information.
    '''
    RELAY_AND_ADDRESSES = 2
    '''Include both the relay URL and the direct addresses.'''
    RELAY = 3
    '''Only include the relay URL.'''
    ADDRESSES = 4
    '''Only include the direct addresses.'''
    


class _UniffiConverterTypeAddrInfoOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddrInfoOptions.ID
        if variant == 2:
            return AddrInfoOptions.RELAY_AND_ADDRESSES
        if variant == 3:
            return AddrInfoOptions.RELAY
        if variant == 4:
            return AddrInfoOptions.ADDRESSES
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AddrInfoOptions.ID:
            buf.write_i32(1)
        if value == AddrInfoOptions.RELAY_AND_ADDRESSES:
            buf.write_i32(2)
        if value == AddrInfoOptions.RELAY:
            buf.write_i32(3)
        if value == AddrInfoOptions.ADDRESSES:
            buf.write_i32(4)







class BlobExportFormat(enum.Enum):
    '''The expected format of a hash being exported.'''
    BLOB = 1
    '''The hash refers to any blob and will be exported to a single file.'''
    COLLECTION = 2
    '''
    The hash refers to a [`crate::format::collection::Collection`] blob
    and all children of the collection shall be exported to one file per child.

    If the blob can be parsed as a [`BlobFormat::HashSeq`], and the first child contains
    collection metadata, all other children of the collection will be exported to
    a file each, with their collection name treated as a relative path to the export
    destination path.

    If the blob cannot be parsed as a collection, the operation will fail.
    '''
    


class _UniffiConverterTypeBlobExportFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobExportFormat.BLOB
        if variant == 2:
            return BlobExportFormat.COLLECTION
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BlobExportFormat.BLOB:
            buf.write_i32(1)
        if value == BlobExportFormat.COLLECTION:
            buf.write_i32(2)







class BlobExportMode(enum.Enum):
    '''
    The export mode describes how files will be exported.

    This is a hint to the import trait method. For some implementations, this
    does not make any sense. E.g. an in memory implementation will always have
    to copy the file into memory. Also, a disk based implementation might choose
    to copy small files even if the mode is `Reference`.
    '''
    COPY = 1
    '''
    This mode will copy the file to the target directory.

    This is the safe default because the file can not be accidentally modified
    after it has been exported.
    '''
    TRY_REFERENCE = 2
    '''
    This mode will try to move the file to the target directory and then reference it from
    the database.

    This has a large performance and storage benefit, but it is less safe since
    the file might be modified in the target directory after it has been exported.

    Stores are allowed to ignore this mode and always copy the file, e.g.
    if the file is very small or if the store does not support referencing files.
    '''
    


class _UniffiConverterTypeBlobExportMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobExportMode.COPY
        if variant == 2:
            return BlobExportMode.TRY_REFERENCE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BlobExportMode.COPY:
            buf.write_i32(1)
        if value == BlobExportMode.TRY_REFERENCE:
            buf.write_i32(2)







class BlobFormat(enum.Enum):
    '''A format identifier'''
    RAW = 1
    '''Raw blob'''
    HASH_SEQ = 2
    '''A sequence of BLAKE3 hashes'''
    


class _UniffiConverterTypeBlobFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobFormat.RAW
        if variant == 2:
            return BlobFormat.HASH_SEQ
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BlobFormat.RAW:
            buf.write_i32(1)
        if value == BlobFormat.HASH_SEQ:
            buf.write_i32(2)







class CapabilityKind(enum.Enum):
    '''Kind of capability of the doc.'''
    WRITE = 1
    '''A writable doc'''
    READ = 2
    '''A readable doc'''
    


class _UniffiConverterTypeCapabilityKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CapabilityKind.WRITE
        if variant == 2:
            return CapabilityKind.READ
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == CapabilityKind.WRITE:
            buf.write_i32(1)
        if value == CapabilityKind.READ:
            buf.write_i32(2)







class ConnType(enum.Enum):
    '''The type of the connection'''
    DIRECT = 1
    '''Indicates you have a UDP connection.'''
    RELAY = 2
    '''Indicates you have a relayed connection.'''
    MIXED = 3
    '''Indicates you have an unverified UDP connection, and a relay connection for backup.'''
    NONE = 4
    '''Indicates you have no proof of connection.'''
    


class _UniffiConverterTypeConnType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnType.DIRECT
        if variant == 2:
            return ConnType.RELAY
        if variant == 3:
            return ConnType.MIXED
        if variant == 4:
            return ConnType.NONE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ConnType.DIRECT:
            buf.write_i32(1)
        if value == ConnType.RELAY:
            buf.write_i32(2)
        if value == ConnType.MIXED:
            buf.write_i32(3)
        if value == ConnType.NONE:
            buf.write_i32(4)







class ContentStatus(enum.Enum):
    '''Whether the content status is available on a node.'''
    COMPLETE = 1
    '''The content is completely available.'''
    INCOMPLETE = 2
    '''The content is partially available.'''
    MISSING = 3
    '''The content is missing.'''
    


class _UniffiConverterTypeContentStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ContentStatus.COMPLETE
        if variant == 2:
            return ContentStatus.INCOMPLETE
        if variant == 3:
            return ContentStatus.MISSING
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ContentStatus.COMPLETE:
            buf.write_i32(1)
        if value == ContentStatus.INCOMPLETE:
            buf.write_i32(2)
        if value == ContentStatus.MISSING:
            buf.write_i32(3)







class DocExportProgressType(enum.Enum):
    '''The type of `DocExportProgress` event'''
    FOUND = 1
    '''An item was found with name `name`, from now on referred to via `id`'''
    PROGRESS = 2
    '''We got progress exporting item `id`.'''
    DONE = 3
    '''We are finished writing item `id`.'''
    ALL_DONE = 4
    '''We are done writing the entry to the filesystem'''
    ABORT = 5
    '''
    We got an error and need to abort.

    This will be the last message in the stream.
    '''
    


class _UniffiConverterTypeDocExportProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DocExportProgressType.FOUND
        if variant == 2:
            return DocExportProgressType.PROGRESS
        if variant == 3:
            return DocExportProgressType.DONE
        if variant == 4:
            return DocExportProgressType.ALL_DONE
        if variant == 5:
            return DocExportProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == DocExportProgressType.FOUND:
            buf.write_i32(1)
        if value == DocExportProgressType.PROGRESS:
            buf.write_i32(2)
        if value == DocExportProgressType.DONE:
            buf.write_i32(3)
        if value == DocExportProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == DocExportProgressType.ABORT:
            buf.write_i32(5)







class DocImportProgressType(enum.Enum):
    '''The type of `DocImportProgress` event'''
    FOUND = 1
    '''An item was found with name `name`, from now on referred to via `id`'''
    PROGRESS = 2
    '''We got progress ingesting item `id`.'''
    INGEST_DONE = 3
    '''We are done ingesting `id`, and the hash is `hash`.'''
    ALL_DONE = 4
    '''We are done with the whole operation.'''
    ABORT = 5
    '''
    We got an error and need to abort.

    This will be the last message in the stream.
    '''
    


class _UniffiConverterTypeDocImportProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DocImportProgressType.FOUND
        if variant == 2:
            return DocImportProgressType.PROGRESS
        if variant == 3:
            return DocImportProgressType.INGEST_DONE
        if variant == 4:
            return DocImportProgressType.ALL_DONE
        if variant == 5:
            return DocImportProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == DocImportProgressType.FOUND:
            buf.write_i32(1)
        if value == DocImportProgressType.PROGRESS:
            buf.write_i32(2)
        if value == DocImportProgressType.INGEST_DONE:
            buf.write_i32(3)
        if value == DocImportProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == DocImportProgressType.ABORT:
            buf.write_i32(5)







class DownloadProgressType(enum.Enum):
    '''The kinds of progress events that can occur in a `DownloadProgress`'''
    INITIAL_STATE = 1
    '''Initial state if subscribing to a running or queued transfer.'''
    FOUND_LOCAL = 2
    '''Data was found locally'''
    CONNECTED = 3
    '''A new connection was established.'''
    FOUND = 4
    '''An item was found with hash `hash`, from now on referred to via `id`'''
    FOUND_HASH_SEQ = 5
    '''An item was found with hash `hash`, from now on referred to via `id`'''
    PROGRESS = 6
    '''We got progress ingesting item `id`.'''
    DONE = 7
    '''We are done with `id`, and the hash is `hash`.'''
    ALL_DONE = 8
    '''We are done with the whole operation.'''
    ABORT = 9
    '''
    We got an error and need to abort.

    This will be the last message in the stream.
    '''
    


class _UniffiConverterTypeDownloadProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DownloadProgressType.INITIAL_STATE
        if variant == 2:
            return DownloadProgressType.FOUND_LOCAL
        if variant == 3:
            return DownloadProgressType.CONNECTED
        if variant == 4:
            return DownloadProgressType.FOUND
        if variant == 5:
            return DownloadProgressType.FOUND_HASH_SEQ
        if variant == 6:
            return DownloadProgressType.PROGRESS
        if variant == 7:
            return DownloadProgressType.DONE
        if variant == 8:
            return DownloadProgressType.ALL_DONE
        if variant == 9:
            return DownloadProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == DownloadProgressType.INITIAL_STATE:
            buf.write_i32(1)
        if value == DownloadProgressType.FOUND_LOCAL:
            buf.write_i32(2)
        if value == DownloadProgressType.CONNECTED:
            buf.write_i32(3)
        if value == DownloadProgressType.FOUND:
            buf.write_i32(4)
        if value == DownloadProgressType.FOUND_HASH_SEQ:
            buf.write_i32(5)
        if value == DownloadProgressType.PROGRESS:
            buf.write_i32(6)
        if value == DownloadProgressType.DONE:
            buf.write_i32(7)
        if value == DownloadProgressType.ALL_DONE:
            buf.write_i32(8)
        if value == DownloadProgressType.ABORT:
            buf.write_i32(9)




# IrohError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class IrohError(Exception):
    '''An iroh error. Each IrohError contains a string description.'''
    pass

_UniffiTempIrohError = IrohError

class IrohError:  # type: ignore
    class Runtime(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Runtime({})".format(str(self))
    _UniffiTempIrohError.Runtime = Runtime # type: ignore
    class NodeCreate(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.NodeCreate({})".format(str(self))
    _UniffiTempIrohError.NodeCreate = NodeCreate # type: ignore
    class Doc(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Doc({})".format(str(self))
    _UniffiTempIrohError.Doc = Doc # type: ignore
    class Author(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Author({})".format(str(self))
    _UniffiTempIrohError.Author = Author # type: ignore
    class Namespace(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Namespace({})".format(str(self))
    _UniffiTempIrohError.Namespace = Namespace # type: ignore
    class DocTicket(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.DocTicket({})".format(str(self))
    _UniffiTempIrohError.DocTicket = DocTicket # type: ignore
    class BlobTicket(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.BlobTicket({})".format(str(self))
    _UniffiTempIrohError.BlobTicket = BlobTicket # type: ignore
    class Uniffi(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Uniffi({})".format(str(self))
    _UniffiTempIrohError.Uniffi = Uniffi # type: ignore
    class Connection(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Connection({})".format(str(self))
    _UniffiTempIrohError.Connection = Connection # type: ignore
    class Blobs(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Blobs({})".format(str(self))
    _UniffiTempIrohError.Blobs = Blobs # type: ignore
    class Collection(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Collection({})".format(str(self))
    _UniffiTempIrohError.Collection = Collection # type: ignore
    class Ipv4Addr(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Ipv4Addr({})".format(str(self))
    _UniffiTempIrohError.Ipv4Addr = Ipv4Addr # type: ignore
    class Ipv6Addr(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Ipv6Addr({})".format(str(self))
    _UniffiTempIrohError.Ipv6Addr = Ipv6Addr # type: ignore
    class SocketAddr(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.SocketAddr({})".format(str(self))
    _UniffiTempIrohError.SocketAddr = SocketAddr # type: ignore
    class PublicKey(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.PublicKey({})".format(str(self))
    _UniffiTempIrohError.PublicKey = PublicKey # type: ignore
    class NodeAddr(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.NodeAddr({})".format(str(self))
    _UniffiTempIrohError.NodeAddr = NodeAddr # type: ignore
    class Hash(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Hash({})".format(str(self))
    _UniffiTempIrohError.Hash = Hash # type: ignore
    class FsUtil(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.FsUtil({})".format(str(self))
    _UniffiTempIrohError.FsUtil = FsUtil # type: ignore
    class Tags(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Tags({})".format(str(self))
    _UniffiTempIrohError.Tags = Tags # type: ignore
    class Url(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Url({})".format(str(self))
    _UniffiTempIrohError.Url = Url # type: ignore
    class Entry(_UniffiTempIrohError):

        def __init__(self, description):
            super().__init__(", ".join([
                "description={!r}".format(description),
            ]))
            self.description = description
        def __repr__(self):
            return "IrohError.Entry({})".format(str(self))
    _UniffiTempIrohError.Entry = Entry # type: ignore

IrohError = _UniffiTempIrohError # type: ignore
del _UniffiTempIrohError


class _UniffiConverterTypeIrohError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return IrohError.Runtime(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return IrohError.NodeCreate(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return IrohError.Doc(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return IrohError.Author(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return IrohError.Namespace(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return IrohError.DocTicket(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return IrohError.BlobTicket(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return IrohError.Uniffi(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return IrohError.Connection(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return IrohError.Blobs(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 11:
            return IrohError.Collection(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return IrohError.Ipv4Addr(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 13:
            return IrohError.Ipv6Addr(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 14:
            return IrohError.SocketAddr(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 15:
            return IrohError.PublicKey(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 16:
            return IrohError.NodeAddr(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 17:
            return IrohError.Hash(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 18:
            return IrohError.FsUtil(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 19:
            return IrohError.Tags(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 20:
            return IrohError.Url(
                description=_UniffiConverterString.read(buf),
            )
        if variant == 21:
            return IrohError.Entry(
                description=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, IrohError.Runtime):
            buf.write_i32(1)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.NodeCreate):
            buf.write_i32(2)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Doc):
            buf.write_i32(3)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Author):
            buf.write_i32(4)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Namespace):
            buf.write_i32(5)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.DocTicket):
            buf.write_i32(6)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.BlobTicket):
            buf.write_i32(7)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Uniffi):
            buf.write_i32(8)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Connection):
            buf.write_i32(9)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Blobs):
            buf.write_i32(10)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Collection):
            buf.write_i32(11)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Ipv4Addr):
            buf.write_i32(12)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Ipv6Addr):
            buf.write_i32(13)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.SocketAddr):
            buf.write_i32(14)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.PublicKey):
            buf.write_i32(15)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.NodeAddr):
            buf.write_i32(16)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Hash):
            buf.write_i32(17)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.FsUtil):
            buf.write_i32(18)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Tags):
            buf.write_i32(19)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Url):
            buf.write_i32(20)
            _UniffiConverterString.write(value.description, buf)
        if isinstance(value, IrohError.Entry):
            buf.write_i32(21)
            _UniffiConverterString.write(value.description, buf)





class LiveEventType(enum.Enum):
    '''The type of events that can be emitted during the live sync progress'''
    INSERT_LOCAL = 1
    '''A local insertion.'''
    INSERT_REMOTE = 2
    '''Received a remote insert.'''
    CONTENT_READY = 3
    '''The content of an entry was downloaded and is now available at the local node'''
    NEIGHBOR_UP = 4
    '''We have a new neighbor in the swarm.'''
    NEIGHBOR_DOWN = 5
    '''We lost a neighbor in the swarm.'''
    SYNC_FINISHED = 6
    '''A set-reconciliation sync finished.'''
    


class _UniffiConverterTypeLiveEventType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventType.INSERT_LOCAL
        if variant == 2:
            return LiveEventType.INSERT_REMOTE
        if variant == 3:
            return LiveEventType.CONTENT_READY
        if variant == 4:
            return LiveEventType.NEIGHBOR_UP
        if variant == 5:
            return LiveEventType.NEIGHBOR_DOWN
        if variant == 6:
            return LiveEventType.SYNC_FINISHED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LiveEventType.INSERT_LOCAL:
            buf.write_i32(1)
        if value == LiveEventType.INSERT_REMOTE:
            buf.write_i32(2)
        if value == LiveEventType.CONTENT_READY:
            buf.write_i32(3)
        if value == LiveEventType.NEIGHBOR_UP:
            buf.write_i32(4)
        if value == LiveEventType.NEIGHBOR_DOWN:
            buf.write_i32(5)
        if value == LiveEventType.SYNC_FINISHED:
            buf.write_i32(6)







class LogLevel(enum.Enum):
    '''The logging level. See the rust (log crate)[https://docs.rs/log] for more information.'''
    TRACE = 1
    DEBUG = 2
    INFO = 3
    WARN = 4
    ERROR = 5
    OFF = 6
    


class _UniffiConverterTypeLogLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LogLevel.TRACE
        if variant == 2:
            return LogLevel.DEBUG
        if variant == 3:
            return LogLevel.INFO
        if variant == 4:
            return LogLevel.WARN
        if variant == 5:
            return LogLevel.ERROR
        if variant == 6:
            return LogLevel.OFF
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == LogLevel.TRACE:
            buf.write_i32(1)
        if value == LogLevel.DEBUG:
            buf.write_i32(2)
        if value == LogLevel.INFO:
            buf.write_i32(3)
        if value == LogLevel.WARN:
            buf.write_i32(4)
        if value == LogLevel.ERROR:
            buf.write_i32(5)
        if value == LogLevel.OFF:
            buf.write_i32(6)







class Origin:
    '''Why we performed a sync exchange'''
    def __init__(self):
        raise RuntimeError("Origin cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONNECT:
        '''public, use a unit variant'''

        reason: "SyncReason";

        @typing.no_type_check
        def __init__(self,reason: "SyncReason"):
            
            self.reason = reason
            

        def __str__(self):
            return "Origin.CONNECT(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_connect():
                return False
            if self.reason != other.reason:
                return False
            return True
    class ACCEPT:
        '''A peer connected to us and we accepted the exchange'''

        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Origin.ACCEPT()".format()

        def __eq__(self, other):
            if not other.is_accept():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_connect(self) -> bool:
        return isinstance(self, Origin.CONNECT)
    def is_accept(self) -> bool:
        return isinstance(self, Origin.ACCEPT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Origin.CONNECT = type("Origin.CONNECT", (Origin.CONNECT, Origin,), {})  # type: ignore
Origin.ACCEPT = type("Origin.ACCEPT", (Origin.ACCEPT, Origin,), {})  # type: ignore




class _UniffiConverterTypeOrigin(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Origin.CONNECT(
                _UniffiConverterTypeSyncReason.read(buf),
            )
        if variant == 2:
            return Origin.ACCEPT(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_connect():
            buf.write_i32(1)
            _UniffiConverterTypeSyncReason.write(value.reason, buf)
        if value.is_accept():
            buf.write_i32(2)







class ShareMode(enum.Enum):
    '''Intended capability for document share tickets'''
    READ = 1
    '''Read-only access'''
    WRITE = 2
    '''Write access'''
    


class _UniffiConverterTypeShareMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ShareMode.READ
        if variant == 2:
            return ShareMode.WRITE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ShareMode.READ:
            buf.write_i32(1)
        if value == ShareMode.WRITE:
            buf.write_i32(2)







class SortBy(enum.Enum):
    '''Fields by which the query can be sorted'''
    KEY_AUTHOR = 1
    '''Fields by which the query can be sorted'''
    AUTHOR_KEY = 2
    '''Fields by which the query can be sorted'''
    


class _UniffiConverterTypeSortBy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SortBy.KEY_AUTHOR
        if variant == 2:
            return SortBy.AUTHOR_KEY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SortBy.KEY_AUTHOR:
            buf.write_i32(1)
        if value == SortBy.AUTHOR_KEY:
            buf.write_i32(2)







class SortDirection(enum.Enum):
    '''Sort direction'''
    ASC = 1
    '''Sort ascending'''
    DESC = 2
    '''Sort descending'''
    


class _UniffiConverterTypeSortDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SortDirection.ASC
        if variant == 2:
            return SortDirection.DESC
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SortDirection.ASC:
            buf.write_i32(1)
        if value == SortDirection.DESC:
            buf.write_i32(2)







class SyncReason(enum.Enum):
    '''Why we started a sync request'''
    DIRECT_JOIN = 1
    '''Direct join request via API'''
    NEW_NEIGHBOR = 2
    '''Peer showed up as new neighbor in the gossip swarm'''
    SYNC_REPORT = 3
    '''We synced after receiving a sync report that indicated news for us'''
    RESYNC = 4
    '''We received a sync report while a sync was running, so run again afterwars'''
    


class _UniffiConverterTypeSyncReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SyncReason.DIRECT_JOIN
        if variant == 2:
            return SyncReason.NEW_NEIGHBOR
        if variant == 3:
            return SyncReason.SYNC_REPORT
        if variant == 4:
            return SyncReason.RESYNC
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SyncReason.DIRECT_JOIN:
            buf.write_i32(1)
        if value == SyncReason.NEW_NEIGHBOR:
            buf.write_i32(2)
        if value == SyncReason.SYNC_REPORT:
            buf.write_i32(3)
        if value == SyncReason.RESYNC:
            buf.write_i32(4)





import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Declaration and _UniffiConverters for AddCallback Callback Interface

class AddCallback:
    '''
    The `progress` method will be called for each `AddProgress` event that is
    emitted during a `node.blobs_add_from_path`. Use the `AddProgress.type()`
    method to check the `AddProgressType`
    '''
    def progress(self, progress: "AddProgress"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceAddCallback(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_progress(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.progress(
                _UniffiConverterTypeAddProgress.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return _UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except IrohError as e:
            # Catch errors declared in the UDL file
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeIrohError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_ERROR

    

    cb = _UniffiConverterCallbackInterfaceAddCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceAddCallback.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceAddCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceAddCallback)
_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_addcallback(foreignCallbackCallbackInterfaceAddCallback, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceAddCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceAddCallback)





# Declaration and _UniffiConverters for DocExportFileCallback Callback Interface

class DocExportFileCallback:
    '''
    The `progress` method will be called for each `DocExportProgress` event that is
    emitted during a `doc.export_file()` call. Use the `DocExportProgress.type()`
    method to check the `DocExportProgressType`
    '''
    def progress(self, progress: "DocExportProgress"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceDocExportFileCallback(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_progress(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.progress(
                _UniffiConverterTypeDocExportProgress.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return _UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except IrohError as e:
            # Catch errors declared in the UDL file
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeIrohError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_ERROR

    

    cb = _UniffiConverterCallbackInterfaceDocExportFileCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceDocExportFileCallback.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceDocExportFileCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDocExportFileCallback)
_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback(foreignCallbackCallbackInterfaceDocExportFileCallback, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceDocExportFileCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDocExportFileCallback)





# Declaration and _UniffiConverters for DocImportFileCallback Callback Interface

class DocImportFileCallback:
    '''
    The `progress` method will be called for each `DocImportProgress` event that is
    emitted during a `doc.import_file()` call. Use the `DocImportProgress.type()`
    method to check the `DocImportProgressType`
    '''
    def progress(self, progress: "DocImportProgress"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceDocImportFileCallback(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_progress(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.progress(
                _UniffiConverterTypeDocImportProgress.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return _UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except IrohError as e:
            # Catch errors declared in the UDL file
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeIrohError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_ERROR

    

    cb = _UniffiConverterCallbackInterfaceDocImportFileCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceDocImportFileCallback.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceDocImportFileCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDocImportFileCallback)
_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback(foreignCallbackCallbackInterfaceDocImportFileCallback, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceDocImportFileCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDocImportFileCallback)





# Declaration and _UniffiConverters for DownloadCallback Callback Interface

class DownloadCallback:
    '''
    The `progress` method will be called for each `DownloadProgress` event that is emitted during
    a `node.blobs_download`. Use the `DownloadProgress.type()` method to check the
    `DownloadProgressType` of the event.
    '''
    def progress(self, progress: "DownloadProgress"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceDownloadCallback(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_progress(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.progress(
                _UniffiConverterTypeDownloadProgress.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return _UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except IrohError as e:
            # Catch errors declared in the UDL file
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeIrohError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_ERROR

    

    cb = _UniffiConverterCallbackInterfaceDownloadCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceDownloadCallback.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceDownloadCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDownloadCallback)
_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback(foreignCallbackCallbackInterfaceDownloadCallback, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceDownloadCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDownloadCallback)





# Declaration and _UniffiConverters for SubscribeCallback Callback Interface

class SubscribeCallback:
    '''
    The `progress` method will be called for each `SubscribeProgress` event that is
    emitted during a `node.doc_subscribe`. Use the `SubscribeProgress.type()`
    method to check the `LiveEvent`
    '''
    def event(self, event: "LiveEvent"):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceSubscribeCallback(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_event(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.event(
                _UniffiConverterTypeLiveEvent.read(args_stream)
                )

        def makeCallAndHandleReturn():
            makeCall()
            return _UNIFFI_CALLBACK_SUCCESS
        try:
            return makeCallAndHandleReturn()
        except IrohError as e:
            # Catch errors declared in the UDL file
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeIrohError.write(e, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_ERROR

    

    cb = _UniffiConverterCallbackInterfaceSubscribeCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceSubscribeCallback.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_event(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceSubscribeCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceSubscribeCallback)
_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback(foreignCallbackCallbackInterfaceSubscribeCallback, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceSubscribeCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceSubscribeCallback)



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDoc(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDoc.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDoc.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEntry.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeConnectionInfo(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeConnectionInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeConnectionInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLatencyAndControlMsg.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLatencyAndControlMsg.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeQueryOptions(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeQueryOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeQueryOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalCallbackInterfaceDocExportFileCallback(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterCallbackInterfaceDocExportFileCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterCallbackInterfaceDocExportFileCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalCallbackInterfaceDocImportFileCallback(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterCallbackInterfaceDocImportFileCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterCallbackInterfaceDocImportFileCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAuthorId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAuthorId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAuthorId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDirectAddrInfo(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDirectAddrInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDirectAddrInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFilterKind(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFilterKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFilterKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeHash(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeHash.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeHash.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNodeAddr(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNodeAddr.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNodeAddr.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBlobListCollectionsResponse(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBlobListCollectionsResponse.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBlobListCollectionsResponse.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBlobListIncompleteResponse(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBlobListIncompleteResponse.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBlobListIncompleteResponse.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeConnectionInfo(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeConnectionInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeConnectionInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLinkAndName(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLinkAndName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLinkAndName.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeListTagsResponse(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeListTagsResponse.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeListTagsResponse.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNamespaceAndCapability.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNamespaceAndCapability.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeCounterStats(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeCounterStats.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeCounterStats.read(buf)
            d[key] = val
        return d

def key_to_path(key: "bytes",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "str":
    '''
    Helper function that translates a key that was derived from the [`path_to_key`] function back
    into a path.

    If `prefix` exists, it will be stripped before converting back to a path
    If `root` exists, will add the root as a parent to the created path
    Removes any null byte that has been appened to the key
    '''
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_key_to_path,
        _UniffiConverterBytes.lower(key),
        _UniffiConverterOptionalString.lower(prefix),
        _UniffiConverterOptionalString.lower(root)))


def path_to_key(path: "str",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "bytes":
    '''
    Helper function that creates a document key from a canonicalized path, removing the `root` and adding the `prefix`, if they exist

    Appends the null byte to the end of the key.
    '''
    
    
    
    return _UniffiConverterBytes.lift(_rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_path_to_key,
        _UniffiConverterString.lower(path),
        _UniffiConverterOptionalString.lower(prefix),
        _UniffiConverterOptionalString.lower(root)))


def set_log_level(level: "LogLevel"):
    '''Set the logging level.'''
    
    _rust_call(_UniffiLib.uniffi_iroh_fn_func_set_log_level,
        _UniffiConverterTypeLogLevel.lower(level))


def start_metrics_collection():
    '''Initialize the global metrics collection.'''
    _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection,)


__all__ = [
    "InternalError",
    "AddProgressType",
    "AddrInfoOptions",
    "BlobExportFormat",
    "BlobExportMode",
    "BlobFormat",
    "CapabilityKind",
    "ConnType",
    "ContentStatus",
    "DocExportProgressType",
    "DocImportProgressType",
    "DownloadProgressType",
    "IrohError",
    "LiveEventType",
    "LogLevel",
    "Origin",
    "ShareMode",
    "SortBy",
    "SortDirection",
    "SyncReason",
    "AddProgressAbort",
    "AddProgressAllDone",
    "AddProgressDone",
    "AddProgressFound",
    "AddProgressProgress",
    "BlobAddOutcome",
    "BlobListCollectionsResponse",
    "BlobListIncompleteResponse",
    "BlobListResponse",
    "ConnectionInfo",
    "ConnectionTypeMixed",
    "CounterStats",
    "DocExportProgressAbort",
    "DocExportProgressFound",
    "DocExportProgressProgress",
    "DocImportProgressAbort",
    "DocImportProgressAllDone",
    "DocImportProgressFound",
    "DocImportProgressIngestDone",
    "DocImportProgressProgress",
    "DownloadProgressAbort",
    "DownloadProgressAllDone",
    "DownloadProgressDone",
    "DownloadProgressFound",
    "DownloadProgressFoundHashSeq",
    "DownloadProgressFoundLocal",
    "DownloadProgressProgress",
    "HashAndTag",
    "InsertRemoteEvent",
    "LatencyAndControlMsg",
    "LinkAndName",
    "ListTagsResponse",
    "NamespaceAndCapability",
    "NodeOptions",
    "OpenState",
    "QueryOptions",
    "SyncEvent",
    "key_to_path",
    "path_to_key",
    "set_log_level",
    "start_metrics_collection",
    "AddProgress",
    "Author",
    "AuthorId",
    "BlobDownloadRequest",
    "BlobTicket",
    "Collection",
    "ConnectionType",
    "DirectAddrInfo",
    "Doc",
    "DocExportProgress",
    "DocImportProgress",
    "DownloadPolicy",
    "DownloadProgress",
    "Entry",
    "FilterKind",
    "Hash",
    "IrohNode",
    "LiveEvent",
    "NodeAddr",
    "NodeStatusResponse",
    "PublicKey",
    "Query",
    "RangeSpec",
    "SetTagOption",
    "WrapOption",
    "AddCallback",
    "DocExportFileCallback",
    "DocImportFileCallback",
    "DownloadCallback",
    "SubscribeCallback",
]

