# Copyright (c) 2018 MetPy Developers.
# Distributed under the terms of the BSD 3-Clause License.
# SPDX-License-Identifier: BSD-3-Clause

import logging
import math

import numpy as np
from scipy.spatial import ConvexHull, Delaunay, cKDTree, qhull

log = logging.getLogger(__name__)


def triangle_area(pt1, pt2, pt3):
    r"""Return the area of a triangle.

    Parameters
    ----------
    pt1: (X,Y) numpy.ndarray
        Starting vertex of a triangle
    pt2: (X,Y) numpy.ndarray
        Second vertex of a triangle
    pt3: (X,Y) numpy.ndarray
        Ending vertex of a triangle

    Returns
    -------
    area: float
        Area of the given triangle.

    """
    a = 0.0

    a += pt1[0] * pt2[1] - pt2[0] * pt1[1]
    a += pt2[0] * pt3[1] - pt3[0] * pt2[1]
    a += pt3[0] * pt1[1] - pt1[0] * pt3[1]

    return abs(a) / 2


def dist_2(x0, y0, x1, y1):
    r"""Return the squared distance between two points.

    This is faster than calculating distance but should
    only be used with comparable ratios.

    Parameters
    ----------
    x0: float
        Starting x coordinate
    y0: float
        Starting y coordinate
    x1: float
        Ending x coordinate
    y1: float
        Ending y coordinate

    Returns
    -------
    d2: float
        squared distance

    See Also
    --------
    distance

    """
    d0 = x1 - x0
    d1 = y1 - y0
    return d0**2 + d1**2


def distance(p0, p1):
    r"""Return the distance between two points.

    Parameters
    ----------
    p0: (X,Y) numpy.ndarray
        Starting coordinate
    p1: (X,Y) numpy.ndarray
        Ending coordinate

    Returns
    -------
    d: float
        distance

    See Also
    --------
    dist_2

    """
    return math.sqrt(dist_2(p0[0], p0[1], p1[0], p1[1]))


def circumcircle_radius(pt0, pt1, pt2):
    r"""Calculate and return the radius of a given triangle's circumcircle.

    Parameters
    ----------
    pt0: (x, y)
        Starting vertex of triangle
    pt1: (x, y)
        Second vertex of triangle
    pt2: (x, y)
        Final vertex of a triangle

    Returns
    -------
    r: float
        circumcircle radius

    See Also
    --------
    circumcenter

    """
    a = distance(pt0, pt1)
    b = distance(pt1, pt2)
    c = distance(pt2, pt0)

    t_area = triangle_area(pt0, pt1, pt2)

    return (a * b * c) / (4 * t_area) if t_area > 0 else np.nan


def circumcenter(pt0, pt1, pt2):
    r"""Calculate and return the circumcenter of a circumcircle generated by a given triangle.

    All three points must be unique or a division by zero error will be raised.

    Parameters
    ----------
    pt0: (x, y)
        Starting vertex of triangle
    pt1: (x, y)
        Second vertex of triangle
    pt2: (x, y)
        Final vertex of a triangle

    Returns
    -------
    cc: (x, y)
        circumcenter coordinates

    See Also
    --------
    circumcenter

    """
    a_x = pt0[0]
    a_y = pt0[1]
    b_x = pt1[0]
    b_y = pt1[1]
    c_x = pt2[0]
    c_y = pt2[1]

    bc_y_diff = b_y - c_y
    ca_y_diff = c_y - a_y
    ab_y_diff = a_y - b_y
    cb_x_diff = c_x - b_x
    ac_x_diff = a_x - c_x
    ba_x_diff = b_x - a_x

    d_div = a_x * bc_y_diff + b_x * ca_y_diff + c_x * ab_y_diff

    if d_div == 0:
        raise ZeroDivisionError(
            "Circumcenter calculation failed due to division by zero."
        )

    d_inv = 0.5 / d_div

    a_mag = a_x**2 + a_y**2
    b_mag = b_x**2 + b_y**2
    c_mag = c_x**2 + c_y**2

    cx = (a_mag * bc_y_diff + b_mag * ca_y_diff + c_mag * ab_y_diff) * d_inv
    cy = (a_mag * cb_x_diff + b_mag * ac_x_diff + c_mag * ba_x_diff) * d_inv

    return cx, cy


def find_natural_neighbors(tri, grid_points):
    r"""Return the natural neighbor triangles for each given grid cell.

    These are determined by the properties of the given Delaunay triangulation.
    A triangle is a natural neighbor of a grid cell if that triangle's circumcenter
    is within the circumradius of the grid cell center.

    Parameters
    ----------
    tri: `scipy.spatial.Delaunay`
        A Delaunay Triangulation.
    grid_points: (X, Y) numpy.ndarray
        Locations of grids.

    Returns
    -------
    members: dict
        List of simplex codes for natural neighbor triangles in ``tri`` for each grid cell.
    circumcenters: numpy.ndarray
        Circumcenter for each triangle in ``tri``.

    """
    # Used for fast identification of points with a radius of another point
    tree = cKDTree(grid_points)

    # Mask for points that are outside the triangulation
    in_triangulation = tri.find_simplex(tree.data) >= 0

    circumcenters = []
    members = {key: [] for key in range(len(tree.data))}
    for i, indices in enumerate(tri.simplices):
        # Find the circumcircle (center and radius) for the triangle.
        triangle = tri.points[indices]
        cc = circumcenter(*triangle)
        r = circumcircle_radius(*triangle)
        circumcenters.append(cc)

        # Find all grid points within the circumcircle.
        for point in tree.query_ball_point(cc, r):
            # If this point is within the triangulation, add this triangle to its list of
            # natural neighbors
            if in_triangulation[point]:
                members[point].append(i)

    return members, np.array(circumcenters)


def find_local_boundary(tri, triangles):
    r"""Find and return the outside edges of a collection of natural neighbor triangles.

    There is no guarantee that this boundary is convex, so ConvexHull is not
    sufficient in some situations.

    Parameters
    ----------
    tri: `scipy.spatial.Delaunay`
        A Delaunay Triangulation
    triangles: (N, ) array
        List of natural neighbor triangles.

    Returns
    -------
    edges: list
        List of vertex codes that form outer edges of
        a group of natural neighbor triangles.

    """
    edges = []

    for triangle in triangles:
        for i in range(3):
            pt1 = tri.simplices[triangle][i]
            pt2 = tri.simplices[triangle][(i + 1) % 3]

            if (pt1, pt2) in edges:
                edges.remove((pt1, pt2))

            elif (pt2, pt1) in edges:
                edges.remove((pt2, pt1))

            else:
                edges.append((pt1, pt2))

    return edges


def area(poly):
    r"""Find the area of a given polygon using the shoelace algorithm.

    Parameters
    ----------
    poly: (2, N) numpy.ndarray
        2-dimensional coordinates representing an ordered
        traversal around the edge a polygon.

    Returns
    -------
    area: float

    """
    a = 0.0
    n = len(poly)

    for i in range(n):
        a += poly[i][0] * poly[(i + 1) % n][1] - poly[(i + 1) % n][0] * poly[i][1]

    return abs(a) / 2.0


def order_edges(edges):
    r"""Return an ordered traversal of the edges of a two-dimensional polygon.

    Parameters
    ----------
    edges: (2, N) numpy.ndarray
        List of unordered line segments, where each
        line segment is represented by two unique
        vertex codes.

    Returns
    -------
    ordered_edges: (2, N) numpy.ndarray

    """
    edge = edges[0]
    edges = edges[1:]

    ordered_edges = [edge]

    num_max = len(edges)
    while len(edges) > 0 and num_max > 0:
        match = edge[1]

        for search_edge in edges:
            vertex = search_edge[0]
            if match == vertex:
                edge = search_edge
                edges.remove(edge)
                ordered_edges.append(search_edge)
                break
        num_max -= 1

    return ordered_edges


def natural_neighbor_point(xp, yp, variable, grid_loc, tri, neighbors, circumcenters):
    r"""Generate a natural neighbor interpolation of the observations to the given point.

    This uses the Liang and Hale approach [Liang2010]_. The interpolation will fail if
    the grid point has no natural neighbors.

    Parameters
    ----------
    xp: (N, ) numpy.ndarray
        x-coordinates of observations
    yp: (N, ) numpy.ndarray
        y-coordinates of observations
    variable: (N, ) numpy.ndarray
        observation values associated with (xp, yp) pairs.
        IE, variable[i] is a unique observation at (xp[i], yp[i])
    grid_loc: (float, float)
        Coordinates of the grid point at which to calculate the
        interpolation.
    tri: `scipy.spatial.Delaunay`
        Delaunay triangulation of the observations.
    neighbors: (N, ) numpy.ndarray
        Simplex codes of the grid point's natural neighbors. The codes
        will correspond to codes in the triangulation.
    circumcenters: list
        Pre-calculated triangle circumcenters for quick look ups. Requires
        indices for the list to match the simplices from the Delaunay triangulation.

    Returns
    -------
    value: float
       Interpolated value for the grid location

    """
    edges = find_local_boundary(tri, neighbors)
    edge_vertices = [segment[0] for segment in order_edges(edges)]
    num_vertices = len(edge_vertices)

    p1 = edge_vertices[0]
    p2 = edge_vertices[1]

    c1 = circumcenter(grid_loc, tri.points[p1], tri.points[p2])
    polygon = [c1]

    area_list = []
    total_area = 0.0

    for i in range(num_vertices):
        p3 = edge_vertices[(i + 2) % num_vertices]

        try:
            c2 = circumcenter(grid_loc, tri.points[p3], tri.points[p2])
            polygon.append(c2)

            for check_tri in neighbors:
                if p2 in tri.simplices[check_tri]:
                    polygon.append(circumcenters[check_tri])

            pts = [polygon[i] for i in ConvexHull(polygon).vertices]
            value = variable[(tri.points[p2][0] == xp) & (tri.points[p2][1] == yp)]

            cur_area = area(pts)

            total_area += cur_area

            area_list.append(cur_area * value[0])

        except (ZeroDivisionError, qhull.QhullError) as e:
            message = (
                "Error during processing of a grid. "
                "Interpolation will continue but be mindful "
                f"of errors in output. {e}"
            )

            log.warning(message)
            return np.nan

        polygon = [c2]

        p2 = p3

    return sum(x / total_area for x in area_list)


def natural_neighbor_to_points(points, values, xi):
    r"""Generate a natural neighbor interpolation to the given points.

    This assigns values to the given interpolation points using the Liang and Hale
    [Liang2010]_. approach.

    Parameters
    ----------
    points: array-like, (N, 2)
        Coordinates of the data points.
    values: array-like, (N,)
        Values of the data points.
    xi: array-like, (M, 2)
        Points to interpolate the data onto.

    Returns
    -------
    img: numpy.ndarray, (M,)
        Array representing the interpolated values for each input point in `xi`

    See Also
    --------
    natural_neighbor_to_grid

    """

    tri = Delaunay(points)

    members, circumcenters = find_natural_neighbors(tri, xi)

    img = np.asarray(
        [
            natural_neighbor_point(
                *np.array(points).transpose(),
                values,
                xi[grid],
                tri,
                neighbors,
                circumcenters,
            )
            if len(neighbors) > 0
            else np.nan
            for grid, neighbors in members.items()
        ]
    )

    return img


def neighbors_and_weights(xp, yp, grid_loc, tri, neighbors, circumcenters):
    r"""Generate a natural neighbor interpolation of the observations to the given point.

    This uses the Liang and Hale approach [Liang2010]_. The interpolation will fail if
    the grid point has no natural neighbors.

    Parameters
    ----------
    xp: (N, ) numpy.ndarray
        x-coordinates of observations
    yp: (N, ) numpy.ndarray
        y-coordinates of observations
    grid_loc: (float, float)
        Coordinates of the grid point at which to calculate the
        interpolation.
    tri: `scipy.spatial.Delaunay`
        Delaunay triangulation of the observations.
    neighbors: (N, ) numpy.ndarray
        Simplex codes of the grid point's natural neighbors. The codes
        will correspond to codes in the triangulation.
    circumcenters: list
        Pre-calculated triangle circumcenters for quick look ups. Requires
        indices for the list to match the simplices from the Delaunay triangulation.

    Returns
    -------
    neighbor_list: list
       List of neighbors for the grid location
    weights: numpy.ndarray
         List of weights for the grid location

    """

    edges = find_local_boundary(tri, neighbors)
    edge_vertices = [segment[0] for segment in order_edges(edges)]
    num_vertices = len(edge_vertices)

    p1 = edge_vertices[0]
    p2 = edge_vertices[1]

    c1 = circumcenter(grid_loc, tri.points[p1], tri.points[p2])

    polygon = [c1]

    neighbor_list = []
    area_list = []
    total_area = 0.0

    for i in range(num_vertices):
        p3 = edge_vertices[(i + 2) % num_vertices]

        try:
            c2 = circumcenter(grid_loc, tri.points[p3], tri.points[p2])

            polygon.append(c2)

            for check_tri in neighbors:
                if p2 in tri.simplices[check_tri]:
                    polygon.append(circumcenters[check_tri])

            pts = [polygon[i] for i in ConvexHull(polygon).vertices]

            cur_area = area(pts)

            total_area += cur_area

            neighbor_list.append(p2)
            area_list.append(cur_area)

        except (ZeroDivisionError, qhull.QhullError) as e:
            message = (
                "Error during processing of a grid. "
                "Interpolation will continue but be mindful "
                f"of errors in output. {e}"
            )

            log.warning(message)
            return list(), list()

        polygon = [c2]

        p2 = p3

    weights = list(x / total_area for x in area_list)
    return neighbor_list, np.array(weights)


def find_all_neighbors_and_weights(points, xi):
    r"""Find the natural neighbors and weights for each grid cell.

    Parameters
    ----------
    points: array-like, (N, 2)
        Coordinates of the data points.
    xi: array-like, (M, 2)
        Points to interpolate the data onto.

    Returns
    -------
    neighbors_list: list
        List of neighbors for each grid location
    weights_list: list
        List of weights for each grid location

    """

    tri = Delaunay(points)

    members, circumcenters = find_natural_neighbors(tri, xi)

    neighbors_list = []
    weights_list = []
    for grid, neighbors_simplices in members.items():
        if len(neighbors_simplices) > 0:
            neighbors, weights = neighbors_and_weights(
                *np.array(points).transpose(),
                xi[grid],
                tri,
                neighbors_simplices,
                circumcenters,
            )
            neighbors_list.append(neighbors)
            weights_list.append(weights)
        else:
            neighbors_list.append(list())
            weights_list.append(list())

    return neighbors_list, weights_list


def interpolate_natural_neighbors(
    points, values, xi, neighbors_list=None, weights_list=None
):
    r"""Interpolate values to the given points using natural neighbor interpolation.
    Optionally, the neighbors and weights can be pre-calculated and passed in to
    speed up the interpolation.

    Parameters
    ----------
    points: array-like, (N, 2)
        Coordinates of the data points.
    values: array-like, (N,)
        Values of the data points.
    xi: array-like, (M, 2)
        Points to interpolate the data onto.
    neighbors_list: list
        List of neighbors for each grid location
    weights_list: list
        List of weights for each grid location

    Returns
    -------
    yi: numpy.ndarray, (M,)
        Array representing the interpolated values for each input point in `xi`

    """

    if neighbors_list is None or weights_list is None:
        neighbors_list, weights_list = find_all_neighbors_and_weights(points, xi)

    yi = np.full(xi.shape[0], np.nan)

    for i, (neighbors, weights) in enumerate(zip(neighbors_list, weights_list)):
        if len(neighbors) > 0:
            yi[i] = (values[neighbors] * weights).sum()

    return yi
