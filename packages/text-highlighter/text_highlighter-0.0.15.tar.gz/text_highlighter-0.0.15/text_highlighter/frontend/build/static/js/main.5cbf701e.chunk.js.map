{"version":3,"sources":["TextHighlighter.tsx","index.tsx"],"names":["MyComponent","state","tag","isFocused","render","annotations","props","args","colors","labels","text","selected_label","show_label_selector","text_height","theme","style","borderStyling","primaryColor","border","outline","initial","value","setState","className","map","label","index","key","backgroundColor","onClick","paddingBottom","lineHeight","height","overflowY","content","onChange","updateState","getSpan","span","color","indexOf","mergeAnnotations","filter","annotation","isNaN","start","end","annotation1","isOverlapping","otherAnnotation","annotation2","newAnnotations","annotation3","push","callback","Streamlit","setComponentValue","_onFocus","_onBlur","StreamlitComponentBase","withStreamlitConnection","ReactDOM","TextHighlighter","document","getElementById"],"mappings":"oTAmBMA,G,kNACGC,MAAQ,CAAEC,IAAK,GAAIC,WAAW,G,EAE9BC,OAAS,WAGd,IAAMC,EAAc,EAAKC,MAAMC,KAAX,YACdC,EAAS,EAAKF,MAAMC,KAAX,OACTE,EAAS,EAAKH,MAAMC,KAAX,OACTG,EAAO,EAAKJ,MAAMC,KAAX,KACPI,EAAiB,EAAKL,MAAMC,KAAX,eACjBK,EAAsB,EAAKN,MAAMC,KAAX,oBACtBM,EAAc,EAAKP,MAAMC,KAAX,YAKZO,EAAU,EAAKR,MAAfQ,MACFC,EAA6B,GAInC,GAAID,EAAO,CAGT,IAAME,EAAa,oBAAgB,EAAKf,MAAME,UAAYW,EAAMG,aAAe,QAE/EF,EAAMG,OAASF,EACfD,EAAMI,QAAUH,EAQlB,OACE,kBAAC,IAAD,CAAOI,QAAS,CAAEC,MAAOhB,EAAaH,IAAKS,KACxC,gBAAGV,EAAH,EAAGA,MAAOqB,EAAV,EAAUA,SAAV,OACC,8BACGV,GAAuB,0BAAMW,UAAU,kBACtCd,EAAOe,KAAI,SAACC,EAAYC,GAAb,OACP,0BACIC,IAAKF,EACLF,UAAS,qBAAgBtB,EAAMC,MAAQuB,EAAQ,WAAa,cAC5DV,MAAO,CAACa,gBAAiBpB,EAAOkB,IAChCG,QAAS,kBAAMP,EAAS,CAACpB,IAAKuB,MAEnCA,OAKL,kBAAC,gBAAD,CACEV,MAAO,CACLe,cAAe,MACfC,WAAY,IACZC,OAAQnB,EAAc,KACtBoB,UAAW,UAEbC,QAASxB,EACTW,MAAOpB,EAAMoB,MACbc,SAAU,SAACd,GAAD,OAAgB,EAAKe,YAAYf,EAAOC,IAClDe,QAAS,SAAAC,GAAI,kCACRA,GADQ,IAEXpC,IAAKD,EAAMC,IACXqC,MAAO/B,EAAOC,EAAO+B,QAAQvC,EAAMC,gB,EAUzCuC,iBAAmB,SAACpC,GAI1BA,EAAcA,EAAYqC,QAAO,SAACC,GAAD,OAAsBC,MAAMD,EAAWE,SAAWD,MAAMD,EAAWG,QAJnD,oBAKvBzC,GALuB,IAKjD,2BAAuC,CAAC,IAAD,EAA5B0C,EAA4B,QACjCC,GAAgB,EAChBC,EAAkB,KAFe,cAGX5C,GAHW,IAGrC,2BAAuC,CAAC,IAA7B6C,EAA4B,QACrC,IAAIH,EAAYF,QAAUK,EAAYL,OAASE,EAAYD,MAAQI,EAAYJ,OAC1EI,EAAYL,OAASE,EAAYF,OAASK,EAAYJ,KAAOC,EAAYF,OAAWK,EAAYL,OAASE,EAAYD,KAAOI,EAAYJ,KAAOC,EAAYD,KAAM,CACpKE,GAAgB,EAChBC,EAAkBC,EAClB,QARiC,8BAWrC,GAAIF,EAAe,CACjB,IADiB,EACXG,EAAiB,GADN,cAES9C,GAFT,IAEjB,2BAAuC,CAAC,IAAD,IAA5B+C,EAA4B,QACjCA,EAAYP,QAAUE,EAAYF,OAASO,EAAYN,MAAQC,EAAYD,KAAOM,EAAYP,SAAZ,UAAsBI,SAAtB,aAAsB,EAAiBJ,QAASO,EAAYN,OAAZ,UAAoBG,SAApB,aAAoB,EAAiBH,MACzKK,EAAeE,KAAKD,IAJP,8BAQjB,OAAOD,IAxBsC,8BA2BjD,OAAO9C,G,EAGD+B,YAAc,SAACf,EAAYiC,GAEjCA,EAAS,CAAEjC,MADXA,EAAQ,EAAKoB,iBAAiBpB,KAE9BkC,IAAUC,kBAAkBnC,I,EAItBoC,SAAW,WACjB,EAAKnC,SAAS,CAAEnB,WAAW,K,EAIrBuD,QAAU,WAChB,EAAKpC,SAAS,CAAEnB,WAAW,K,yBAvHLwD,MAgIXC,cAAwB5D,GC/IvC6D,IAASzD,OACP,kBAAC0D,EAAD,MACAC,SAASC,eAAe,W","file":"static/js/main.5cbf701e.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\nimport { TextAnnotator } from 'react-text-annotate'\nimport { State } from 'react-powerplug'\nimport \"./style.css\"\n\ninterface BaseState {\n  isFocused: boolean,\n  tag: string,\n}\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase<BaseState> {\n  public state = { tag: '', isFocused: false }\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n    const annotations = this.props.args[\"annotations\"]\n    const colors = this.props.args[\"colors\"]\n    const labels = this.props.args[\"labels\"]\n    const text = this.props.args[\"text\"]\n    const selected_label = this.props.args[\"selected_label\"]\n    const show_label_selector = this.props.args[\"show_label_selector\"]\n    const text_height = this.props.args[\"text_height\"]\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n      const borderStyling = `1px solid ${this.state.isFocused ? theme.primaryColor : \"gray\"\n        }`\n      style.border = borderStyling\n      style.outline = borderStyling\n    }\n\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    // initial={{ value: [{ start: 18, end: 28, tag: 'PERSON' }], tag: 'PERSON' }}\n    return (\n      <State initial={{ value: annotations, tag: selected_label }}>\n        {({ state, setState }) => (\n          <span>\n            {show_label_selector && <span className=\"label-selector\">{\n              labels.map((label: any, index: number) => (\n                  <span\n                      key={label}\n                      className={`label-pill ${state.tag === label ? 'selected' : 'deselected'}`}\n                      style={{backgroundColor: colors[index]}}\n                      onClick={() => setState({tag: label})}\n                  >\n                {label}\n                </span>\n              ))\n            }</span>}\n\n            <TextAnnotator\n              style={{\n                paddingBottom: '8px',\n                lineHeight: 1.5,\n                height: text_height + 'px',\n                overflowY: 'scroll'\n              }}\n              content={text}\n              value={state.value}\n              onChange={(value: any) => this.updateState(value, setState)}\n              getSpan={span => ({\n                ...span,\n                tag: state.tag,\n                color: colors[labels.indexOf(state.tag)],\n              })}\n            />\n          </span>\n        )}\n      </State>\n\n    )\n  }\n\n  private mergeAnnotations = (annotations: any[]) => {\n    // Remove all annotations which are a subannotation of another annotation;\n    // which means that annotation2.start >= annotation1.start and annotation2.end <= annotation1.end\n    // Remove any annotations with start NaN or end NaN\n    annotations = annotations.filter((annotation: any) => !isNaN(annotation.start) && !isNaN(annotation.end));\n    for (const annotation1 of annotations) {\n      var isOverlapping = false;\n      let otherAnnotation = null;\n      for (const annotation2 of annotations) {\n        if (annotation1.start === annotation2.start && annotation1.end === annotation2.end) continue;\n        if ((annotation2.start <= annotation1.start && annotation2.end >= annotation1.start) || (annotation2.start <= annotation1.end && annotation2.end >= annotation1.end)) {\n          isOverlapping = true;\n          otherAnnotation = annotation2;\n          break;\n        }\n      }\n      if (isOverlapping) {\n        const newAnnotations = [];\n        for (const annotation3 of annotations) {\n          if (annotation3.start !== annotation1.start && annotation3.end !== annotation1.end && annotation3.start !== otherAnnotation?.start && annotation3.end !== otherAnnotation?.end) {\n            newAnnotations.push(annotation3);\n          }\n        }\n        // Deselect both annotation1 and otherannotation\n        return newAnnotations;\n      }\n    }\n    return annotations;\n  }\n\n  private updateState = (value: any, callback: any): void => {\n    value = this.mergeAnnotations(value);\n    callback({ value });\n    Streamlit.setComponentValue(value);\n  }\n\n  /** Focus handler for our \"Click Me!\" button. */\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  /** Blur handler for our \"Click Me!\" button. */\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(MyComponent)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport TextHighlighter from \"./TextHighlighter\"\n\nReactDOM.render(\n  <TextHighlighter />,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}