// Auto generated code by ssc_gen
// WARNING: Any manual changes made to this file will be lost when this
// is run again. Do not edit this file unless you know what you are doing.

import 'dart:core';
import 'baseStruct.dart';

/// Representation available dubbers and params. Useful for switch dubber
///
/// [
///   {
///     "name": "String",
///     "value": "String",
///     "data_id": "String",
///     "data_translation_type": "String",
///     "data_media_hash": "String",
///     "data_media_type": "String",
///     "data_title": "String"
///   },
///   "..."
/// ]
class MovieTranslationsPanel extends BaseParser {
  MovieTranslationsPanel(rawDocument) : super(rawDocument);
  MovieTranslationsPanel.fromDocument(document) : super.fromDocument(document);
  MovieTranslationsPanel.fromElement(element) : super.fromElement(element);

  @override
  mRunParse() {
    List<Map<String, dynamic>> items = [];
    for (var el in mPartDocument(selector)) {
      Map<String, dynamic> tmpItem = {};
      tmpItem["name"] = xxParseName(el);
      tmpItem["value"] = xxParseValue(el);
      tmpItem["data_id"] = xxParseDataId(el);
      tmpItem["data_translation_type"] = xxParseDataTranslationType(el);
      tmpItem["data_media_hash"] = xxParseDataMediaHash(el);
      tmpItem["data_media_type"] = xxParseDataMediaType(el);
      tmpItem["data_title"] = xxParseDataTitle(el);
      items.add(tmpItem);
    }
    return items;
  }

  xxParseName(el) {
    var val = mAttrText(el);
    var val1 = mStrTrim(val, ' ');
    return val1;
  }

  xxParseValue(el) {
    var val = mAttr(el, 'value');
    return val;
  }

  xxParseDataId(el) {
    var val = mAttr(el, 'data-id');
    return val;
  }

  xxParseDataTranslationType(el) {
    var val = mAttr(el, 'data-translation-type');
    return val;
  }

  xxParseDataMediaHash(el) {
    var val = mAttr(el, 'data-media-hash');
    return val;
  }

  xxParseDataMediaType(el) {
    var val = mAttr(el, 'data-media-type');
    return val;
  }

  xxParseDataTitle(el) {
    var val = mAttr(el, 'data-title');
    return val;
  }
}

/// payload for Kodik API request
///
/// {
///   "d": "String",
///   "d_sign": "String",
///   "pd": "String",
///   "pd_sign": "String",
///   "ref": "String",
///   "ref_sign": "String",
///   "type": "String",
///   "hash": "String",
///   "id": "String"
/// }
class KodikAPIPayload extends BaseParser {
  KodikAPIPayload(rawDocument) : super(rawDocument);
  KodikAPIPayload.fromDocument(document) : super.fromDocument(document);
  KodikAPIPayload.fromElement(element) : super.fromElement(element);

  @override
  mRunParse() {
    Map<String, dynamic> items = {};

    items["d"] = xxParseD(selector);
    items["d_sign"] = xxParseDSign(selector);
    items["pd"] = xxParsePd(selector);
    items["pd_sign"] = xxParsePdSign(selector);
    items["ref"] = xxParseRef(selector);
    items["ref_sign"] = xxParseRefSign(selector);
    items["type"] = xxParseType(selector);
    items["hash"] = xxParseHash(selector);
    items["id"] = xxParseId(selector);
    return items;
  }

  xxParseD(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'var\\s*domain\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseDSign(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'var\\s*d_sign\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParsePd(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 = mReMatch(val, 'var\\s*pd\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParsePdSign(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'var\\s*pd_sign\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseRef(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 = mReMatch(val, 'var\\s*ref\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseRefSign(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'var\\s*ref_sign\\s+=\\s+[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseType(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'videoInfo\\.type\\s*=\\s*[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseHash(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'videoInfo\\.hash\\s*=\\s*[\'"](.*?)[\'"];', group: 1);
    return val1;
  }

  xxParseId(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 =
        mReMatch(val, 'videoInfo\\.id\\s*=\\s*[\'"](.*?)[\'"];', group: 1);
    return val1;
  }
}

/// this schema used to extract params for next API request
///
///     required next keys for API request:
///         - contain in `api_payload` key
///     constants:
///         - cdn_is_working: true
///         - bad_user: false (or true)
///         - info: {}
///
///     USAGE:
///         1. GET <PLAYER_LINK> (e.g.: https://kodik.info/seria/1133512/04d5f7824ba3563bd78e44a22451bb45/720p)
///         2. parse payload (see required pairs upper) (<PAYLOAD>)
///         3. extract the API path from player_js_path (<API_PATH>) (encoded in BASE64)
///         4. POST https://kodik.info/ + <API_PATH>; data=<PAYLOAD> (<JSON>). next HEADERS required:
///             - origin="https://<NETLOC>" // player page
///             - referer=<PLAYER_LINK> // FIRST URL player entrypoint
///             - accept= "application/json, text/javascript, */*; q=0.01"
///         5. extract data from ['links'] key from <JSON> response
///         6. urls encoded in ROT_13 + BASE64 ciphers
///     ISSUES:
///         - kodik maybe have another netloc (e.g.: anivod)
///         - 403 Forbidden if request sent not from CIS region
///         - 404 DELETED: eg: https://kodik.info/seria/310427/09985563d891b56b1e9b01142ae11872/720p
///
///
///
/// {
///   "url_params": "String",
///   "api_payload": {
///     "d": "String",
///     "d_sign": "String",
///     "pd": "String",
///     "pd_sign": "String",
///     "ref": "String",
///     "ref_sign": "String",
///     "type": "String",
///     "hash": "String",
///     "id": "String"
///   },
///   "player_js_path": "String",
///   "movie_translations": [
///     {
///       "name": "String",
///       "value": "String",
///       "data_id": "String",
///       "data_translation_type": "String",
///       "data_media_hash": "String",
///       "data_media_type": "String",
///       "data_title": "String"
///     },
///     "..."
///   ]
/// }
class KodikPage extends BaseParser {
  KodikPage(rawDocument) : super(rawDocument);
  KodikPage.fromDocument(document) : super.fromDocument(document);
  KodikPage.fromElement(element) : super.fromElement(element);

  @override
  mRunParse() {
    Map<String, dynamic> items = {};

    items["url_params"] = xxParseUrlParams(selector);
    items["api_payload"] = xxParseApiPayload(selector);
    items["player_js_path"] = xxParsePlayerJsPath(selector);
    items["movie_translations"] = xxParseMovieTranslations(selector);
    return items;
  }

  xxParseUrlParams(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 = mReMatch(val, 'var\\s*urlParams\\s*=\\s*[\'"](\\{.*\\})[\'"]',
        group: 1);
    return val1;
  }

  xxParseApiPayload(el) {
    var val = KodikAPIPayload.fromDocument(el).parse();
    return val;
  }

  xxParsePlayerJsPath(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 = mReMatch(val,
        '<script\\s*type="text/javascript"\\s*src="(/assets/js/app\\.player_single.*?)">',
        group: 1);
    return val1;
  }

  xxParseMovieTranslations(el) {
    try {
      var val = MovieTranslationsPanel.fromDocument(el).parse();
      return val;
    } catch (e) {
      return null;
    }
  }
}

/// Extract the API path from js player source
///
/// {
///   "path": "String"
/// }
class KodikApiPath extends BaseParser {
  KodikApiPath(rawDocument) : super(rawDocument);
  KodikApiPath.fromDocument(document) : super.fromDocument(document);
  KodikApiPath.fromElement(element) : super.fromElement(element);

  @override
  mRunParse() {
    Map<String, dynamic> items = {};

    items["path"] = xxParsePath(selector);
    return items;
  }

  xxParsePath(el) {
    var val = mAttrRaw(el.querySelector('html'));
    var val1 = mReMatch(
        val, '\\\$\\.ajax\\([^>]+,url:\\s*atob\\(["\']([\\w=]+)["\']\\)',
        group: 1);
    return val1;
  }
}
