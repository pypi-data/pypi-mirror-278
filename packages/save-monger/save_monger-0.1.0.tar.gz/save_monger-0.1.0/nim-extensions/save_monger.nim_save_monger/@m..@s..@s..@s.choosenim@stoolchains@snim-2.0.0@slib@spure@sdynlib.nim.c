/* Generated by Nim Compiler v2.0.0 */
#define NIM_INTBITS 64
#define NIM_EmulateOverflowChecks

#include "nimbase.h"
#include <windows.h>
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
struct TGenericSeq {
	NI len;
	NI reserved;
};
struct NimStringDesc {
  TGenericSeq Sup;
	NIM_CHAR data[SEQ_DECL_SIZE];
};
static N_INLINE(NCSTRING, nimToCStringConv)(NimStringDesc* s_p0);
static N_INLINE(NCSTRING, nimToCStringConv)(NimStringDesc* s_p0) {
	NCSTRING result;
	result = (NCSTRING)0;
	{
		NIM_BOOL T3_;
		T3_ = (NIM_BOOL)0;
		T3_ = (s_p0 == ((NimStringDesc*) NIM_NIL));
		if (T3_) goto LA4_;
		T3_ = ((*s_p0).Sup.len == ((NI)0));
LA4_: ;
		if (!T3_) goto LA5_;
		result = "";
	}
	goto LA1_;
LA5_: ;
	{
		result = ((NCSTRING) ((*s_p0).data));
	}
LA1_: ;
	return result;
}
N_LIB_PRIVATE N_NIMCALL(void*, loadLib__pureZdynlib_u3)(NimStringDesc* path_p0, NIM_BOOL globalSymbols_p1) {
	void* result;
	HMODULE T1_;
	result = (void*)0;
	T1_ = (HMODULE)0;
	T1_ = LoadLibraryA(nimToCStringConv(path_p0));
	result = ((void*) (T1_));
	return result;
}
N_LIB_PRIVATE N_NIMCALL(void*, symAddr__pureZdynlib_u49)(void* lib_p0, NCSTRING name_p1) {
	void* result;
	FARPROC T1_;
	result = (void*)0;
	T1_ = (FARPROC)0;
	T1_ = GetProcAddress(((HMODULE) (lib_p0)), name_p1);
	result = ((void*) (T1_));
	return result;
}
