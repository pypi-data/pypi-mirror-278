import re
import os
import subprocess
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity


class MathDf:
    def __init__(self):
        self.tasks = {
            "Концепция класса и объекта. Принципы и механизмы ООП.": "Класс - это шаблон, описывающий свойства (атрибуты) и поведение (методы) объектов, которые будут создаваться на его основе. Объект - это конкретный экземпляр класса с уникальными значениями атрибутов. Основные принципы ООП включают: инкапсуляцию, которая подразумевает скрытие внутреннего состояния объекта и доступ к нему только через методы; наследование, позволяющее создавать новые классы на основе существующих и тем самым уменьшать дублирование кода; полиморфизм, который позволяет использовать один интерфейс для разных типов данных, и абстракцию, фокусирующуюся на выделении главных характеристик объекта и игнорировании несущественных деталей. Эти принципы помогают создавать структурированный, понятный и повторно используемый код.",
            "Объявление класса, конструктор, создание объектов и одиночное наследование в Python. Управление доступом к атрибутам класса в Python. Полиморфизм и утиная типизация, проверка принадлежности объекта к классу в языке Python": "Класс в Python объявляется с помощью ключевого слова `class`. Конструктор - это метод `__init__`, который вызывается при создании объекта класса. Наследование осуществляется указанием родительского класса в скобках после имени класса. Доступ к атрибутам класса управляется через уровни доступа: публичные (без подчеркивания), защищенные (с одним подчеркиванием) и приватные (с двумя подчеркиваниями). Полиморфизм позволяет использовать методы разных классов через один интерфейс. Утиная типизация предполагает, что объект может быть использован, если он имеет нужные методы и свойства, независимо от его класса. Проверка принадлежности объекта к классу выполняется с помощью функции `isinstance`.",
            "Методы классов и статические переменные, методы в Python. Специальные методы для использования пользовательских классов со стандартными операторами и функциями.": "Методы классов в Python объявляются внутри класса и первым аргументом принимают `self`, который ссылается на экземпляр класса. Статические методы обозначаются декоратором `@staticmethod`, они не принимают `self` и могут быть вызваны без создания экземпляра класса. Статические переменные определяются внутри класса, но вне методов, и общие для всех экземпляров. Специальные методы (магические методы) начинаются и заканчиваются двойным подчеркиванием, например, `__init__` для инициализации, `__str__` для строкового представления объекта, `__add__` для перегрузки оператора сложения. Эти методы позволяют использовать пользовательские классы с операторами и функциями, как встроенные типы данных.",
            "Основные возможности, поддерживаемые функциональными языками программирования. Поддержка элементов функционального программирования в Python": "Функциональные языки программирования поддерживают такие возможности, как чистые функции, неизменяемые данные, высшие функции (функции первого класса), каррирование и рекурсия. Чистые функции всегда возвращают одинаковый результат для одних и тех же аргументов и не имеют побочных эффектов. Неизменяемость данных обеспечивает безопасность многопоточности. Высшие функции могут принимать другие функции в качестве аргументов или возвращать их. В Python функциональное программирование поддерживается через такие элементы, как функции `map`, `filter` и `reduce`, выражения `lambda`, функции первого класса, и неизменяемые типы данных, такие как `tuple`.",
            "Концепция «функции – граждане первого класса» в языке программирования, поддержка этой концепции в Python. Специфика лямбда функций в Python их возможности и ограничения. Типичные сценарии использования лямбда-функций в Python.": "Концепция «функции – граждане первого класса» означает, что функции могут быть присвоены переменным, переданы как аргументы другим функциям и возвращены как результат других функций. В Python это поддерживается полностью. Лямбда функции в Python - это анонимные функции, определяемые с помощью ключевого слова `lambda`. Они могут иметь любое количество аргументов, но только одно выражение. Ограничения лямбда функций включают невозможность использовать многослойные выражения или операторы и их анонимность, что затрудняет отладку. Типичные сценарии использования лямбда-функций включают кратковременные функции для сортировки, фильтрации и в высших функциях, таких как `map`, `filter` и `reduce`.",
            "Глобальные и локальные переменные в функциях на примере Python. Побочные эффекты вызова функций и их последствия.": "Глобальные переменные определяются вне функций и доступны для всех функций в модуле. Локальные переменные создаются внутри функции и доступны только в этой функции. Пример: \nglobal_var = 10\n\ndef my_func():\n    local_var = 5\n    print(global_var + local_var)\n\nmy_func() # Выводит 15. Побочные эффекты - это изменения состояния программы или внешнего окружения, вызванные функцией, например, изменение глобальных переменных или модификация объектов, переданных по ссылке. Такие эффекты могут привести к труднонаходимым ошибкам и делают функции менее предсказуемыми.",
            "Вложенные функции и замыкания, специфика реализации в Python.": "Вложенные функции - это функции, определенные внутри других функций. Замыкание возникает, когда вложенная функция запоминает значения из окружающей области видимости, даже после того, как внешняя функция завершила выполнение. Пример: \ndef outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nclosure = outer(10)\nprint(closure(5)) # Выводит 15. В Python замыкания полезны для создания функций с сохраненным состоянием и для фабричных функций. Замыкания запоминают привязки переменных на момент их создания и могут использоваться для инкапсуляции и защиты данных.",
            "Функции высшего порядка и декораторы в Python.": "Функции высшего порядка принимают другие функции в качестве аргументов или возвращают функции. Пример: \ndef apply(func, x):\n    return func(x)\n\nprint(apply(lambda y: y * 2, 5)) # Выводит 10. Декораторы - это функции высшего порядка, которые принимают другую функцию и расширяют её функциональность без изменения её кода. Пример: \ndef my_decorator(func):\n    def wrapper():\n        print('Before')\n        func()\n        print('After')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('Hello')\n\nsay_hello() # Выводит 'Before', 'Hello', 'After'. Декораторы часто используются для логирования, проверки и модификации ввода-вывода функций.",
            "Концепция map/filter/reduce. Реализация map/filter/reduce в Python и пример их использования.": "Функции map, filter и reduce являются основными инструментами функционального программирования. Функция `map` применяет переданную функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами. Функция `filter` фильтрует элементы итерируемого объекта, оставляя только те, для которых переданная функция возвращает True. Функция `reduce` (из модуля functools) применяет бинарную функцию к элементам итерируемого объекта, сводя его к одному значению. Примеры: \n\nfrom functools import reduce\n\n# map\nnumbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)  # [1, 4, 9, 16]\n\n# filter\nodd_numbers = list(filter(lambda x: x % 2 != 0, numbers))\nprint(odd_numbers)  # [1, 3]\n\n# reduce\nsum_numbers = reduce(lambda x, y: x + y, numbers)\nprint(sum_numbers)  # 10. Эти функции упрощают работу с итерируемыми объектами, делая код более декларативным и читаемым.",
            "Итераторы в Python: встроенные итераторы, создание собственных итераторов, типичные способы обхода итераторов и принцип их работы. Встроенные функции для работы с итераторами и возможности модуля itertools. Функции генераторы и выражения генераторы: создание и применение в Python": "Итераторы - объекты, поддерживающие метод __iter__(), возвращающий сам объект, и метод __next__(), возвращающий следующий элемент или вызывающий StopIteration. Встроенные итераторы включают списки, кортежи, словари и файлы. Собственные итераторы создаются через классы: \n\nclass MyIterator:\n    def __init__(self, data):\n        self.data = data\n        self.index = 0\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.index < len(self.data):\n            result = self.data[self.index]\n            self.index += 1\n            return result\n        else:\n            raise StopIteration\n\n# Использование:\nmy_iter = MyIterator([1, 2, 3])\nfor item in my_iter:\n    print(item)  # 1, 2, 3. Встроенные функции: `iter`, `next`, `enumerate`, `zip`, `map`, `filter`. Модуль itertools предлагает мощные инструменты для работы с итераторами: `count`, `cycle`, `chain`, `islice` и т.д. Функции-генераторы создаются с помощью ключевого слова `yield`: \n\ndef my_gen():\n    yield 1\n    yield 2\n    yield 3\n\nfor value in my_gen():\n    print(value)  # 1, 2, 3. Выражения-генераторы создаются аналогично списочным включениям, но используют круглые скобки: \ngen_expr = (x**2 for x in range(5))\nprint(list(gen_expr))  # [0, 1, 4, 9, 16]. Генераторы позволяют экономить память за счёт ленивых вычислений.",
            "Специфика массивов, как структур данных. Динамические массивы - специфика работы, сложность операций. Специфика работа с array в Python.": "Массивы - это структуры данных, хранящие элементы одинакового типа в непрерывной области памяти. Динамические массивы могут изменять свой размер во время выполнения программы. В Python динамические массивы реализованы с помощью списков (list). Списки могут автоматически изменять размер при добавлении/удалении элементов, что делает их удобными, но может повлиять на производительность. Операции добавления/удаления элементов в конец имеют амортизированную сложность O(1), вставка/удаление в середину/начало - O(n), доступ по индексу - O(1). Модуль array в Python предоставляет массивы с фиксированным типом элементов, что делает их более эффективными по памяти и быстрее для некоторых операций. Пример: \n\nimport array as arr\nmy_array = arr.array('i', [1, 2, 3, 4])\nmy_array.append(5)\nprint(my_array)  # array('i', [1, 2, 3, 4, 5]). Массивы array используются для более эффективного хранения данных одного типа, особенно для числовых вычислений.",
            "Абстрактная структура данных стек и очередь: базовые и расширенные операции, их сложность.": "Стек - это структура данных, работающая по принципу LIFO (Last In, First Out). Базовые операции включают: push (добавление элемента на вершину стека), pop (удаление элемента с вершины), peek (просмотр верхнего элемента без удаления), и is_empty (проверка, пуст ли стек). Все базовые операции имеют сложность O(1). Расширенные операции, такие как поиск элемента в стеке, обычно имеют сложность O(n). Стек используется в алгоритмах обратной польской записи, реализации рекурсии, и управления памятью в вызовах функций.Очередь - это структура данных, работающая по принципу FIFO (First In, First Out). Базовые операции включают: enqueue (добавление элемента в конец очереди), dequeue (удаление элемента из начала очереди), peek (просмотр первого элемента без удаления), и is_empty (проверка, пуста ли очередь). Все базовые операции имеют сложность O(1). Расширенные операции, такие как поиск элемента в очереди, имеют сложность O(n). Очереди применяются в управлении задачами, симуляциях, алгоритмах ширинного поиска и буферах данных.",
            "Специфика реализации и скорости основных операций в очереди на базе массива и связанного списка.": "Очередь на базе массива: Реализована с использованием динамического массива. Операции enqueue (добавление в конец) и dequeue (удаление из начала) имеют сложность O(1) амортизированно, но могут быть O(n) при необходимости расширения массива. Доступ к элементам по индексу - O(1). Основная проблема - необходимость смещения элементов при удалении из начала, что может сделать dequeue O(n) в худшем случае.Очередь на базе связанного списка: Реализована с использованием двухсвязного списка. Операции enqueue (добавление в конец) и dequeue (удаление из начала) всегда имеют сложность O(1). Нет необходимости в смещении элементов, что делает операции более стабильными по времени. Однако доступ к произвольным элементам имеет сложность O(n), так как требуется последовательный обход списка. В целом, очередь на связанном списке более эффективна для операций enqueue и dequeue в стабильном времени, тогда как очередь на массиве может быть более эффективна для произвольного доступа к элементам.",
            "Связанные списки: однонаправленные и двунаправленные – принцип реализации. Сравнение скорости выполнения основных операций в связанных списках и в динамическом массиве.": "Однонаправленный связанный список: Состоит из узлов, каждый из которых содержит данные и ссылку на следующий узел. Реализуется классами, где каждый узел имеет атрибуты `data` и `next`. Основные операции включают добавление, удаление и поиск элементов. Добавление в начало - O(1), добавление в конец - O(n) без указателя на хвост, поиск - O(n), удаление - O(n).Двунаправленный связанный список: Состоит из узлов, каждый из которых содержит данные и ссылки на предыдущий и следующий узлы. Реализуется классами, где каждый узел имеет атрибуты `data`, `prev` и `next`. Основные операции включают добавление, удаление и поиск элементов. Добавление и удаление элементов на любом конце - O(1), поиск - O(n).Сравнение с динамическим массивом:1. Доступ по индексу: динамический массив - O(1), связанный список - O(n).2. Добавление в конец: динамический массив - O(1) амортизированно, O(n) в худшем случае; связанный список - O(1) с указателем на хвост.3. Удаление из начала: динамический массив - O(n) из-за необходимости смещения элементов, связанный список - O(1).4. Добавление/удаление в середине: динамический массив - O(n) из-за смещения элементов, связанный список - O(n) из-за поиска позиции. Связанные списки более эффективны для частых вставок и удалений, особенно в начале и конце, тогда как динамические массивы предпочтительны для доступа по индексу и итерации.",
            "Алгоритм обменной сортировки, сложность сортировки и возможности по ее улучшению.": """
        Алгоритм обменной сортировки, известный также как пузырьковая сортировка, работает следующим образом:

        1. Проходится по массиву, сравнивая каждую пару соседних элементов.
        2. Если элементы находятся в неправильном порядке, они меняются местами.
        3. Это повторяется до тех пор, пока массив не будет отсортирован.

        На каждом шаге самый большой элемент "всплывает" к концу массива, поэтому с каждым проходом можно рассматривать на один элемент меньше. Процесс продолжается до тех пор, пока не потребуется никаких обменов.

        Сложность сортировки:

        - В худшем случае, когда массив изначально отсортирован в обратном порядке, сложность алгоритма составляет O(n^2), где n — количество элементов в массиве.
        - В лучшем случае, когда массив уже отсортирован, сложность составляет O(n), так как требуется всего один проход для проверки.
        - Средняя сложность также O(n^2).

        Возможности по улучшению:

        1. **Оптимизация пузырьковой сортировки**: Можно улучшить пузырьковую сортировку, добавив флаг, который отмечает, произошли ли обмены во время прохода по массиву. Если в каком-то проходе обменов не было, массив уже отсортирован и можно прекратить выполнение.

        2. **Шейкерная сортировка**: Это улучшенная версия пузырьковой сортировки, в которой проходы выполняются попеременно слева направо и справа налево. Это позволяет быстрее перемещать элементы к их конечным позициям.

        3. **Использование других алгоритмов**: Пузырьковая сортировка неэффективна для сортировки больших массивов, поэтому лучше использовать более производительные алгоритмы, такие как сортировка слиянием или быстрая сортировка, которые имеют среднюю сложность O(n log n).

        Обменная сортировка проста в реализации и понимании, но из-за своей низкой производительности на больших наборах данных она практически не используется на практике.
        """,
            "Алгоритм сортировки выбором, сложность сортировки и возможности по ее улучшению.": """
        Алгоритм сортировки выбором (Selection Sort) работает следующим образом:

        1. Массив делится на две части: отсортированную и неотсортированную.
        2. На каждом шаге алгоритм находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
        3. После каждого прохода граница между отсортированной и неотсортированной частями сдвигается на один элемент вправо.
        4. Процесс повторяется, пока вся неотсортированная часть не станет пустой.

        Пример:

        Если у нас есть массив [5, 2, 9, 1, 5, 6], алгоритм сначала находит минимальный элемент (1) и перемещает его в начало массива, результат [1, 2, 9, 5, 5, 6]. Затем он ищет минимальный элемент среди оставшихся элементов (2) и оставляет его на месте. Продолжая этот процесс, массив становится отсортированным.

        Сложность сортировки:

        - В худшем случае сложность сортировки выбором составляет O(n^2), где n — количество элементов в массиве. Это связано с тем, что для каждого элемента необходимо выполнить n - 1 сравнений.
        - В лучшем случае сложность также O(n^2), поскольку алгоритм всегда проходит по всему неотсортированному массиву для поиска минимального элемента, независимо от его начального состояния.
        - Средняя сложность также O(n^2), что делает сортировку выбором неэффективной для больших массивов.

        Возможности по улучшению:

        1. **Двунаправленная сортировка выбором**: Вместо поиска только минимального элемента на каждом проходе, можно искать как минимальный, так и максимальный элементы и размещать их на соответствующих позициях. Это сократит количество проходов по массиву в два раза.

        2. **Оптимизация количества обменов**: Путем хранения индекса минимального элемента и выполнения обмена только один раз за проход, можно уменьшить количество обменов. Однако это не влияет на общую сложность алгоритма, но может сократить время выполнения на практике.

        3. **Использование других алгоритмов**: Сортировка выбором на больших наборах данных уступает более производительным алгоритмам, таким как быстрая сортировка или сортировка слиянием, которые имеют среднюю сложность O(n log n).

        Сортировка выбором проста в реализации и хорошо работает на небольших массивах или когда память ограничена, так как она выполняется на месте и не требует дополнительной памяти.
        """,

            "Алгоритм сортировки вставками, его сложность. Алгоритм быстрого поиска в отсортированном массиве. Сложность поиска в отсортированном и не отсортированном массиве.": "Сортировка вставками работает следующим образом: массив перебирается, и каждый элемент вставляется в уже отсортированную часть массива на своё место. Сложность сортировки вставками: худший и средний случаи - O(n^2), лучший случай - O(n) (если массив уже отсортирован). Быстрый поиск в отсортированном массиве осуществляется с помощью бинарного поиска, который делит массив пополам на каждом шаге и исключает половину, в которой точно нет искомого элемента. Сложность бинарного поиска - O(log n). Сложность поиска в массиве: в отсортированном массиве с использованием бинарного поиска - O(log n), в неотсортированном массиве с использованием линейного поиска - O(n). Отсортированные массивы значительно ускоряют поиск благодаря бинарному поиску, тогда как неотсортированные массивы требуют полного перебора элементов.",
            "Алгоритм сортировки Шелла, сложность сортировки и возможности по ее улучшению.": "Сортировка Шелла - это улучшенная версия сортировки вставками. Она использует несколько проходов и сравнивает элементы, находящиеся на определённом расстоянии друг от друга, которое уменьшается с каждым проходом. Алгоритм начинается с больших интервалов и постепенно их уменьшает, пока не дойдёт до 1, то есть до обычной сортировки вставками.  Сложность сортировки Шелла зависит от выбора последовательности интервалов (gap sequence). В худшем случае сложность варьируется от O(n^2) до O(n log^2 n), в среднем - O(n^(3/2)). На практике сортировка Шелла работает быстрее, чем O(n^2). Для улучшения алгоритма можно использовать разные последовательности интервалов, такие как последовательность Кнута или Седжвика. Эти последовательности обеспечивают более эффективное уменьшение интервалов и, соответственно, более быструю сортировку. Оптимальный выбор последовательности интервалов может значительно повысить производительность алгоритма.",
            "Алгоритм быстрой сортировки, сложность сортировки и возможности по ее улучшению.": "Быстрая сортировка (Quicksort) - это рекурсивный алгоритм, который делит массив на две части, основываясь на выбранном элементе (опорном элементе). Все элементы, меньшие опорного, перемещаются в левую часть, а большие - в правую. Затем процесс повторяется рекурсивно для каждой из частей.Сложность быстрой сортировки: в среднем случае - O(n log n), в худшем случае - O(n^2) (происходит, когда выбранный опорный элемент всегда оказывается наихудшим). Тем не менее, на практике быстрая сортировка обычно работает быстрее из-за эффективного использования кэша и малой константы в O(n log n).Для улучшения быстрой сортировки можно использовать:1. Выбор лучшего опорного элемента, например, медианы из трёх (первый, средний и последний элементы).2. Оптимизацию хвостовой рекурсии, чтобы уменьшить глубину рекурсивных вызовов.3. Переход на сортировку вставками для небольших подмассивов, так как она более эффективна для небольших данных.Эти улучшения помогают избежать худшего случая и ускоряют выполнение алгоритма на практике.",
            "Алгоритм сортировки слиянием, сложность сортировки.": "Сортировка слиянием - это рекурсивный алгоритм, который делит массив на две половины, сортирует каждую из них отдельно, а затем сливает отсортированные половины в один массив. Этот процесс повторяется рекурсивно, пока массив не будет отсортирован. Сложность сортировки слиянием в худшем, среднем и лучшем случае составляет O(n log n). Алгоритм стабилен, то есть сохраняет относительный порядок элементов с одинаковыми значениями. Основной недостаток сортировки слиянием - необходимость дополнительной памяти для хранения временных массивов, что делает её менее эффективной по использованию памяти по сравнению с быстрой сортировкой.",
            "Реализация двоичных деревьев в виде связанных объектов. Различные реализации рекурсивного обхода двоичных деревьев.": "Двоичное дерево реализуется с использованием классов, где каждый узел содержит значение и ссылки на левый и правый дочерние узлы. Основные виды рекурсивного обхода двоичных деревьев: 1. Прямой (preorder): сначала обрабатывается текущий узел, затем левое и правое поддерево. 2. Симметричный (inorder): сначала обрабатывается левое поддерево, затем текущий узел и правое поддерево. 3. Обратный (postorder): сначала обрабатываются левое и правое поддеревья, затем текущий узел. Эти методы обхода используются для различных задач, таких как поиск, вставка и удаление элементов в дереве.",
            "Двоичное дерево поиска – принципы реализации и логика реализации основных операций.": "Двоичное дерево поиска (BST) - это структура данных, в которой каждый узел имеет не более двух потомков. Узлы организованы так, что для каждого узла все элементы в левом поддереве меньше, а в правом поддереве больше, чем значение самого узла. Основные операции: 1. Вставка: начинается с корня, сравнивает значение с текущим узлом и рекурсивно перемещается в левое или правое поддерево, в зависимости от значения, до тех пор, пока не найдется пустое место для нового узла. 2. Поиск: аналогично вставке, сравнивает искомое значение с текущим узлом и рекурсивно перемещается в левое или правое поддерево, пока не найдет значение или не дойдет до конца дерева. 3. Удаление: если узел не имеет детей, он просто удаляется. Если есть один потомок, узел заменяется этим потомком. Если есть два потомка, узел заменяется наименьшим значением в правом поддереве (или наибольшим в левом поддереве), после чего удаляется найденное значение. Эти операции позволяют поддерживать упорядоченность элементов и обеспечивают эффективный доступ к данным.",
            "Двоичная куча – принципы реализации и логика реализации основных операций.": "Двоичная куча (heap) - это полное бинарное дерево, в котором каждый узел удовлетворяет свойству кучи: значение узла больше или равно (в случае максимальной кучи) или меньше или равно (в случае минимальной кучи) значений его потомков. Основные операции: 1. Вставка: новый элемент добавляется в конец кучи (поддерживая структуру полного дерева), затем выполняется операция всплытия (перемещение вверх), чтобы восстановить свойство кучи. 2. Удаление корня (обычно максимального или минимального элемента): корень заменяется последним элементом кучи, затем выполняется операция просеивания вниз (перемещение вниз), чтобы восстановить свойство кучи. 3. Построение кучи: массив преобразуется в кучу путём многократного выполнения операции просеивания вниз начиная с последнего нетерминального узла до корня. Двоичные кучи эффективны для реализации очередей с приоритетом и обеспечивают операции вставки и удаления с логарифмической сложностью O(log n).",
            "Абстрактный тип данных - ассоциативный массив и принцип его реализации на основе хэш-таблиц и хэш-функций.": "Ассоциативный массив (или словарь) - это структура данных, которая хранит пары ключ-значение и обеспечивает быстрый доступ к значениям по ключу. Хэш-таблица - это одна из реализаций ассоциативного массива, использующая хэш-функцию для вычисления индекса, по которому хранится значение. Хэш-функция принимает ключ и возвращает индекс массива, где хранится значение. Основные операции: 1. Вставка: ключ хэшируется для определения индекса, затем пара ключ-значение добавляется в соответствующую ячейку. Если ячейка занята (коллизия), используются методы разрешения коллизий, такие как цепочки (связывание) или открытая адресация. 2. Поиск: ключ хэшируется для нахождения индекса, затем возвращается значение из соответствующей ячейки. 3. Удаление: ключ хэшируется для нахождения индекса, затем пара ключ-значение удаляется из соответствующей ячейки. Хэш-таблицы обеспечивают амортизированную сложность O(1) для основных операций при хорошем распределении хэш-функций и эффективном разрешении коллизий.",
            "Общая схема построения хэш-функции и возможная роль в этой схеме хэш-функции multiply-add-and-divide. Принцип работы хэш-функции multiply-add-and-divide.": "Хэш-функция преобразует входные данные (ключи) в числовое значение (хэш), которое используется для индексации в хэш-таблице. Основная цель хэш-функции - обеспечить равномерное распределение хэшей по таблице, минимизируя коллизии. В общей схеме построения хэш-функции важно выбрать метод обработки ключей, который будет эффективно распределять значения. Хэш-функция multiply-add-and-divide (MAD) использует умножение, сложение и деление для достижения этой цели. Принцип работы MAD хэш-функции следующий: сначала ключ умножается на большое простое число, затем к результату добавляется определённое смещение, и, наконец, результат делится на размер хэш-таблицы с использованием операции взятия остатка. Эта последовательность операций помогает получить более равномерное распределение хэшей, что уменьшает вероятность коллизий и повышает эффективность хэш-таблицы. Важно правильно выбрать параметры для умножения и смещения, чтобы обеспечить хорошее распределение и избежать систематических ошибок.",
            "Полиномиальная хэш-функция – принцип работы, специфика эффективной реализации и специфика применения хэш-функции.": "Полиномиальная хэш-функция вычисляет хэш-значение ключа, рассматривая его как полином, где каждый символ ключа представляет коэффициент полинома. Принцип работы: каждый символ строки умножается на степень некоторого основания и результаты суммируются. Специфика эффективной реализации заключается в выборе подходящего основания и использования метода Горнера для оптимизации вычислений. Метод Горнера позволяет сократить количество умножений, что делает вычисление более эффективным. Полиномиальная хэш-функция широко применяется для хэширования строк, поскольку она обеспечивает хорошее распределение хэшей и минимизирует коллизии. Важно выбрать оптимальное основание и модуль для обеспечения равномерного распределения хэшей и предотвращения коллизий.",
            "Различные методы разрешения коллизий в хэш-таблицах.": "Коллизии в хэш-таблицах происходят, когда два ключа хэшируются в один и тот же индекс. Существуют различные методы разрешения коллизий: 1. Открытая адресация: при коллизии поиск нового индекса для размещения элемента. Варианты включают линейное пробирование (последовательный поиск следующей свободной ячейки), квадратичное пробирование (поиск на возрастающих квадратичных расстояниях) и двойное хеширование (использование второй хэш-функции для вычисления шага поиска). 2. Метод цепочек: каждая ячейка хэш-таблицы содержит указатель на связный список (цепочку), в котором хранятся все элементы, хэшируемые в один и тот же индекс. 3. Перехеширование: создание новой хэш-таблицы большего размера и перераспределение всех элементов, когда коэффициент заполнения превышает определённое значение. Выбор метода зависит от конкретных требований к производительности и памяти. Метод цепочек проще в реализации и хорошо работает при умеренной загрузке, тогда как открытая адресация более эффективна по памяти, но может ухудшить производительность при высоком коэффициенте заполнения.",
            "Написать программу с интерактивным консольным меню (т.е. вывод списка действий по цифрам) по вычислению площади круга (родительский класс), длины окружности (подкласс) и объема шара (подкласс) по задаваемому с клавиатуры радиусу. Содержание меню: 1. Вычислить площадь круга. 2. Вычислить длину окружности. 3. Вычислить объем шара.":
                """
                import math
        
                class Circle:
                    def __init__(self, radius):
                        self.radius = radius
        
                    def area(self):
                        return math.pi * (self.radius ** 2)
        
                class Circumference(Circle):
                    def __init__(self, radius):
                        super().__init__(radius)
        
                    def length(self):
                        return 2 * math.pi * self.radius
        
                class Sphere(Circle):
                    def __init__(self, radius):
                        super().__init__(radius)
        
                    def volume(self):
                        return (4/3) * math.pi * (self.radius ** 3)
        
                def main():
                    while True:
                        print("\nМеню:")
                        print("1. Вычислить площадь круга")
                        print("2. Вычислить длину окружности")
                        print("3. Вычислить объем шара")
                        print("4. Выйти")
        
                        choice = input("Выберите действие (1-4): ")
        
                        if choice == '1' or choice == '2' or choice == '3':
                            radius = float(input("Введите радиус: "))
        
                        if choice == '1':
                            circle = Circle(radius)
                            print(f"Площадь круга: {circle.area()}")
                        elif choice == '2':
                            circumference = Circumference(radius)
                            print(f"Длина окружности: {circumference.length()}")
                        elif choice == '3':
                            sphere = Sphere(radius)
                            print(f"Объем шара: {sphere.volume()}")
                        elif choice == '4':
                            print("Выход из программы.")
                            break
                        else:
                            print("Неверный выбор, попробуйте снова.")
        
                if __name__ == "__main__":
                    main()
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Поменять местами первый и последний элементы стека.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def swap_first_last(self):
                        if self.size() > 1:
                            self.stack[0], self.stack[-1] = self.stack[-1], self.stack[0]
        
                # Пример использования
                stack = Stack()
                stack.push(1)
                stack.push(2)
                stack.push(3)
                print("Стек до замены:", stack.stack)
                stack.swap_first_last()
                print("Стек после замены:", stack.stack)
                """,
            "Дан список А3, состоящий из четного количества элементов. Используя функцию (функции) высшего порядка разбейте его на списки В, С так, чтобы в одном были положительные элементы, а в другом отрицательные.":
                """
                def split_list(A3):
                    B = list(filter(lambda x: x > 0, A3))
                    C = list(filter(lambda x: x < 0, A3))
                    return B, C
        
                # Пример использования
                A3 = [1, -2, 3, -4, 5, -6]
                B, C = split_list(A3)
                print("Положительные элементы (B):", B)
                print("Отрицательные элементы (C):", C)
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Удалить элемент, который находится в середине стека, если нечетное число элементов, а если четное, то два средних.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def remove_middle(self):
                        n = self.size()
                        if n == 0:
                            return
                        mid = n // 2
                        if n % 2 == 0:
                            self.stack.pop(mid - 1)
                            self.stack.pop(mid - 1)
                        else:
                            self.stack.pop(mid)
        
                # Пример использования
                stack = Stack()
                stack.push(1)
                stack.push(2)
                stack.push(3)
                stack.push(4)
                stack.push(5)
                print("Стек до удаления среднего элемента:", stack.stack)
                stack.remove_middle()
                print("Стек после удаления среднего элемента:", stack.stack)
        
                stack = Stack()
                stack.push(1)
                stack.push(2)
                stack.push(3)
                stack.push(4)
                stack.push(5)
                stack.push(6)
                print("Стек до удаления средних элементов:", stack.stack)
                stack.remove_middle()
                print("Стек после удаления средних элементов:", stack.stack)
                """,
            "Создать класс Plane (самолетов), имеющий атрибуты: название самолета, количество пассажиров на борту, курс движения (откуда и куда). Методы: - определить загрузку самолета, если максимальная вместимость = 200 пассажиров; – определить все имена самолетов, летящих по одному маршруту; - определить среднюю загрузку всех самолетов.":
                """
                class Plane:
                    max_capacity = 200
        
                    def __init__(self, name, passengers, origin, destination):
                        self.name = name
                        self.passengers = passengers
                        self.origin = origin
                        self.destination = destination
        
                    def load_factor(self):
                        return self.passengers / self.max_capacity
        
                    @staticmethod
                    def planes_on_route(planes, origin, destination):
                        return [plane.name for plane in planes if plane.origin == origin and plane.destination == destination]
        
                    @staticmethod
                    def average_load(planes):
                        total_passengers = sum(plane.passengers for plane in planes)
                        return total_passengers / (len(planes) * Plane.max_capacity)
        
                # Пример использования
                plane1 = Plane("Boeing 737", 150, "NYC", "LA")
                plane2 = Plane("Airbus A320", 180, "NYC", "LA")
                plane3 = Plane("Boeing 747", 200, "Chicago", "Paris")
        
                planes = [plane1, plane2, plane3]
        
                print(f"Загрузка {plane1.name}: {plane1.load_factor() * 100:.2f}%")
                print("Самолеты на маршруте NYC-LA:", Plane.planes_on_route(planes, "NYC", "LA"))
                print(f"Средняя загрузка всех самолетов: {Plane.average_load(planes) * 100:.2f}%")
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Удалить каждый второй элемент стека.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def remove_every_second(self):
                        self.stack = [item for index, item in enumerate(self.stack) if index % 2 == 0]
        
                # Пример использования
                stack = Stack()
                stack.push(1)
                stack.push(2)
                stack.push(3)
                stack.push(4)
                stack.push(5)
                stack.push(6)
                print("Стек до удаления каждого второго элемента:", stack.stack)
                stack.remove_every_second()
                print("Стек после удаления каждого второго элемента:", stack.stack)
                """,
            "Дано предложение без знаков препинания. Превратить предложение в список слов. При помощи механизма map/filter/reduce отбросить у каждого слова последнюю букву и склеить в одну строку те обрезанные слова, длина которых больше 5.":
                """
                from functools import reduce
        
                # Пример предложения
                sentence = "Дано предложение без знаков препинания"
        
                # Превратить предложение в список слов
                words = sentence.split()
        
                # Отбросить у каждого слова последнюю букву
                trimmed_words = list(map(lambda word: word[:-1], words))
        
                # Оставить только те слова, длина которых больше 5
                filtered_words = list(filter(lambda word: len(word) > 5, trimmed_words))
        
                # Склеить слова в одну строку
                result = reduce(lambda x, y: x + y, filtered_words, "")
        
                print(result)
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Найти минимальный элемент стека и вставить после него '0'.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def insert_after_min(self):
                        if self.is_empty():
                            return
                        min_element = min(self.stack)
                        min_index = self.stack.index(min_element)
                        self.stack.insert(min_index + 1, 0)
        
                # Пример использования
                stack = Stack()
                stack.push(3)
                stack.push(1)
                stack.push(4)
                stack.push(1)
                stack.push(5)
                print("Стек до вставки '0':", stack.stack)
                stack.insert_after_min()
                print("Стек после вставки '0':", stack.stack)
                """,
            "Дан список S состоящий из N различных элементов. Вывести индексы четных элементов списка. Использовать встроенные функции высшего порядка.":
                """
                # Пример списка
                S = [3, 4, 7, 8, 10, 15, 18, 21]
        
                # Используем функцию enumerate для получения индексов и значений, filter для отбора четных элементов и map для получения индексов
                even_indices = list(map(lambda x: x[0], filter(lambda x: x[1] % 2 == 0, enumerate(S))))
        
                print(even_indices)
                """,
            "Реализовать декоратор с именем not_none, который генерирует исключительную ситуацию если декорируемая функция вернула значения None.":
                """
                def not_none(func):
                    def wrapper(*args, **kwargs):
                        result = func(*args, **kwargs)
                        if result is None:
                            raise ValueError("Функция вернула None")
                        return result
                    return wrapper
        
                # Пример использования
                @not_none
                def test_function(x):
                    if x > 0:
                        return x
                    else:
                        return None
        
                # Пример вызова
                try:
                    print(test_function(5))  # Вывод: 5
                    print(test_function(-1)) # Генерирует ValueError
                except ValueError as e:
                    print(e)
                """,
            "Создайте класс Speed (Скорость), имеющий атрибуты: value (значение), unit (единица измерения). При изменении единицы измерения значение должно соответственно меняться. Например, при переходе от км/ч к м/с и наоборот. Например, 20 км/ч = 5.56 м/с. Допустимые значения свойства unit: ‘м/с’, ‘км/ч’. Организуйте эту проверку. Продемонстрируйте работу с классом":
                """
                class Speed:
                    def __init__(self, value, unit):
                        self.value = value
                        self.unit = unit
        
                    @property
                    def unit(self):
                        return self._unit
        
                    @unit.setter
                    def unit(self, new_unit):
                        if new_unit not in ['м/с', 'км/ч']:
                            raise ValueError("Недопустимая единица измерения. Допустимые значения: 'м/с', 'км/ч'")
        
                        if hasattr(self, '_unit') and self._unit != new_unit:
                            if new_unit == 'м/с':
                                self.value = self.value / 3.6
                            elif new_unit == 'км/ч':
                                self.value = self.value * 3.6
        
                        self._unit = new_unit
        
                    def __str__(self):
                        return f"{self.value:.2f} {self.unit}"
        
                # Пример использования
                speed = Speed(20, 'км/ч')
                print(speed)  # Вывод: 20.00 км/ч
        
                speed.unit = 'м/с'
                print(speed)  # Вывод: 5.56 м/с
        
                speed.unit = 'км/ч'
                print(speed)  # Вывод: 20.00 км/ч
        
                try:
                    speed.unit = 'мили/ч'
                except ValueError as e:
                    print(e)  # Вывод: Недопустимая единица измерения. Допустимые значения: 'м/с', 'км/ч'
                """,
            "Реализовать декоратор с именем print_type, выводящий на печать тип значения, возвращаемого декорируемой функцией.":
                """
                def print_type(func):
                    def wrapper(*args, **kwargs):
                        result = func(*args, **kwargs)
                        print(f"Тип возвращаемого значения: {type(result)}")
                        return result
                    return wrapper
        
                # Пример использования
                @print_type
                def test_function(x):
                    return x
        
                # Пример вызова
                print(test_function(5))        # Вывод: Тип возвращаемого значения: <class 'int'> \n 5
                print(test_function("hello"))  # Вывод: Тип возвращаемого значения: <class 'str'> \n hello
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Удалить минимальный элемент стека.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def remove_minimum(self):
                        if self.is_empty():
                            return
                        min_element = min(self.stack)
                        self.stack.remove(min_element)
        
                # Пример использования
                stack = Stack()
                stack.push(3)
                stack.push(1)
                stack.push(4)
                stack.push(1)
                stack.push(5)
                print("Стек до удаления минимального элемента:", stack.stack)
                stack.remove_minimum()
                print("Стек после удаления минимального элемента:", stack.stack)
                """,
            "Задано положительное и отрицательное число в двоичной системе. Составить программу вычисления суммы этих чисел, используя функцию сложения чисел в двоичной системе счисления. Использовать рекурсию.":
                """
                def add_binary(a, b):
                    if not a:
                        return b
                    if not b:
                        return a
        
                    if a[-1] == '1' and b[-1] == '1':
                        return add_binary(add_binary(a[:-1], b[:-1]), '1') + '0'
                    elif a[-1] == '0' and b[-1] == '0':
                        return add_binary(a[:-1], b[:-1]) + '0'
                    else:
                        return add_binary(a[:-1], b[:-1]) + '1'
        
                # Преобразование двоичных строк в целые числа
                def binary_to_int(binary_str):
                    if binary_str[0] == '-':
                        return -int(binary_str[1:], 2)
                    else:
                        return int(binary_str, 2)
        
                # Преобразование целых чисел в двоичные строки
                def int_to_binary(num):
                    if num < 0:
                        return '-' + bin(num)[3:]
                    else:
                        return bin(num)[2:]
        
                # Пример использования
                positive_binary = "1010"  # 10 в десятичной системе
                negative_binary = "-110"  # -6 в десятичной системе
        
                # Преобразование в десятичные числа
                positive_int = binary_to_int(positive_binary)
                negative_int = binary_to_int(negative_binary)
        
                # Сложение чисел
                sum_int = positive_int + negative_int
        
                # Преобразование результата обратно в двоичную строку
                sum_binary = int_to_binary(sum_int)
        
                print(f"Сумма {positive_binary} и {negative_binary} в двоичной системе: {sum_binary}")
                """,
            "Вывести по убыванию количество всех предыдущих ремонтов машин 'Жигули'. Реализовать с помощью алгоритма сортировки слиянием.":
                """
                def merge_sort(arr):
                    if len(arr) <= 1:
                        return arr
                    mid = len(arr) // 2
                    left = merge_sort(arr[:mid])
                    right = merge_sort(arr[mid:])
                    return merge(left, right)
        
                def merge(left, right):
                    result = []
                    i = j = 0
                    while i < len(left) and j < len(right):
                        if left[i] > right[j]:
                            result.append(left[i])
                            i += 1
                        else:
                            result.append(right[j])
                            j += 1
                    result.extend(left[i:])
                    result.extend(right[j:])
                    return result
        
                # Пример данных
                repairs = {
                    "Жигули_1": 5,
                    "Жигули_2": 3,
                    "Жигули_3": 8,
                    "Жигули_4": 2
                }
        
                # Извлекаем количество ремонтов и сортируем по убыванию
                repair_counts = list(repairs.values())
                sorted_repairs = merge_sort(repair_counts)
        
                print("Количество ремонтов по убыванию:", sorted_repairs)
                """,
            "Написать программу с интерактивным консольным меню (т.е. вывод списка действий по цифрам) по удалению из списка (задаем с клавиатуры) элемента с задаваемым с клавиатуры индексом (например, m). При решении задачи необходимо использовать функцию map. Содержание меню: 1. Удалить элемент из списка и вывести итоговый список. 2. Удалить элемент из списка и вывести его номер(а).":
                """
                def remove_element(lst, index):
                    return list(map(lambda x: x[1], filter(lambda x: x[0] != index, enumerate(lst))))
        
                def main():
                    while True:
                        print("\nМеню:")
                        print("1. Удалить элемент из списка и вывести итоговый список")
                        print("2. Удалить элемент из списка и вывести его номер(а)")
                        print("3. Выйти")
        
                        choice = input("Выберите действие (1-3): ")
        
                        if choice == '1' or choice == '2':
                            lst = list(map(int, input("Введите список чисел через пробел: ").split()))
                            index = int(input("Введите индекс элемента для удаления: "))
        
                        if choice == '1':
                            new_lst = remove_element(lst, index)
                            print("Итоговый список:", new_lst)
                        elif choice == '2':
                            if 0 <= index < len(lst):
                                print("Удаленный элемент:", lst[index])
                            else:
                                print("Неверный индекс")
                        elif choice == '3':
                            print("Выход из программы.")
                            break
                        else:
                            print("Неверный выбор, попробуйте снова.")
        
                if __name__ == "__main__":
                    main()
                """,
            "Задание: построить базовый класс с указанными в таблице полями и методами: - конструктор; - функция, которая определяет «качество» объекта – Q по заданной формуле; - метод вывода информации об объекте. Построить дочерний класс (класс-потомок), который содержит: - дополнительное поле P; - функция, которая определяет «качество» объекта дочернего класса – Qp и перегружает функцию качества родительского класса (Q), выполняя вычисление по новой формуле.":
                """
                class Car:
                    def __init__(self, brand, power, seats):
                        self.brand = brand
                        self.power = power
                        self.seats = seats
        
                    def quality(self):
                        return 0.1 * self.power * self.seats
        
                    def display_info(self):
                        return f"Марка: {self.brand}, Мощность: {self.power} кВт, Число мест: {self.seats}, Качество: {self.quality()}"
        
                class CarWithYear(Car):
                    def __init__(self, brand, power, seats, year):
                        super().__init__(brand, power, seats)
                        self.year = year
        
                    def quality(self):
                        base_quality = super().quality()
                        current_year = 2024
                        return base_quality - 1.5 * (current_year - self.year)
        
                    def display_info(self):
                        base_info = super().display_info()
                        return f"{base_info}, Год выпуска: {self.year}, Качество с учетом года: {self.quality()}"
        
                # Пример использования
                car1 = Car("Toyota", 150, 5)
                print(car1.display_info())
        
                car2 = CarWithYear("Toyota", 150, 5, 2015)
                print(car2.display_info())
                """,
            "Написать программу с интерактивным консольным меню (т.е. вывод списка действий по цифрам) по вычислению площади прямоугольника (родительский класс), и периметра прямоугольника (дочерний класс) по задаваемой с клавиатуры длине сторон прямоугольника. Содержание меню: 1. Вычислить площадь прямоугольника. 2. Вычислить периметр прямоугольника.":
                """
                class Rectangle:
                    def __init__(self, length, width):
                        self.length = length
                        self.width = width
        
                    def area(self):
                        return self.length * self.width
        
                class RectangleWithPerimeter(Rectangle):
                    def __init__(self, length, width):
                        super().__init__(length, width)
        
                    def perimeter(self):
                        return 2 * (self.length + self.width)
        
                def main():
                    while True:
                        print("\nМеню:")
                        print("1. Вычислить площадь прямоугольника")
                        print("2. Вычислить периметр прямоугольника")
                        print("3. Выйти")
        
                        choice = input("Выберите действие (1-3): ")
        
                        if choice == '1' or choice == '2':
                            length = float(input("Введите длину прямоугольника: "))
                            width = float(input("Введите ширину прямоугольника: "))
        
                        if choice == '1':
                            rectangle = Rectangle(length, width)
                            print(f"Площадь прямоугольника: {rectangle.area()}")
                        elif choice == '2':
                            rectangle_with_perimeter = RectangleWithPerimeter(length, width)
                            print(f"Периметр прямоугольника: {rectangle_with_perimeter.perimeter()}")
                        elif choice == '3':
                            print("Выход из программы.")
                            break
                        else:
                            print("Неверный выбор, попробуйте снова.")
        
                if __name__ == "__main__":
                    main()
                """,
            "Дан кольцевой список с перечнем товаров. Выбрать все товары, изготовленные фирмой Bosh и создать из них новый список.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class CircularLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                            self.head.next = self.head
                        else:
                            temp = self.head
                            while temp.next != self.head:
                                temp = temp.next
                            temp.next = new_node
                            new_node.next = self.head
        
                    def get_bosh_products(self):
                        bosh_products = []
                        if not self.head:
                            return bosh_products
                        temp = self.head
                        while True:
                            if "Bosh" in temp.data:
                                bosh_products.append(temp.data)
                            temp = temp.next
                            if temp == self.head:
                                break
                        return bosh_products
        
                # Пример использования
                circular_list = CircularLinkedList()
                circular_list.append("Bosh Washing Machine")
                circular_list.append("Samsung TV")
                circular_list.append("Bosh Refrigerator")
                circular_list.append("LG Microwave")
                circular_list.append("Bosh Dishwasher")
        
                bosh_products = circular_list.get_bosh_products()
                print("Товары, изготовленные фирмой Bosh:", bosh_products)
                """,
            "С помощью функции reduce() вычислить двойной факториал заданного натурального числа n (для четного или нечетного n).":
                """
                from functools import reduce
        
                def double_factorial(n):
                    if n <= 0:
                        return 1
                    return reduce(lambda x, y: x * y, range(n, 0, -2))
        
                # Пример использования
                n = 7
                print(f"Двойной факториал {n}!! = {double_factorial(n)}")
        
                n = 8
                print(f"Двойной факториал {n}!! = {double_factorial(n)}")
                """,
            "Создайте класс Заказ(Order), у которого есть свойства код_товара(code), цена(price), количество(count) и методы __init__ и __str__. Создайте 2 класса-потомка: Опт(Opt) и Розница(Retail). В этих классах создайте методы __init__, __str__ и сумма_заказа (summa), позволяющий узнать стоимость заказа. Для опта стоимость единицы товара составляет 95% от цены, а при покупке более 500 штук – 90% цены. В розницу стоимость единицы товара составляет 100% цены. Стоимость заказа равна произведению цены на количество. Создайте список, содержащий по 2 объекта каждого класса (Order, Opt, Retail). Для этого списка: • выведите информацию о каждом объекте с помощью метода __str__; • найдите общую стоимость заказов для объектов Opt и Retail.":
                """
                class Order:
                    def __init__(self, code, price, count):
                        self.code = code
                        self.price = price
                        self.count = count
        
                    def __str__(self):
                        return f"Order(code: {self.code}, price: {self.price}, count: {self.count})"
        
                class Opt(Order):
                    def __init__(self, code, price, count):
                        super().__init__(code, price, count)
        
                    def summa(self):
                        if self.count > 500:
                            return self.count * self.price * 0.90
                        else:
                            return self.count * self.price * 0.95
        
                    def __str__(self):
                        return f"Opt(code: {self.code}, price: {self.price}, count: {self.count}, total: {self.summa()})"
        
                class Retail(Order):
                    def __init__(self, code, price, count):
                        super().__init__(code, price, count)
        
                    def summa(self):
                        return self.count * self.price
        
                    def __str__(self):
                        return f"Retail(code: {self.code}, price: {self.price}, count: {self.count}, total: {self.summa()})"
        
                # Создание списка с объектами
                orders = [
                    Order("001", 100, 10),
                    Order("002", 200, 20),
                    Opt("003", 100, 300),
                    Opt("004", 100, 600),
                    Retail("005", 50, 30),
                    Retail("006", 75, 40)
                ]
        
                # Вывод информации о каждом объекте
                for order in orders:
                    print(order)
        
                # Общая стоимость заказов для объектов Opt и Retail
                total_sum = sum(order.summa() for order in orders if isinstance(order, (Opt, Retail)))
                print(f"Общая стоимость заказов для объектов Opt и Retail: {total_sum}")
                """,
            "Создать класс Деньги для работы с денежными суммами. Число должно быть представлено списком, состоящим из рублей и копеек. Реализовать сложение, вычитание, деление сумм, деление денежных сумм.":
                """
                class Money:
                    def __init__(self, rubles, kopeks):
                        self.rubles = rubles
                        self.kopeks = kopeks
                        self.normalize()
        
                    def normalize(self):
                        if self.kopeks >= 100:
                            self.rubles += self.kopeks // 100
                            self.kopeks = self.kopeks % 100
                        elif self.kopeks < 0:
                            self.rubles -= (-self.kopeks) // 100 + 1
                            self.kopeks = 100 - (-self.kopeks) % 100
        
                    def __add__(self, other):
                        return Money(self.rubles + other.rubles, self.kopeks + other.kopeks)
        
                    def __sub__(self, other):
                        return Money(self.rubles - other.rubles, self.kopeks - other.kopeks)
        
                    def __truediv__(self, divisor):
                        total_kopeks = (self.rubles * 100 + self.kopeks) / divisor
                        return Money(int(total_kopeks // 100), int(total_kopeks % 100))
        
                    def __floordiv__(self, divisor):
                        total_kopeks = (self.rubles * 100 + self.kopeks) // divisor
                        return Money(int(total_kopeks // 100), int(total_kopeks % 100))
        
                    def __str__(self):
                        return f"{self.rubles} руб. {self.kopeks} коп."
        
                # Пример использования
                money1 = Money(10, 150)
                money2 = Money(5, 75)
        
                print(f"Сумма: {money1 + money2}")
                print(f"Разность: {money1 - money2}")
                print(f"Деление суммы на 2: {money1 / 2}")
                print(f"Целочисленное деление суммы на 2: {money1 // 2}")
                """,
            "Дан кольцевой список из 20 фамилий студентов. Разбить студентов на 2 группы по 10 человек. Во вторую группу попадает каждый 11-й человек.": """
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.head.next = self.head
        else:
            temp = self.head
            while temp.next != self.head:
                temp = temp.next
            temp.next = new_node
            new_node.next = self.head

    def split_groups(self):
        group1 = []
        group2 = []
        temp = self.head
        count = 1
        total_count = 0

        while total_count < 20:  # Должно быть ровно 20 студентов
            if count % 11 == 0:
                group2.append(temp.data)
            else:
                group1.append(temp.data)
            temp = temp.next
            count += 1
            total_count += 1

        return group1, group2

# Пример использования
students = ["Student1", "Student2", "Student3", "Student4", "Student5", "Student6", "Student7", "Student8", "Student9",
            "Student10", "Student11", "Student12", "Student13", "Student14", "Student15", "Student16", "Student17", "Student18",
            "Student19", "Student20"]

circular_list = CircularLinkedList()
for student in students:
    circular_list.append(student)

group1, group2 = circular_list.split_groups()
print("Группа 1:", group1)
print("Группа 2:", group2)
""",
            "Составить программу для нахождения числа, которое образуется из данного натурального числа при записи его цифр в обратном порядке. Например, для числа 1234 получаем результат 4321. Использовать рекурсию.":
                """
                def reverse_number(n, reversed_n=0):
                    if n == 0:
                        return reversed_n
                    else:
                        return reverse_number(n // 10, reversed_n * 10 + n % 10)
        
                # Пример использования
                number = 1234
                reversed_number = reverse_number(number)
                print(f"Обратное число для {number} является {reversed_number}")
                """,
            "Создать класс стек. Использовать способ реализации стека через list. Сформировать стек с элементами - строками. Прочитать три нижних элемента стека и поменять местами верхний и нижний элементы.":
                """
                class Stack:
                    def __init__(self):
                        self.stack = []
        
                    def push(self, item):
                        self.stack.append(item)
        
                    def pop(self):
                        if not self.is_empty():
                            return self.stack.pop()
                        return None
        
                    def peek(self):
                        if not self.is_empty():
                            return self.stack[-1]
                        return None
        
                    def is_empty(self):
                        return len(self.stack) == 0
        
                    def size(self):
                        return len(self.stack)
        
                    def get_bottom_three(self):
                        if self.size() >= 3:
                            return self.stack[:3]
                        return self.stack
        
                    def swap_top_bottom(self):
                        if self.size() > 1:
                            self.stack[0], self.stack[-1] = self.stack[-1], self.stack[0]
        
                # Пример использования
                stack = Stack()
                stack.push("string1")
                stack.push("string2")
                stack.push("string3")
                stack.push("string4")
                stack.push("string5")
        
                print("Стек до изменений:", stack.stack)
                bottom_three = stack.get_bottom_three()
                print("Три нижних элемента стека:", bottom_three)
                stack.swap_top_bottom()
                print("Стек после замены верхнего и нижнего элементов:", stack.stack)
                """,
            "Дан список А3, состоящий из четного количества элементов. Используя функцию(функции) высшего порядка разбейте его на списки В, С так, чтобы в одном были положительные элементы, а в другом отрицательные.":
                """
                def split_list(A3):
                    B = list(filter(lambda x: x > 0, A3))
                    C = list(filter(lambda x: x < 0, A3))
                    return B, C
        
                # Пример использования
                A3 = [1, -2, 3, -4, 5, -6, 7, -8]
                B, C = split_list(A3)
                print("Положительные элементы (B):", B)
                print("Отрицательные элементы (C):", C)
                """,
            "Создайте класс Студент, имеющий: закрытый атрибут Имя – строка, содержащая фамилию; метод __init__. При создании объекта указывается имя, список Дисциплины пустой; закрытый атрибут Дисциплины – словарь сданных дисциплин. Ключом является название дисциплины, значением – оценка. • метод put добавляет новую дисциплину в атрибут Дисциплины. Параметрами метода являются название дисциплины и оценка; • свойство Сдано возвращает список названий сданных дисциплин; Создайте экземпляр класса, продемонстрируйте работу с атрибутами, методами и свойствами.":
                """
                class Student:
                    def __init__(self, name):
                        self.__name = name
                        self.__disciplines = {}
        
                    def put(self, discipline, grade):
                        self.__disciplines[discipline] = grade
        
                    @property
                    def Сдано(self):
                        return list(self.__disciplines.keys())
        
                    def __str__(self):
                        return f"Студент: {self.__name}, Дисциплины: {self.__disciplines}"
        
                # Пример использования
                student = Student("Иванов")
                print(student)  # Студент: Иванов, Дисциплины: {}
        
                student.put("Математика", 5)
                student.put("Физика", 4)
                print(student)  # Студент: Иванов, Дисциплины: {'Математика': 5, 'Физика': 4}
        
                print("Сданные дисциплины:", student.Сдано)  # Сданные дисциплины: ['Математика', 'Физика']
                """,
            "Дан список S состоящий из N различных элементов. Вывести индексы четных элементов списка. Использовать функции высшего порядка.":
                """
                # Пример списка
                S = [3, 4, 7, 8, 10, 15, 18, 21]
        
                # Используем функцию enumerate для получения индексов и значений,
                # filter для отбора четных элементов и map для получения индексов
                even_indices = list(map(lambda x: x[0], filter(lambda x: x[1] % 2 == 0, enumerate(S))))
        
                print(even_indices)
                """,
            "Дан однонаправленный связный список. Вставить элемент после n-го элемента списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def insert_after(self, n, data):
                        current = self.head
                        count = 0
                        while current and count < n:
                            current = current.next
                            count += 1
                        if current:
                            new_node = Node(data)
                            new_node.next = current.next
                            current.next = new_node
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                sll = SinglyLinkedList()
                sll.append(1)
                sll.append(2)
                sll.append(3)
                sll.append(4)
        
                print("Список до вставки:")
                sll.display()
        
                sll.insert_after(2, 5)  # Вставить 5 после 3-го элемента (индекса 2)
        
                print("Список после вставки:")
                sll.display()
                """,
            "Создать декоратор tol(len, fill) с параметрами len и fill. Декоратор превращает результат декорируемой функции в список состоящий из len элементов. Если исходная функция возвращает меньше заданного количества элементов, то оставшиеся места заполняются значениями fill, в случае, если количество возвращаемых элементов больше len, то хвост последовательности отбрасывается.":
                """
                def tol(length, fill):
                    def decorator(func):
                        def wrapper(*args, **kwargs):
                            result = func(*args, **kwargs)
                            if len(result) < length:
                                result += [fill] * (length - len(result))
                            return result[:length]
                        return wrapper
                    return decorator
        
                # Пример использования
                @tol(5, 0)
                def generate_list(n):
                    return list(range(n))
        
                # Функция вернет [0, 1, 2] и декоратор преобразует ее в [0, 1, 2, 0, 0]
                print(generate_list(3))  # Вывод: [0, 1, 2, 0, 0]
        
                # Функция вернет [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] и декоратор преобразует ее в [0, 1, 2, 3, 4]
                print(generate_list(10))  # Вывод: [0, 1, 2, 3, 4]
                """,
            "Реализовать однонаправленный связанный список (реализовать класс для элементов списка). Преобразовать строку 'Eeny, meeny, miney, moe; Catch a tiger by his toe.' в связный список символов строки и удалить из него все элементы содержащие гласные буквы.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def remove_vowels(self):
                        vowels = "AEIOUaeiou"
                        current = self.head
                        prev = None
                        while current:
                            if current.data in vowels:
                                if prev:
                                    prev.next = current.next
                                else:
                                    self.head = current.next
                            else:
                                prev = current
                            current = current.next
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                string = 'Eeny, meeny, miney, moe; Catch a tiger by his toe.'
                sll = SinglyLinkedList()
                for char in string:
                    sll.append(char)
        
                print("Список до удаления гласных:")
                sll.display()
        
                sll.remove_vowels()
        
                print("Список после удаления гласных:")
                sll.display()
                """,
            "Создать базовый класс по следующей предметной области. Известны оклад (зарплата) и ставка процента подоходного налога. Определить размер подоходного налога и сумму, получаемую на руки. Исходными данными являются величина оклада (переменная oklad, выражаемая числом) и ставка подоходного налога (переменная procent, выражаемая числом). Размер налога (переменная nalog) определяется как oklad∗procent/100, а сумма, получаемая на руки (переменная summa) — как oklad-nalog.": """
        class Salary:
            def __init__(self, oklad, procent):
                self.oklad = oklad
                self.procent = procent

            @property
            def nalog(self):
                return self.oklad * self.procent / 100

            @property
            def summa(self):
                return self.oklad - self.nalog

        # Пример использования:
        # salary = Salary(1000, 13)
        # print(f"Налог: {salary.nalog}")
        # print(f"Сумма на руки: {salary.summa}")
        """,
            "Вывести по убыванию количество всех предыдущих ремонтов машин 'Жигули'. Осуществить алгоритм сортировки слиянием.":
                """
                def merge_sort(arr):
                    if len(arr) <= 1:
                        return arr
                    mid = len(arr) // 2
                    left = merge_sort(arr[:mid])
                    right = merge_sort(arr[mid:])
                    return merge(left, right)
        
                def merge(left, right):
                    result = []
                    i = j = 0
                    while i < len(left) and j < len(right):
                        if left[i] > right[j]:
                            result.append(left[i])
                            i += 1
                        else:
                            result.append(right[j])
                            j += 1
                    result.extend(left[i:])
                    result.extend(right[j:])
                    return result
        
                # Пример данных о ремонтах машин Жигули
                repairs = {
                    "Жигули_1": 5,
                    "Жигули_2": 3,
                    "Жигули_3": 8,
                    "Жигули_4": 2,
                    "Жигули_5": 7
                }
        
                # Извлекаем количество ремонтов и сортируем по убыванию
                repair_counts = list(repairs.values())
                sorted_repairs = merge_sort(repair_counts)
        
                print("Количество ремонтов по убыванию:", sorted_repairs)
                """,
            "Описать рекурсивные функции Fact(N) и Fact2(N) вещественного типа, вычисляющие значения факториала N! и двойного факториала N!! соответственно (N > 0 — параметр целого типа).":
                """
                def Fact(N):
                    if N <= 1:
                        return 1.0
                    return N * Fact(N - 1)
        
                def Fact2(N):
                    if N <= 1:
                        return 1.0
                    return N * Fact2(N - 2)
        
                # Пример использования
                N = 5
                print(f"Факториал {N}!: {Fact(N)}")
                print(f"Двойной факториал {N}!!: {Fact2(N)}")
                """,
            "Дан однонаправленный связный список. Удалить каждый второй элемент списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def remove_every_second(self):
                        if not self.head:
                            return
                        current = self.head
                        while current and current.next:
                            current.next = current.next.next
                            current = current.next
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                sll = SinglyLinkedList()
                for i in range(1, 11):  # Добавляем элементы 1-10
                    sll.append(i)
        
                print("Список до удаления каждого второго элемента:")
                sll.display()
        
                sll.remove_every_second()
        
                print("Список после удаления каждого второго элемента:")
                sll.display()
                """,
            "Создать иерархию классов для фруктов, продающихся в магазине. Иерархия должна содержать не менее 3 классов. Объекты должны содержать не менее 3-х атрибутов. Часть атрибутов должна быть защищена от изменения. Необходимо заполнить список представителями всех классов (всего 5 объектов) и продемонстрировать созданную защиту.":
                """
                class Fruit:
                    def __init__(self, name, price_per_kg, quantity_kg):
                        self._name = name
                        self._price_per_kg = price_per_kg
                        self._quantity_kg = quantity_kg
        
                    def display_info(self):
                        return f"Фрукт: {self._name}, Цена за кг: {self._price_per_kg} руб., Количество: {self._quantity_kg} кг"
        
                class Apple(Fruit):
                    def __init__(self, name, price_per_kg, quantity_kg, variety):
                        super().__init__(name, price_per_kg, quantity_kg)
                        self.__variety = variety
        
                    def display_info(self):
                        base_info = super().display_info()
                        return f"{base_info}, Сорт: {self.__variety}"
        
                class Banana(Fruit):
                    def __init__(self, name, price_per_kg, quantity_kg, origin):
                        super().__init__(name, price_per_kg, quantity_kg)
                        self.__origin = origin
        
                    def display_info(self):
                        base_info = super().display_info()
                        return f"{base_info}, Страна происхождения: {self.__origin}"
        
                class Orange(Fruit):
                    def __init__(self, name, price_per_kg, quantity_kg, is_seedless):
                        super().__init__(name, price_per_kg, quantity_kg)
                        self.__is_seedless = is_seedless
        
                    def display_info(self):
                        base_info = super().display_info()
                        seedless_info = "без косточек" if self.__is_seedless else "с косточками"
                        return f"{base_info}, {seedless_info}"
        
                # Пример использования
                fruit_list = [
                    Apple("Яблоко", 100, 5, "Голден"),
                    Apple("Яблоко", 90, 3, "Антоновка"),
                    Banana("Банан", 120, 10, "Эквадор"),
                    Orange("Апельсин", 150, 8, True),
                    Orange("Апельсин", 140, 7, False)
                ]
        
                for fruit in fruit_list:
                    print(fruit.display_info())
        
                # Попытка изменения защищенного атрибута
                try:
                    fruit_list[0]._price_per_kg = 50  # Попытка изменить защищенный атрибут
                except AttributeError as e:
                    print(f"Ошибка при изменении защищенного атрибута: {e}")
        
                print("\nСписок после попытки изменения:")
                for fruit in fruit_list:
                    print(fruit.display_info())
                """,
            "Расположить по алфавиту имена владельцев и, соответственно, вывести информацию об их машинах. Использовать алгоритм сортировки выбором.":
                """
                def selection_sort(arr):
                    n = len(arr)
                    for i in range(n):
                        min_index = i
                        for j in range(i + 1, n):
                            if arr[j][0] < arr[min_index][0]:
                                min_index = j
                        arr[i], arr[min_index] = arr[min_index], arr[i]
        
                # Пример данных
                owners_cars = [
                    ("Иванов", "Toyota Camry"),
                    ("Петров", "Ford Focus"),
                    ("Сидоров", "Honda Civic"),
                    ("Алексеев", "BMW X5"),
                    ("Михайлов", "Audi A6")
                ]
        
                # Сортировка по именам владельцев
                selection_sort(owners_cars)
        
                # Вывод информации об отсортированных владельцах и их машинах
                for owner, car in owners_cars:
                    print(f"Владелец: {owner}, Машина: {car}")
                """,
            "Описать рекурсивную функцию Root(a, b, ε), которая методом деления отрезка пополам находит с точностью ε корень уравнения f(x) = 0 на отрезке [а, b] (считать, что ε > 0, а < b, f(a) – f(b) < 0 и f(x) — непрерывная и монотонная на отрезке [а, b] функция).":
                """
                def f(x):
                    return x**2 - 4  # Пример функции, где корень уравнения x^2 - 4 = 0
        
                def Root(a, b, epsilon):
                    if b - a < epsilon:
                        return (a + b) / 2
                    mid = (a + b) / 2
                    if f(a) * f(mid) < 0:
                        return Root(a, mid, epsilon)
                    else:
                        return Root(mid, b, epsilon)
        
                # Пример использования
                a, b, epsilon = 0, 3, 0.001
                root = Root(a, b, epsilon)
                print(f"Корень уравнения на отрезке [{a}, {b}] с точностью {epsilon}: {root}")
                """,
            "Дан одномерный массив целых чисел размерности n, заданных случайным образом из интервала от -20 до 20. Если сумма отрицательных элементов по модулю превышает сумму положительных, то отсортировать массив по возрастанию, иначе – по убыванию. Реализовать сортировку алгоритмом сортировки выбором.":
                """
                import random
        
                def selection_sort(arr, ascending=True):
                    n = len(arr)
                    for i in range(n):
                        idx = i
                        for j in range(i + 1, n):
                            if (ascending and arr[j] < arr[idx]) or (not ascending and arr[j] > arr[idx]):
                                idx = j
                        arr[i], arr[idx] = arr[idx], arr[i]
        
                # Генерация случайного массива
                n = 10
                array = [random.randint(-20, 20) for _ in range(n)]
                print("Исходный массив:", array)
        
                # Вычисление сумм положительных и отрицательных элементов
                sum_positive = sum(x for x in array if x > 0)
                sum_negative = sum(-x for x in array if x < 0)
        
                # Определение направления сортировки
                if sum_negative > sum_positive:
                    print("Сумма отрицательных элементов по модулю превышает сумму положительных. Сортировка по возрастанию.")
                    selection_sort(array, ascending=True)
                else:
                    print("Сумма положительных элементов больше или равна сумме отрицательных по модулю. Сортировка по убыванию.")
                    selection_sort(array, ascending=False)
        
                print("Отсортированный массив:", array)
                """,
            "Создать декоратор dec(a, b) с параметрами a и b. Декоратор увеличивает результат декорируемой функции, которая вычисляет сумму произвольного количества чисел, на 'a' элементов при условии положительного значения суммы. Если исходная функция возвращает отрицательное значение суммы, то декоратор уменьшает результат декорируемой функции на значение 'b'.":
                """
                def dec(a, b):
                    def decorator(func):
                        def wrapper(*args, **kwargs):
                            result = func(*args, **kwargs)
                            if result > 0:
                                return result + a
                            else:
                                return result - b
                        return wrapper
                    return decorator
        
                # Пример использования
                @dec(5, 3)
                def sum_numbers(*numbers):
                    return sum(numbers)
        
                # Функция вернет сумму чисел и декоратор изменит ее в зависимости от результата
                print(sum_numbers(1, 2, 3))  # Сумма 6, декоратор увеличивает на 5, результат 11
                print(sum_numbers(-1, -2, -3))  # Сумма -6, декоратор уменьшает на 3, результат -9
                """,
            "Дан одномерный массив целых чисел размерности n, заданных случайным образом из интервала от -20 до 20. Если в массиве есть отрицательные элементы, то отсортировать массив по возрастанию, иначе - по убыванию. Реализовать сортировку алгоритмом сортировки вставками.":
                """
                import random
        
                def insertion_sort(arr, ascending=True):
                    for i in range(1, len(arr)):
                        key = arr[i]
                        j = i - 1
                        while j >= 0 and ((ascending and arr[j] > key) or (not ascending and arr[j] < key)):
                            arr[j + 1] = arr[j]
                            j -= 1
                        arr[j + 1] = key
        
                # Генерация случайного массива
                n = 10
                array = [random.randint(-20, 20) for _ in range(n)]
                print("Исходный массив:", array)
        
                # Определение наличия отрицательных элементов
                contains_negative = any(x < 0 for x in array)
        
                # Сортировка массива
                if contains_negative:
                    print("В массиве есть отрицательные элементы. Сортировка по возрастанию.")
                    insertion_sort(array, ascending=True)
                else:
                    print("В массиве нет отрицательных элементов. Сортировка по убыванию.")
                    insertion_sort(array, ascending=False)
        
                print("Отсортированный массив:", array)
                """,
            "Дан список целых чисел. При помощи механизма map/filter/reduce рассчитать остаток от деления на 7 для каждого из чисел списка и получить произведение тех остатков, величина которых больше 4.":
                """
                from functools import reduce
        
                # Пример списка
                numbers = [14, 15, 21, 28, 35, 45, 50, 63, 77]
        
                # Рассчитать остаток от деления на 7 для каждого из чисел списка
                remainders = list(map(lambda x: x % 7, numbers))
        
                # Отфильтровать остатки, величина которых больше 4
                filtered_remainders = list(filter(lambda x: x > 4, remainders))
        
                # Получить произведение отфильтрованных остатков
                result = reduce(lambda x, y: x * y, filtered_remainders, 1)
        
                print(f"Результат: {result}")
                """,
            "Дан одномерный массив целых чисел размерности n, заданных случайным образом из интервала от 0 до 100. Если количество четных элементов, стоящих на нечетных местах, превышает количество нечетных элементов, стоящих на четных местах, то отсортировать массив по возрастанию, иначе по убыванию. Реализовать алгоритм сортировки слиянием.":
                """
                import random
        
                def merge_sort(arr, ascending=True):
                    if len(arr) <= 1:
                        return arr
        
                    mid = len(arr) // 2
                    left = merge_sort(arr[:mid], ascending)
                    right = merge_sort(arr[mid:], ascending)
        
                    return merge(left, right, ascending)
        
                def merge(left, right, ascending):
                    result = []
                    while left and right:
                        if (ascending and left[0] <= right[0]) or (not ascending and left[0] >= right[0]):
                            result.append(left.pop(0))
                        else:
                            result.append(right.pop(0))
        
                    result.extend(left if left else right)
                    return result
        
                # Генерация случайного массива
                n = 10
                array = [random.randint(0, 100) for _ in range(n)]
                print("Исходный массив:", array)
        
                # Подсчет количества четных на нечетных местах и нечетных на четных местах
                even_on_odd = sum(1 for i in range(1, n, 2) if array[i] % 2 == 0)
                odd_on_even = sum(1 for i in range(0, n, 2) if array[i] % 2 != 0)
        
                # Сортировка массива в зависимости от условий
                if even_on_odd > odd_on_even:
                    print("Количество четных элементов на нечетных местах больше. Сортировка по возрастанию.")
                    sorted_array = merge_sort(array, ascending=True)
                else:
                    print("Количество нечетных элементов на четных местах больше или равно. Сортировка по убыванию.")
                    sorted_array = merge_sort(array, ascending=False)
        
                print("Отсортированный массив:", sorted_array)
                """,
            "Реализовать декоратор с именем not_sum, который генерирует исключительную ситуацию, если декорируемая функция вернула отрицательное значение суммы трех чисел.":
                """
                def not_sum(func):
                    def wrapper(*args, **kwargs):
                        result = func(*args, **kwargs)
                        if result < 0:
                            raise ValueError("Сумма трех чисел отрицательная")
                        return result
                    return wrapper
        
                # Пример использования
                @not_sum
                def sum_three_numbers(a, b, c):
                    return a + b + c
        
                # Пример вызова
                try:
                    print(sum_three_numbers(1, 2, 3))  # Вывод: 6
                    print(sum_three_numbers(-5, 2, 1)) # Исключение: Сумма трех чисел отрицательная
                except ValueError as e:
                    print(e)
                """,
            "Дано два однонаправленных связных списка. Создать список, содержащий элементы общие для двух списков.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                def find_common_elements(list1, list2):
                    elements1 = set()
                    current = list1.head
                    while current:
                        elements1.add(current.data)
                        current = current.next
        
                    common_elements = SinglyLinkedList()
                    current = list2.head
                    while current:
                        if current.data in elements1:
                            common_elements.append(current.data)
                        current = current.next
        
                    return common_elements
        
                # Пример использования
                list1 = SinglyLinkedList()
                list1.append(1)
                list1.append(2)
                list1.append(3)
                list1.append(4)
                list1.append(5)
        
                list2 = SinglyLinkedList()
                list2.append(3)
                list2.append(4)
                list2.append(5)
                list2.append(6)
                list2.append(7)
        
                print("Список 1:")
                list1.display()
        
                print("Список 2:")
                list2.display()
        
                common_elements_list = find_common_elements(list1, list2)
        
                print("Общие элементы:")
                common_elements_list.display()
                """,
            "Дан список целых чисел. При помощи механизма map/filter/reduce рассчитать остаток от деления на 17 для каждого из чисел списка и получить произведение тех остатков, величина которых меньше 7.":
                """
                from functools import reduce
        
                # Пример списка
                numbers = [34, 51, 85, 102, 153, 204, 255, 306]
        
                # Рассчитать остаток от деления на 17 для каждого из чисел списка
                remainders = list(map(lambda x: x % 17, numbers))
        
                # Отфильтровать остатки, величина которых меньше 7
                filtered_remainders = list(filter(lambda x: x < 7, remainders))
        
                # Получить произведение отфильтрованных остатков
                result = reduce(lambda x, y: x * y, filtered_remainders, 1)
        
                print(f"Результат: {result}")
                """,
            "Создать класс Профиль местности, который хранит последовательность высот, вычисленных через равные промежутки по горизонтали. Методы: наибольшая высота, наименьшая высота, перепад высот (наибольший, суммарный), крутизна (тангенс угла наклона; наибольшая, средняя), сравнение двух профилей одинаковой длины (по перепаду, по крутизне).":
                """
                class TerrainProfile:
                    def __init__(self, heights):
                        self.heights = heights
        
                    def max_height(self):
                        return max(self.heights)
        
                    def min_height(self):
                        return min(self.heights)
        
                    def max_drop(self):
                        return max(abs(self.heights[i] - self.heights[i+1]) for i in range(len(self.heights) - 1))
        
                    def total_drop(self):
                        return sum(abs(self.heights[i] - self.heights[i+1]) for i in range(len(self.heights) - 1))
        
                    def max_slope(self):
                        return max(abs(self.heights[i] - self.heights[i+1]) for i in range(len(self.heights) - 1))
        
                    def average_slope(self):
                        total_slope = sum(abs(self.heights[i] - self.heights[i+1]) for i in range(len(self.heights) - 1))
                        return total_slope / (len(self.heights) - 1)
        
                    def compare_to(self, other):
                        if len(self.heights) != len(other.heights):
                            raise ValueError("Профили должны быть одинаковой длины для сравнения")
        
                        max_drop_diff = self.max_drop() - other.max_drop()
                        total_drop_diff = self.total_drop() - other.total_drop()
                        max_slope_diff = self.max_slope() - other.max_slope()
                        avg_slope_diff = self.average_slope() - other.average_slope()
        
                        return {
                            "max_drop_diff": max_drop_diff,
                            "total_drop_diff": total_drop_diff,
                            "max_slope_diff": max_slope_diff,
                            "avg_slope_diff": avg_slope_diff
                        }
        
                # Пример использования
                profile1 = TerrainProfile([100, 200, 150, 300, 250, 400])
                profile2 = TerrainProfile([110, 210, 160, 310, 260, 410])
        
                print("Профиль 1 - наибольшая высота:", profile1.max_height())
                print("Профиль 1 - наименьшая высота:", profile1.min_height())
                print("Профиль 1 - наибольший перепад высот:", profile1.max_drop())
                print("Профиль 1 - суммарный перепад высот:", profile1.total_drop())
                print("Профиль 1 - наибольшая крутизна:", profile1.max_slope())
                print("Профиль 1 - средняя крутизна:", profile1.average_slope())
        
                comparison = profile1.compare_to(profile2)
                print("Сравнение профилей по перепаду высот и крутизне:", comparison)
                """,
            "Дан список целых чисел. При помощи механизма map/filter/reduce рассчитать разность со значением 10 для каждого из чисел списка и получить сумму тех значений, величина которых меньше 0.":
                """
                from functools import reduce
        
                # Пример списка
                numbers = [5, 15, 20, 3, 12, 8]
        
                # Рассчитать разность со значением 10 для каждого из чисел списка
                differences = list(map(lambda x: x - 10, numbers))
        
                # Отфильтровать значения, величина которых меньше 0
                filtered_differences = list(filter(lambda x: x < 0, differences))
        
                # Получить сумму отфильтрованных значений
                result = reduce(lambda x, y: x + y, filtered_differences, 0)
        
                print(f"Результат: {result}")
                """,
            "Реализовать двоичное дерево в виде связанных объектов (реализовать класс для элементов двоичного дерева) и реализовать симметричную процедуру обхода двоичного дерева в виде рекурсивной функции.":
                """
                class TreeNode:
                    def __init__(self, value):
                        self.value = value
                        self.left = None
                        self.right = None
        
                class BinaryTree:
                    def __init__(self):
                        self.root = None
        
                    def insert(self, value):
                        if not self.root:
                            self.root = TreeNode(value)
                        else:
                            self._insert_recursively(self.root, value)
        
                    def _insert_recursively(self, node, value):
                        if value < node.value:
                            if node.left:
                                self._insert_recursively(node.left, value)
                            else:
                                node.left = TreeNode(value)
                        else:
                            if node.right:
                                self._insert_recursively(node.right, value)
                            else:
                                node.right = TreeNode(value)
        
                    def inorder_traversal(self):
                        self._inorder_traversal(self.root)
        
                    def _inorder_traversal(self, node):
                        if node:
                            self._inorder_traversal(node.left)
                            print(node.value, end=" ")
                            self._inorder_traversal(node.right)
        
                # Пример использования
                bt = BinaryTree()
                bt.insert(5)
                bt.insert(3)
                bt.insert(7)
                bt.insert(2)
                bt.insert(4)
                bt.insert(6)
                bt.insert(8)
        
                print("Симметричный обход дерева:")
                bt.inorder_traversal()  # Ожидаемый вывод: 2 3 4 5 6 7 8
                """,
            "В одномерном массиве целых чисел найти количество пар элементов разного знака. (пара — это два рядом стоящих элемента).":
                """
                # Пример списка
                numbers = [3, -4, 5, -6, 7, 8, -9, 10]
        
                # Поиск количества пар элементов разного знака
                count_pairs = sum(1 for i in range(len(numbers) - 1) if numbers[i] * numbers[i + 1] < 0)
        
                print(f"Количество пар элементов разного знака: {count_pairs}")
                """,
            "Задание: построить базовый класс с указанными в таблице полями и методами: - конструктор; - функция, которая определяет «качество» объекта – Q по заданной формуле; - метод вывода информации об объекте. Построить дочерний класс (класс-потомок), который содержит: - дополнительное поле P; - функция, которая определяет «качество» объекта дочернего класса – Qp и перегружает функцию качества родительского класса (Q), выполняя вычисление по новой формуле. Создать проект для демонстрации работы: ввод и вывод информации об объектах классов.":
                """
                class Computer:
                    def __init__(self, processor_name, frequency, ram):
                        self.processor_name = processor_name
                        self.frequency = frequency  # in MHz
                        self.ram = ram  # in MB
        
                    def quality(self):
                        return 0.1 * self.frequency + self.ram
        
                    def display_info(self):
                        return f"Компьютер: {self.processor_name}, Частота: {self.frequency} МГц, ОЗУ: {self.ram} МБ, Качество: {self.quality()}"
        
                class ComputerWithSSD(Computer):
                    def __init__(self, processor_name, frequency, ram, ssd_capacity):
                        super().__init__(processor_name, frequency, ram)
                        self.ssd_capacity = ssd_capacity  # in GB
        
                    def quality(self):
                        base_quality = super().quality()
                        return base_quality + 0.5 * self.ssd_capacity
        
                    def display_info(self):
                        base_info = super().display_info()
                        return f"{base_info}, SSD: {self.ssd_capacity} ГБ, Качество с учетом SSD: {self.quality()}"
        
                # Пример использования
                computer1 = Computer("Intel i5", 3200, 8192)
                computer2 = Computer("AMD Ryzen 5", 3600, 16384)
        
                computer_with_ssd1 = ComputerWithSSD("Intel i7", 3400, 16384, 512)
                computer_with_ssd2 = ComputerWithSSD("AMD Ryzen 7", 3700, 32768, 1024)
        
                computers = [computer1, computer2, computer_with_ssd1, computer_with_ssd2]
        
                for computer in computers:
                    print(computer.display_info())
                """,
            "Создать иерархию классов для фруктов, продающихся в магазине. Иерархия должна содержать не менее 3 классов. Объекты должны содержать не менее 2-х атрибутов и 2-х методов. Реализовать механизм автоматического подсчета количества всех созданных фруктов и автоматического присвоения каждому фрукту уникального идентификатора. Необходимо заполнить список представителями всех классов (всего не менее 5 объектов) и продемонстрировать работу созданного механизма.":
                """
                class Fruit:
                    total_fruits = 0
                    id_counter = 1
        
                    def __init__(self, name, price_per_kg):
                        self.name = name
                        self.price_per_kg = price_per_kg
                        self.id = Fruit.id_counter
                        Fruit.id_counter += 1
                        Fruit.total_fruits += 1
        
                    def display_info(self):
                        return f"Фрукт: {self.name}, Цена за кг: {self.price_per_kg} руб., ID: {self.id}"
        
                    @classmethod
                    def total_count(cls):
                        return f"Всего фруктов: {cls.total_fruits}"
        
                class Apple(Fruit):
                    def __init__(self, name, price_per_kg, variety):
                        super().__init__(name, price_per_kg)
                        self.variety = variety
        
                    def display_info(self):
                        return f"{super().display_info()}, Сорт: {self.variety}"
        
                    def get_variety(self):
                        return f"Сорт яблока: {self.variety}"
        
                class Banana(Fruit):
                    def __init__(self, name, price_per_kg, origin):
                        super().__init__(name, price_per_kg)
                        self.origin = origin
        
                    def display_info(self):
                        return f"{super().display_info()}, Страна происхождения: {self.origin}"
        
                    def get_origin(self):
                        return f"Страна происхождения банана: {self.origin}"
        
                class Orange(Fruit):
                    def __init__(self, name, price_per_kg, is_seedless):
                        super().__init__(name, price_per_kg)
                        self.is_seedless = is_seedless
        
                    def display_info(self):
                        seedless_info = "без косточек" if self.is_seedless else "с косточками"
                        return f"{super().display_info()}, {seedless_info}"
        
                    def has_seeds(self):
                        return "Есть косточки" if not self.is_seedless else "Без косточек"
        
                # Пример использования
                fruit_list = [
                    Apple("Яблоко", 100, "Голден"),
                    Apple("Яблоко", 90, "Антоновка"),
                    Banana("Банан", 120, "Эквадор"),
                    Orange("Апельсин", 150, True),
                    Orange("Апельсин", 140, False)
                ]
        
                for fruit in fruit_list:
                    print(fruit.display_info())
        
                print(Fruit.total_count())
                """,
            "Дано предложение без знаков препинания. Превратить предложение в список слов. При помощи механизма map/filter/reduce найти количество слов, длина которых больше 4 и склеить их в одну строку.":
                """
                from functools import reduce
        
                # Пример предложения
                sentence = "Это пример предложения без знаков препинания для демонстрации работы"
        
                # Превратить предложение в список слов
                words = sentence.split()
        
                # Фильтруем слова, длина которых больше 4
                filtered_words = list(filter(lambda word: len(word) > 4, words))
        
                # Считаем количество отфильтрованных слов
                word_count = len(filtered_words)
        
                # Склеиваем отфильтрованные слова в одну строку
                concatenated_string = reduce(lambda x, y: x + y, filtered_words, "")
        
                print(f"Количество слов, длина которых больше 4: {word_count}")
                print(f"Склеенная строка: {concatenated_string}")
                """,
            "В одномерном массиве (array) целых чисел найти количество пар, модуль разности элементов которых больше 10. (пара — это два рядом стоящих элемента).":
                """
                # Пример массива
                array = [15, 2, 30, 18, 22, 1, 5, 16, 28]
        
                # Поиск количества пар, модуль разности элементов которых больше 10
                count_pairs = sum(1 for i in range(len(array) - 1) if abs(array[i] - array[i + 1]) > 10)
        
                print(f"Количество пар, модуль разности элементов которых больше 10: {count_pairs}")
                """,
            "Реализовать функцию st_reverse(a_string), которая при помощи стека инвертирует строку (меняет порядок букв на обратный). Пример: st_reverse('abcd') -> 'dcba'.":
                """
                def st_reverse(a_string):
                    stack = []
        
                    # Добавляем каждый символ строки в стек
                    for char in a_string:
                        stack.append(char)
        
                    reversed_string = ''
        
                    # Извлекаем символы из стека, чтобы инвертировать строку
                    while stack:
                        reversed_string += stack.pop()
        
                    return reversed_string
        
                # Пример использования
                print(st_reverse('abcd'))  # Ожидаемый вывод: 'dcba'
                print(st_reverse('Hello, World!'))  # Ожидаемый вывод: '!dlroW ,olleH'
                """,
            "Дан двунаправленный связный список. Вставить элемент после n-го элемента списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
                        self.prev = None
        
                class DoublyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
                            new_node.prev = current
        
                    def insert_after_n(self, n, data):
                        if not self.head:
                            print("Список пуст.")
                            return
                        current = self.head
                        count = 0
                        while current and count < n:
                            current = current.next
                            count += 1
                        if not current:
                            print(f"Элемента с индексом {n} не существует.")
                            return
                        new_node = Node(data)
                        new_node.next = current.next
                        new_node.prev = current
                        if current.next:
                            current.next.prev = new_node
                        current.next = new_node
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" <-> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                dll = DoublyLinkedList()
                for i in range(1, 6):  # Добавляем элементы 1-5
                    dll.append(i)
        
                print("Список до вставки элемента:")
                dll.display()
        
                n = 2
                new_element = 10
                dll.insert_after_n(n, new_element)  # Вставляем 10 после 3-го элемента (индекса 2)
        
                print("Список после вставки элемента:")
                dll.display()
                """,
            "Дан двунаправленный связный список. Удалить n-ый элемент списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
                        self.prev = None
        
                class DoublyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
                            new_node.prev = current
        
                    def delete_nth(self, n):
                        if not self.head:
                            print("Список пуст.")
                            return
                        current = self.head
                        count = 0
                        while current and count < n:
                            current = current.next
                            count += 1
                        if not current:
                            print(f"Элемента с индексом {n} не существует.")
                            return
                        if current.prev:
                            current.prev.next = current.next
                        if current.next:
                            current.next.prev = current.prev
                        if current == self.head:
                            self.head = current.next
                        print(f"Удален элемент с данными: {current.data}")
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" <-> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                dll = DoublyLinkedList()
                for i in range(1, 6):  # Добавляем элементы 1-5
                    dll.append(i)
        
                print("Список до удаления элемента:")
                dll.display()
        
                n = 2
                dll.delete_nth(n)  # Удаляем 3-й элемент (индекс 2)
        
                print("Список после удаления элемента:")
                dll.display()
                """,
            "Добавить элемент в начало однонаправленного связного списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def add_to_start(self, data):
                        new_node = Node(data)
                        new_node.next = self.head
                        self.head = new_node
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                sll = SinglyLinkedList()
                for i in range(1, 6):  # Добавляем элементы 1-5
                    sll.append(i)
        
                print("Список до добавления элемента в начало:")
                sll.display()
        
                new_element = 0
                sll.add_to_start(new_element)  # Добавляем 0 в начало
        
                print("Список после добавления элемента в начало:")
                sll.display()
                """,
            "Соединить два однонаправленных связных списка.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class SinglyLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = new_node
        
                    def extend(self, other_list):
                        if not self.head:
                            self.head = other_list.head
                        else:
                            current = self.head
                            while current.next:
                                current = current.next
                            current.next = other_list.head
        
                    def display(self):
                        current = self.head
                        while current:
                            print(current.data, end=" -> ")
                            current = current.next
                        print("None")
        
                # Пример использования
                list1 = SinglyLinkedList()
                list2 = SinglyLinkedList()
        
                # Заполнение первого списка
                for i in range(1, 6):  # Добавляем элементы 1-5
                    list1.append(i)
        
                # Заполнение второго списка
                for i in range(6, 11):  # Добавляем элементы 6-10
                    list2.append(i)
        
                print("Первый список:")
                list1.display()
        
                print("Второй список:")
                list2.display()
        
                # Соединяем списки
                list1.extend(list2)
        
                print("Объединенный список:")
                list1.display()
                """,
            "Даны 2 кольцевых списка с фамилиями шахматистов 2-х команд. Произвести жеребьевку. В первой команде выбирается каждый n-й игрок, а во второй - каждый k-й.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class CircularLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                            new_node.next = self.head
                        else:
                            current = self.head
                            while current.next != self.head:
                                current = current.next
                            current.next = new_node
                            new_node.next = self.head
        
                    def select_every_nth(self, n):
                        selected = []
                        if not self.head:
                            return selected
                        current = self.head
                        count = 0
                        while True:
                            count += 1
                            if count % n == 0:
                                selected.append(current.data)
                            current = current.next
                            if current == self.head:
                                break
                        return selected
        
                # Пример использования
                team1 = CircularLinkedList()
                team2 = CircularLinkedList()
        
                # Заполнение списков фамилиями шахматистов
                team1_players = ["Иванов", "Петров", "Сидоров", "Смирнов", "Кузнецов", "Попов", "Соколов", "Лебедев"]
                team2_players = ["Федоров", "Васильев", "Михайлов", "Новиков", "Морозов", "Павлов", "Семенов", "Егоров"]
        
                for player in team1_players:
                    team1.append(player)
        
                for player in team2_players:
                    team2.append(player)
        
                # Жеребьевка
                n = 3  # В первой команде выбирается каждый 3-й игрок
                k = 2  # Во второй команде выбирается каждый 2-й игрок
        
                selected_team1 = team1.select_every_nth(n)
                selected_team2 = team2.select_every_nth(k)
        
                print("Выбранные игроки первой команды:", selected_team1)
                print("Выбранные игроки второй команды:", selected_team2)
                """,
            "Даны 2 кольцевых списка: фамилии участников розыгрыша и названия призов. Выиграет n человек (каждый k-й). Число для пересчета призов - t.":
                """
                class Node:
                    def __init__(self, data):
                        self.data = data
                        self.next = None
        
                class CircularLinkedList:
                    def __init__(self):
                        self.head = None
        
                    def append(self, data):
                        new_node = Node(data)
                        if not self.head:
                            self.head = new_node
                            new_node.next = self.head
                        else:
                            current = self.head
                            while current.next != self.head:
                                current = current.next
                            current.next = new_node
                            new_node.next = self.head
        
                    def select_every_kth(self, k, count):
                        selected = []
                        if not self.head:
                            return selected
                        current = self.head
                        idx = 1
                        while len(selected) < count:
                            if idx % k == 0:
                                selected.append(current.data)
                            current = current.next
                            idx += 1
                        return selected
        
                    def __str__(self):
                        result = []
                        if not self.head:
                            return "Список пуст"
                        current = self.head
                        while True:
                            result.append(current.data)
                            current = current.next
                            if current == self.head:
                                break
                        return " -> ".join(result) + " -> ..."
        
                # Пример использования
                participants = CircularLinkedList()
                prizes = CircularLinkedList()
        
                # Заполнение списков
                participant_names = ["Иванов", "Петров", "Сидоров", "Смирнов", "Кузнецов", "Попов", "Соколов", "Лебедев"]
                prize_names = ["Приз1", "Приз2", "Приз3", "Приз4", "Приз5", "Приз6", "Приз7", "Приз8"]
        
                for name in participant_names:
                    participants.append(name)
        
                for prize in prize_names:
                    prizes.append(prize)
        
                n = 3  # Выиграет 3 человека
                k = 2  # Каждый 2-й
                t = 4  # Число для пересчета призов
        
                print("Участники:", participants)
                print("Призы:", prizes)
        
                winners = participants.select_every_kth(k, n)
                selected_prizes = prizes.select_every_kth(t, n)
        
                print("Выигравшие участники:", winners)
                print("Выигранные призы:", selected_prizes)
                """,
            "Дан список с перечнем товаров. Выбрать все товары, изготовленные фирмой Bosh и создать из них новый список.": """
# Пример списка товаров
products = [
    {"name": "Washing Machine", "brand": "Bosh", "price": 30000},
    {"name": "Refrigerator", "brand": "Samsung", "price": 25000},
    {"name": "Dishwasher", "brand": "Bosh", "price": 35000},
    {"name": "Microwave", "brand": "LG", "price": 7000},
    {"name": "Oven", "brand": "Bosh", "price": 40000},
    {"name": "Blender", "brand": "Philips", "price": 5000}
]

# Создание нового списка с товарами фирмы Bosh
bosh_products = list(filter(lambda x: x["brand"] == "Bosh", products))
print("Товары фирмы Bosh:", bosh_products)
""",
            "Даны 2 списка: перечень товаров, производимых Концернами BORK и PHILIPS. Создать список товаров, выпускаемых как одной, так и другой фирмой. Результат вывести в веб-интерфейс при помощи фреймворка Flask. Базу данных можно использовать по желанию, дизайн не обязателен: достаточно обычных кнопок/списков.": """
# app.py
from flask import Flask, render_template
import mysql.connector
import os

app = Flask(__name__)

db_config = {
    'host': 'localhost',
    'user': 'root',
    'password': 'admin',
    'database': 'products_db'
}

sql_file = 'products_db.sql'

def import_db():
    os.system(f"mysql -u {db_config['user']} -p{db_config['password']} -e 'DROP DATABASE IF EXISTS {db_config['database']}; CREATE DATABASE {db_config['database']};'")
    os.system(f"mysql -u {db_config['user']} -p{db_config['password']} {db_config['database']} < {sql_file}")

def get_products_by_brand(brand):
    db = mysql.connector.connect(**db_config)
    cursor = db.cursor()
    query = "SELECT name FROM products WHERE brand = %s"
    cursor.execute(query, (brand,))
    products = cursor.fetchall()
    cursor.close()
    db.close()
    return [product[0] for product in products]

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/show')
def show():
    products_bork = get_products_by_brand('BORK')
    products_phillips = get_products_by_brand('PHILIPS')
    return render_template('show.html', products_bork=products_bork, products_phillips=products_phillips)

if __name__ == "__main__":
    import_db()
    app.run(debug=True)

# index.html
\"\"\"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Товары от BORK и PHILIPS</title>
</head>
<body>
<h1>Товары, выпускаемые BORK и PHILIPS</h1>
<form action="/show" method="get">
    <button type="submit">Показать товары</button>
</form>
</body>
</html>
\"\"\"

# show.html
\"\"\"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Товары от BORK и PHILIPS</title>
</head>
<body>
<h1>Список товаров, выпускаемых BORK</h1>
<ul id="product-list-bork">
    {% for product in products_bork %}
        <li>{{ product }}</li>
    {% endfor %}
</ul>

<h1>Список товаров, выпускаемых PHILIPS</h1>
<ul id="product-list-phillips">
    {% for product in products_phillips %}
        <li>{{ product }}</li>
    {% endfor %}
</ul>
<a href="/">Назад</a>
</body>
</html>
\"\"\"
""",
            "Даны 2 списка с фамилиями студентов 2-х групп. Перевести n студентов из 1-й группы во 2-ю. Число пересчета - k.": """
# Пример списков студентов
group1 = ["Иванов", "Петров", "Сидоров", "Смирнов", "Кузнецов", "Попов", "Соколов", "Лебедев", "Федоров", "Михайлов"]
group2 = ["Новиков", "Морозов", "Павлов", "Семенов", "Егоров"]

n = 3  # Число студентов для перевода
k = 2  # Число пересчета

# Функция для перевода студентов
def transfer_students(group1, group2, n, k):
    transferred_students = []
    index = k - 1  # Начальный индекс для пересчета
    while len(transferred_students) < n and group1:
        index = index % len(group1)  # Цикличность в случае небольшого списка
        transferred_students.append(group1.pop(index))
        index += k - 1  # Переход к следующему студенту с учетом удаления

    group2.extend(transferred_students)
    return group1, group2, transferred_students

group1, group2, transferred_students = transfer_students(group1, group2, n, k)

print("Обновленный список 1-й группы:", group1)
print("Обновленный список 2-й группы:", group2)
print("Переведенные студенты:", transferred_students)
""",
            "Даны 2 списка: перечень товаров и фамилии покупателей. Каждый n-й покупатель покупает m-й товар. Вывести список покупок.": """
        # Списки товаров и фамилий покупателей
        items = ["Хлеб", "Молоко", "Яблоки", "Сыр", "Кофе"]
        customers = ["Иванов", "Петров", "Сидоров", "Кузнецов", "Новиков"]

        # Вывод списка покупок
        purchases = []
        for i, customer in enumerate(customers):
            item = items[i % len(items)]  # Подбор товара по циклическому индексу
            purchases.append(f"{customer} покупает {item}")

        # Печать списка покупок
        for purchase in purchases:
            print(purchase)
        """,
            "Описать функцию, которая: a) присваивает параметру Е запись из самого левого листа непустого дерева Т (лист-вершина, из которого не выходит ни одной ветви); b) определяет число вхождений записи Е в дерево Т.":
                """
                class TreeNode:
                    def __init__(self, value):
                        self.value = value
                        self.left = None
                        self.right = None
        
                # a) Присваивание параметру E записи из самого левого листа дерева T
                def find_leftmost_leaf(node):
                    if node is None:
                        return None
                    current = node
                    while current.left:
                        current = current.left
                    return current.value
        
                # b) Определение числа вхождений записи E в дерево T
                def count_occurrences(node, E):
                    if node is None:
                        return 0
                    count = 1 if node.value == E else 0
                    return count + count_occurrences(node.left, E) + count_occurrences(node.right, E)
        
                # Пример использования
                # Построение дерева
                root = TreeNode(5)
                root.left = TreeNode(3)
                root.right = TreeNode(7)
                root.left.left = TreeNode(3)
                root.left.right = TreeNode(4)
                root.right.left = TreeNode(6)
                root.right.right = TreeNode(7)
                root.left.left.left = TreeNode(3)
        
                # a) Присваивание параметру E записи из самого левого листа дерева T
                E = find_leftmost_leaf(root)
                print(f"Самый левый лист: {E}")
        
                # b) Определение числа вхождений записи E в дерево T
                occurrences = count_occurrences(root, E)
                print(f"Число вхождений записи {E} в дерево: {occurrences}")
                """,
            "Вершины дерева вещественные числа. Описать функцию, которая вычисляет среднее арифметическое всех вершин дерева. Результат вывести в веб-интерфейс при помощи фреймворка Django. Базу данных можно использовать по желанию, дизайн не обязателен: достаточно обычных кнопок/списков.": '''
# manage.py
#!/usr/bin/env python
import os
import sys
import mysql.connector

def load_db():
    db_config = {
        'host': 'localhost',
        'user': 'root',
        'password': 'admin',
        'database': 'tree_db'
    }

    sql_file_path = os.path.join(os.path.dirname(__file__), 'tree_db.sql')
    if not os.path.exists(sql_file_path):
        return

    with open(sql_file_path, 'r') as file:
        sql_commands = file.read().split(';')

    conn = mysql.connector.connect(
        host=db_config['host'],
        user=db_config['user'],
        password=db_config['password']
    )
    cursor = conn.cursor()
    cursor.execute(f"CREATE DATABASE IF NOT EXISTS {db_config['database']}")
    cursor.execute(f"USE {db_config['database']}")

    for command in sql_commands:
        if command.strip():
            cursor.execute(command)

    conn.commit()
    cursor.close()
    conn.close()

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'djangoproject99.settings')
    from django.core.management import execute_from_command_line

    if len(sys.argv) > 1 and sys.argv[1] == 'load_db':
        load_db()
    else:
        execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

# djangoproject99/settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'tree_db',
        'USER': 'root',
        'PASSWORD': 'admin',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}

# djangoproject99/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('djangoproject99.urls')),
]

# djangoproject99/urls.py (файл в вашем приложении)
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('calculate/', views.calculate_average, name='calculate_average'),
]

# djangoproject99/views.py
from django.shortcuts import render
import mysql.connector

db_config = {
    'host': 'localhost',
    'user': 'root',
    'password': 'admin',
    'database': 'tree_db'
}

def index(request):
    return render(request, 'djangoproject99/tree_average.html', {'average': None})

def calculate_average(request):
    average = None
    if request.method == 'POST':
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        query = "SELECT AVG(value) FROM tree_node"
        cursor.execute(query)
        result = cursor.fetchone()
        average = result[0] if result else None
        cursor.close()
        conn.close()
    return render(request, 'djangoproject99/tree_average.html', {'average': average})

# djangoproject99/templates/djangoproject99/tree_average.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Среднее арифметическое вершин дерева</title>
</head>
<body>
    <h1>Вычислить среднее арифметическое вершин дерева</h1>
    <form action="{% url 'calculate_average' %}" method="post">
        {% csrf_token %}
        <button type="submit">Вычислить</button>
    </form>
    {% if average is not None %}
    <ul>
        <li>Среднее арифметическое: {{ average }}</li>
    </ul>
    {% endif %}
</body>
</html>
'''
        }

    def tokenize(self, text):
        # Преобразуем текст в список слов
        return re.findall(r'\b\w+\b', text.lower())

    def find(self, task_text):
        task_words = self.tokenize(task_text)
        best_match = None
        highest_similarity = 0

        task_texts = list(self.tasks.keys())
        task_vectors = self.vectorize_texts(task_texts + [task_text])

        query_vector = task_vectors[-1]
        task_vectors = task_vectors[:-1]

        similarities = cosine_similarity([query_vector], task_vectors).flatten()

        highest_similarity_index = similarities.argmax()
        highest_similarity = similarities[highest_similarity_index]

        if highest_similarity > 0:  # Порог можно настроить
            best_match = task_texts[highest_similarity_index]
            solution = self.tasks[best_match]
            return f"Задача: {best_match}\n\nРешение:\n{solution}"
        else:
            return "Задача не найдена"

    def vectorize_texts(self, texts):
        # Используем TF-IDF для векторизации текста
        vectorizer = TfidfVectorizer()
        vectors = vectorizer.fit_transform(texts)
        return vectors.toarray()

    def create_python_file(self, task_text):
        result = self.find(task_text)
        if result == "Задача не найдена":
            print(result)
            return

        task, solution = result.split("\n\nРешение:\n", 1)
        print(task)

        confirmation = input("Создать .py файл с этим решением? (да/нет): ").strip().lower()
        if confirmation != 'да':
            print("Создание файла отменено.")
            return

        file_number = 1
        while os.path.exists(f'task_{file_number}.py'):
            file_number += 1

        filename = f'task_{file_number}.py'
        with open(filename, 'w', encoding='utf-8') as file:  # Указываем кодировку
            file.write(solution.strip())

        print(f"Файл {filename} создан.")

        # Исправление отступов и форматирование файла
        self.fix_indentation_and_format(filename)

    def fix_indentation_and_format(self, filename):
        try:
            # Сначала исправляем отступы с помощью autopep8
            subprocess.run(['autopep8', '--in-place', '--aggressive', '--aggressive', filename], check=True)
            print(f"Отступы в файле {filename} исправлены.")

            # Затем форматируем с помощью black
            subprocess.run(['black', filename], check=True)
            print(f"Файл {filename} отформатирован.")
        except subprocess.CalledProcessError as e:
            print(f"Ошибка при форматировании файла {filename}: {e}")


