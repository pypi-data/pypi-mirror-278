
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import _jpype
import java.lang
import java.util
import java.util.stream
import jisa
import jisa.maths.fits
import jisa.maths.functions
import jisa.maths.interpolation
import jisa.maths.matrices
import jisa.maths.nd
import jpype
import typing



class ErrorValue(java.lang.Number):
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def add(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def add(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def div(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def div(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def divide(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def divide(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def getError(self) -> float: ...
    def getValue(self) -> float: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @typing.overload
    def minus(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def minus(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def multiply(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def multiply(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def plus(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def plus(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def pow(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def pow(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def subtract(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def subtract(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...
    @typing.overload
    def times(self, double: float) -> 'ErrorValue': ...
    @typing.overload
    def times(self, errorValue: 'ErrorValue') -> 'ErrorValue': ...

_Range__T = typing.TypeVar('_Range__T', bound=java.lang.Number)  # <T>
class Range(java.lang.Iterable[_Range__T], typing.Generic[_Range__T]):
    def __init__(self, tArray: typing.Union[typing.List[_Range__T], jpype.JArray]): ...
    def array(self) -> typing.MutableSequence[_Range__T]: ...
    def column(self) -> jisa.maths.matrices.RealMatrix: ...
    @staticmethod
    def count(int: int, int2: int) -> 'Range'[int]: ...
    def doubleArray(self) -> typing.MutableSequence[float]: ...
    @staticmethod
    def exponential(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> 'Range'[float]: ...
    @staticmethod
    def function(int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[float, float], typing.Callable[[float], float]]) -> 'Range'[float]: ...
    @staticmethod
    def geometric(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number3: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> 'Range'[float]: ...
    def get(self, int: int) -> _Range__T: ...
    def getDouble(self, int: int) -> float: ...
    def iterator(self) -> java.util.Iterator[_Range__T]: ...
    @typing.overload
    @staticmethod
    def linear(int: int, int2: int) -> 'Range'[float]: ...
    @typing.overload
    @staticmethod
    def linear(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> 'Range'[float]: ...
    def list(self) -> java.util.List[_Range__T]: ...
    @staticmethod
    def manual(*number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> 'Range'[float]: ...
    def mirror(self) -> 'Range'[_Range__T]: ...
    @staticmethod
    def polynomial(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int, int2: int) -> 'Range'[float]: ...
    @typing.overload
    def repeat(self, int: int) -> 'Range'[_Range__T]: ...
    @typing.overload
    @staticmethod
    def repeat(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> 'Range'[float]: ...
    def reshape(self, int: int, int2: int) -> jisa.maths.matrices.RealMatrix: ...
    def reverse(self) -> 'Range'[_Range__T]: ...
    def row(self) -> jisa.maths.matrices.RealMatrix: ...
    def shift(self, int: int) -> 'Range'[_Range__T]: ...
    def shuffle(self) -> 'Range'[_Range__T]: ...
    def size(self) -> int: ...
    @staticmethod
    def step(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number3: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> 'Range'[float]: ...
    def stream(self) -> java.util.stream.Stream[_Range__T]: ...
    def toString(self) -> str: ...
    class DoubleRange(jisa.maths.Range[float]):
        def __init__(self, range: 'Range'[float], type: 'Range.Type', int: int): ...
        def getOrder(self) -> int: ...
        def getType(self) -> 'Range.Type': ...
    class Type(java.lang.Enum['Range.Type']):
        LINEAR: typing.ClassVar['Range.Type'] = ...
        EXPONENTIAL: typing.ClassVar['Range.Type'] = ...
        POLYNOMIAL: typing.ClassVar['Range.Type'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Range.Type': ...
        @staticmethod
        def values() -> typing.MutableSequence['Range.Type']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.maths")``.

    ErrorValue: typing.Type[ErrorValue]
    Range: typing.Type[Range]
    fits: jisa.maths.fits.__module_protocol__
    functions: jisa.maths.functions.__module_protocol__
    interpolation: jisa.maths.interpolation.__module_protocol__
    matrices: jisa.maths.matrices.__module_protocol__
    nd: jisa.maths.nd.__module_protocol__
