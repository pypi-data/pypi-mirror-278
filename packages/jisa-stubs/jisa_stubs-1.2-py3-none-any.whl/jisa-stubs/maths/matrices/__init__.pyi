
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import java.util.function
import java.util.stream
import jisa
import jisa.maths.functions
import jisa.maths.matrices.exceptions
import jpype
import org.apache.commons.math.complex
import org.apache.commons.math.linear
import typing



_LU__T = typing.TypeVar('_LU__T')  # <T>
class LU(typing.Generic[_LU__T]):
    def getL(self) -> 'Matrix'[_LU__T]: ...
    def getP(self) -> 'Matrix'[_LU__T]: ...
    def getU(self) -> 'Matrix'[_LU__T]: ...

_Matrix__EntryConsumer__T = typing.TypeVar('_Matrix__EntryConsumer__T')  # <T>
_Matrix__EntryMapper__U = typing.TypeVar('_Matrix__EntryMapper__U')  # <U>
_Matrix__EntryMapper__T = typing.TypeVar('_Matrix__EntryMapper__T')  # <T>
_Matrix__LinearMapper__T = typing.TypeVar('_Matrix__LinearMapper__T')  # <T>
_Matrix__T = typing.TypeVar('_Matrix__T')  # <T>
class Matrix(java.lang.Iterable[_Matrix__T], typing.Generic[_Matrix__T]):
    @typing.overload
    def add(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def add(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def addToElement(self, int: int, int2: int, t: _Matrix__T) -> None: ...
    def appendCols(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def appendRows(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    @staticmethod
    def canMultiply(matrix: 'Matrix', matrix2: 'Matrix') -> bool: ...
    def checkIndices(self, int: int, int2: int) -> None: ...
    @staticmethod
    def colMatrixMatch(matrix: 'Matrix', matrix2: 'Matrix') -> bool: ...
    def cols(self) -> int: ...
    def copy(self) -> 'Matrix'[_Matrix__T]: ...
    @staticmethod
    def dimensionsMatch(matrix: 'Matrix', matrix2: 'Matrix') -> bool: ...
    @typing.overload
    def div(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def div(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def divide(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def divide(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def divideElement(self, int: int, int2: int, t: _Matrix__T) -> None: ...
    def elementDivide(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def elementMultiply(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def equals(self, matrix: 'Matrix'[_Matrix__T]) -> bool: ...
    @typing.overload
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Matrix__T], typing.Callable[[_Matrix__T], None]]) -> None: ...
    @typing.overload
    def forEach(self, entryConsumer: typing.Union['Matrix.EntryConsumer'[_Matrix__T], typing.Callable[[int, int, _Matrix__T], None]]) -> None: ...
    def forEachCol(self, consumer: typing.Union[java.util.function.Consumer[typing.Union[typing.List[_Matrix__T], jpype.JArray]], typing.Callable[[typing.Union[typing.List[_Matrix__T], jpype.JArray]], None]]) -> None: ...
    def forEachRow(self, consumer: typing.Union[java.util.function.Consumer[typing.Union[typing.List[_Matrix__T], jpype.JArray]], typing.Callable[[typing.Union[typing.List[_Matrix__T], jpype.JArray]], None]]) -> None: ...
    def get(self, int: int, int2: int) -> _Matrix__T: ...
    def getColArray(self, int: int) -> typing.MutableSequence[_Matrix__T]: ...
    def getColMatrix(self, int: int) -> 'Matrix'[_Matrix__T]: ...
    def getColSums(self) -> 'Matrix'[_Matrix__T]: ...
    def getData(self) -> typing.MutableSequence[typing.MutableSequence[_Matrix__T]]: ...
    def getDeterminant(self) -> _Matrix__T: ...
    def getDiagonal(self) -> 'Matrix'[_Matrix__T]: ...
    def getFlatData(self) -> typing.MutableSequence[_Matrix__T]: ...
    def getLU(self) -> LU[_Matrix__T]: ...
    def getQR(self) -> 'QR'[_Matrix__T]: ...
    def getRowArray(self, int: int) -> typing.MutableSequence[_Matrix__T]: ...
    def getRowMatrix(self, int: int) -> 'Matrix'[_Matrix__T]: ...
    def getRowSums(self) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'Matrix'[_Matrix__T]: ...
    def getTrace(self) -> _Matrix__T: ...
    def invert(self) -> 'Matrix'[_Matrix__T]: ...
    def isCol(self) -> bool: ...
    def isRow(self) -> bool: ...
    @staticmethod
    def isScalar(matrix: 'Matrix') -> bool: ...
    def isSingular(self) -> bool: ...
    def isSquare(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_Matrix__T]: ...
    @typing.overload
    def leftDivide(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def leftDivide(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def leftElementDivide(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def leftElementMultiply(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def leftMultiply(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def leftMultiply(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    _map_2__U = typing.TypeVar('_map_2__U')  # <U>
    _map_3__U = typing.TypeVar('_map_3__U')  # <U>
    @typing.overload
    def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def map(self, entryMapper: typing.Union['Matrix.EntryMapper'[_Matrix__T, _Matrix__T], typing.Callable[[int, int, _Matrix__T], _Matrix__T]]) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def map(self, matrix: 'Matrix'[_map_2__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_2__U, _Matrix__T], typing.Callable[[_Matrix__T], _map_2__U]]) -> None: ...
    @typing.overload
    def map(self, matrix: 'Matrix'[_map_3__U], entryMapper: typing.Union['Matrix.EntryMapper'[_map_3__U, _Matrix__T], typing.Callable[[int, int, _Matrix__T], _map_3__U]]) -> None: ...
    @typing.overload
    def mapCol(self, int: int, linearMapper: typing.Union['Matrix.LinearMapper'[_Matrix__T], typing.Callable[[int, _Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapCol(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, linearMapper: typing.Union['Matrix.LinearMapper'[_Matrix__T], typing.Callable[[int, _Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    def mapElement(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, linearMapper: typing.Union['Matrix.LinearMapper'[_Matrix__T], typing.Callable[[int, _Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, linearMapper: typing.Union['Matrix.LinearMapper'[_Matrix__T], typing.Callable[[int, _Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapSelf(self, gFunction: typing.Union[jisa.maths.functions.GFunction[_Matrix__T, _Matrix__T], typing.Callable[[_Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def mapSelf(self, entryMapper: typing.Union['Matrix.EntryMapper'[_Matrix__T, _Matrix__T], typing.Callable[[int, int, _Matrix__T], _Matrix__T]]) -> None: ...
    @typing.overload
    def minus(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def minus(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def multiply(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def multiply(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def multiplyElement(self, int: int, int2: int, t: _Matrix__T) -> None: ...
    @typing.overload
    def plus(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def plus(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def reshape(self, int: int, int2: int) -> 'Matrix'[_Matrix__T]: ...
    @staticmethod
    def rowMatrixMatch(matrix: 'Matrix', matrix2: 'Matrix') -> bool: ...
    def rows(self) -> int: ...
    def set(self, int: int, int2: int, t: _Matrix__T) -> None: ...
    @typing.overload
    def setAll(self, t: _Matrix__T) -> None: ...
    @typing.overload
    def setAll(self, *t: _Matrix__T) -> None: ...
    @typing.overload
    def setCol(self, int: int, *t: _Matrix__T) -> None: ...
    @typing.overload
    def setCol(self, int: int, matrix: 'Matrix'[_Matrix__T]) -> None: ...
    @typing.overload
    def setDiagonal(self, t: _Matrix__T) -> None: ...
    @typing.overload
    def setDiagonal(self, *t: _Matrix__T) -> None: ...
    @typing.overload
    def setRow(self, int: int, *t: _Matrix__T) -> None: ...
    @typing.overload
    def setRow(self, int: int, matrix: 'Matrix'[_Matrix__T]) -> None: ...
    def setSubMatrix(self, int: int, int2: int, matrix: 'Matrix'[_Matrix__T]) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.Stream[_Matrix__T]: ...
    @typing.overload
    def subtract(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def subtract(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def subtractFromElement(self, int: int, int2: int, t: _Matrix__T) -> None: ...
    @typing.overload
    def times(self, t: _Matrix__T) -> 'Matrix'[_Matrix__T]: ...
    @typing.overload
    def times(self, matrix: 'Matrix'[_Matrix__T]) -> 'Matrix'[_Matrix__T]: ...
    def toString(self) -> str: ...
    def transpose(self) -> 'Matrix'[_Matrix__T]: ...
    class EntryConsumer(typing.Generic[_Matrix__EntryConsumer__T]):
        def accept(self, int: int, int2: int, t: _Matrix__EntryConsumer__T) -> None: ...
    class EntryMapper(typing.Generic[_Matrix__EntryMapper__U, _Matrix__EntryMapper__T]):
        def map(self, int: int, int2: int, t: _Matrix__EntryMapper__T) -> _Matrix__EntryMapper__U: ...
    class LinearMapper(typing.Generic[_Matrix__LinearMapper__T]):
        def map(self, int: int, t: _Matrix__LinearMapper__T) -> _Matrix__LinearMapper__T: ...

_MatrixFactory__Copier__T = typing.TypeVar('_MatrixFactory__Copier__T')  # <T>
_MatrixFactory__Operation__T = typing.TypeVar('_MatrixFactory__Operation__T')  # <T>
_MatrixFactory__T = typing.TypeVar('_MatrixFactory__T')  # <T>
class MatrixFactory(typing.Generic[_MatrixFactory__T]):
    def __init__(self, t: _MatrixFactory__T, t2: _MatrixFactory__T, operation: typing.Union['MatrixFactory.Operation'[_MatrixFactory__T], typing.Callable[[_MatrixFactory__T, _MatrixFactory__T], _MatrixFactory__T]], operation2: typing.Union['MatrixFactory.Operation'[_MatrixFactory__T], typing.Callable[[_MatrixFactory__T, _MatrixFactory__T], _MatrixFactory__T]], operation3: typing.Union['MatrixFactory.Operation'[_MatrixFactory__T], typing.Callable[[_MatrixFactory__T, _MatrixFactory__T], _MatrixFactory__T]], operation4: typing.Union['MatrixFactory.Operation'[_MatrixFactory__T], typing.Callable[[_MatrixFactory__T, _MatrixFactory__T], _MatrixFactory__T]], copier: typing.Union['MatrixFactory.Copier'[_MatrixFactory__T], typing.Callable[[_MatrixFactory__T], _MatrixFactory__T]]): ...
    @typing.overload
    def create(self, int: int, int2: int) -> Matrix[_MatrixFactory__T]: ...
    @typing.overload
    def create(self, int: int, int2: int, *t: _MatrixFactory__T) -> Matrix[_MatrixFactory__T]: ...
    def createCol(self, *t: _MatrixFactory__T) -> Matrix[_MatrixFactory__T]: ...
    def createIdentity(self, int: int) -> Matrix[_MatrixFactory__T]: ...
    def createRow(self, *t: _MatrixFactory__T) -> Matrix[_MatrixFactory__T]: ...
    class Copier(typing.Generic[_MatrixFactory__Copier__T]):
        def copy(self, t: _MatrixFactory__Copier__T) -> _MatrixFactory__Copier__T: ...
    class Operation(typing.Generic[_MatrixFactory__Operation__T]):
        def operate(self, t: _MatrixFactory__Operation__T, t2: _MatrixFactory__Operation__T) -> _MatrixFactory__Operation__T: ...

_QR__T = typing.TypeVar('_QR__T')  # <T>
class QR(typing.Generic[_QR__T]):
    def getH(self) -> Matrix[_QR__T]: ...
    def getQ(self) -> Matrix[_QR__T]: ...
    def getQT(self) -> Matrix[_QR__T]: ...
    def getR(self) -> Matrix[_QR__T]: ...

class RealMatrix(Matrix[float]):
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, *double: float): ...
    @typing.overload
    def __init__(self, int: int, int2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, int: int, int2: int, matrixBuilder: typing.Union['RealMatrix.MatrixBuilder', typing.Callable]): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, matrix: Matrix[float]): ...
    @typing.overload
    def __init__(self, realMatrix: org.apache.commons.math.linear.RealMatrix): ...
    @typing.overload
    def add(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def add(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def addToElement(self, int: int, int2: int, double: float) -> None: ...
    def appendCols(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def appendRows(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def asColumn(*double: float) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def asColumn(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'RealMatrix': ...
    @staticmethod
    def asRealMatrix(matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def asRow(*double: float) -> 'RealMatrix': ...
    @typing.overload
    @staticmethod
    def asRow(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'RealMatrix': ...
    def cols(self) -> int: ...
    def copy(self) -> 'RealMatrix': ...
    @typing.overload
    def div(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def div(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    def divide(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def divide(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def divideElement(self, int: int, int2: int, double: float) -> None: ...
    def elementDivide(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def elementMultiply(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def get(self, int: int, int2: int) -> float: ...
    def getCol(self, int: int) -> typing.MutableSequence[float]: ...
    def getColArray(self, int: int) -> typing.MutableSequence[float]: ...
    def getColMatrix(self, int: int) -> 'RealMatrix': ...
    def getColQuadratures(self) -> 'RealMatrix': ...
    def getColSums(self) -> 'RealMatrix': ...
    def getData(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDeterminant(self) -> float: ...
    def getDiagonal(self) -> 'RealMatrix': ...
    def getFlatData(self) -> typing.MutableSequence[float]: ...
    def getLU(self) -> LU[float]: ...
    def getMaxElement(self) -> float: ...
    def getMinElement(self) -> float: ...
    def getNorm(self) -> float: ...
    def getQR(self) -> 'RealMatrix.QR': ...
    def getRow(self, int: int) -> typing.MutableSequence[float]: ...
    def getRowArray(self, int: int) -> typing.MutableSequence[float]: ...
    def getRowMatrix(self, int: int) -> 'RealMatrix': ...
    def getRowQuadratures(self) -> 'RealMatrix': ...
    def getRowSums(self) -> 'RealMatrix': ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'RealMatrix': ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'RealMatrix': ...
    def getTrace(self) -> float: ...
    @staticmethod
    def identity(int: int) -> 'RealMatrix': ...
    def invert(self) -> 'RealMatrix': ...
    def isSingular(self) -> bool: ...
    @staticmethod
    def iterableToCol(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'RealMatrix': ...
    @typing.overload
    def leftDivide(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def leftDivide(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def leftElementDivide(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def leftElementMultiply(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    def leftMultiply(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def leftMultiply(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    _map_0__U = typing.TypeVar('_map_0__U')  # <U>
    _map_1__U = typing.TypeVar('_map_1__U')  # <U>
    @typing.overload
    def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, typing.Any], typing.Callable[[typing.Any], _map_0__U]]) -> None: ...
    @typing.overload
    def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, typing.Any], typing.Callable[[int, int, typing.Any], _map_1__U]]) -> None: ...
    @typing.overload
    def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[float, float], typing.Callable[[float], float]]) -> 'RealMatrix': ...
    @typing.overload
    def map(self, entryMapper: typing.Union[Matrix.EntryMapper[float, float], typing.Callable[[int, int, float], float]]) -> 'RealMatrix': ...
    @typing.overload
    def mapCol(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapCol(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[float], typing.Callable[[int, float], float]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[float], typing.Callable[[int, float], float]]) -> None: ...
    def mapElement(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[float, float], typing.Callable[[float], float]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[float], typing.Callable[[int, float], float]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[float], typing.Callable[[int, float], float]]) -> None: ...
    @typing.overload
    def minus(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def minus(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    def multiply(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def multiply(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    @typing.overload
    def multiply(self, realMatrix: org.apache.commons.math.linear.RealMatrix) -> 'RealMatrix': ...
    def multiplyElement(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def plus(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def plus(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def realMatrix(self) -> org.apache.commons.math.linear.RealMatrix: ...
    def reshape(self, int: int, int2: int) -> 'RealMatrix': ...
    def rotate2D(self, double: float) -> 'RealMatrix': ...
    @staticmethod
    def rotation2D(double: float) -> 'RealMatrix': ...
    def rows(self) -> int: ...
    def set(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def setAll(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def setAll(self, double: float) -> None: ...
    @typing.overload
    def setAll(self, *double: float) -> None: ...
    @typing.overload
    def setCol(self, int: int, *t: typing.Any) -> None: ...
    @typing.overload
    def setCol(self, int: int, matrix: Matrix[typing.Any]) -> None: ...
    @typing.overload
    def setCol(self, int: int, *double: float) -> None: ...
    @typing.overload
    def setDiagonal(self, double: float) -> None: ...
    @typing.overload
    def setDiagonal(self, *double: float) -> None: ...
    @typing.overload
    def setRow(self, int: int, *t: typing.Any) -> None: ...
    @typing.overload
    def setRow(self, int: int, matrix: Matrix[typing.Any]) -> None: ...
    @typing.overload
    def setRow(self, int: int, *double: float) -> None: ...
    @typing.overload
    def subtract(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def subtract(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def subtractFromElement(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def times(self, double: float) -> 'RealMatrix': ...
    @typing.overload
    def times(self, matrix: Matrix[float]) -> 'RealMatrix': ...
    def toString(self) -> str: ...
    def transpose(self) -> 'RealMatrix': ...
    class MatrixBuilder:
        def get(self, int: int, int2: int) -> float: ...
    class QR(QR[float]):
        def __init__(self, qRDecomposition: org.apache.commons.math.linear.QRDecomposition): ...
        def getH(self) -> 'RealMatrix': ...
        def getQ(self) -> 'RealMatrix': ...
        def getQT(self) -> 'RealMatrix': ...
        def getR(self) -> 'RealMatrix': ...

_AbstractMatrix__LMatrix__T = typing.TypeVar('_AbstractMatrix__LMatrix__T')  # <T>
_AbstractMatrix__T = typing.TypeVar('_AbstractMatrix__T')  # <T>
class AbstractMatrix(Matrix[_AbstractMatrix__T], typing.Generic[_AbstractMatrix__T]):
    @typing.overload
    def __init__(self, t: _AbstractMatrix__T, t2: _AbstractMatrix__T, int: int, int2: int): ...
    @typing.overload
    def __init__(self, t: _AbstractMatrix__T, t2: _AbstractMatrix__T, matrix: Matrix[_AbstractMatrix__T]): ...
    @typing.overload
    def __init__(self, t: _AbstractMatrix__T, t2: _AbstractMatrix__T, fieldMatrix: org.apache.commons.math.linear.FieldMatrix['AbstractMatrix.FieldElement']): ...
    @typing.overload
    def add(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def add(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def addToElement(self, int: int, int2: int, t: _AbstractMatrix__T) -> None: ...
    def appendCols(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def appendRows(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def cols(self) -> int: ...
    def copy(self) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def create(self) -> 'AbstractMatrix'[_AbstractMatrix__T]: ...
    @typing.overload
    def create(self, int: int, int2: int) -> 'AbstractMatrix'[_AbstractMatrix__T]: ...
    @typing.overload
    def create(self, matrix: Matrix[_AbstractMatrix__T]) -> 'AbstractMatrix'[_AbstractMatrix__T]: ...
    @typing.overload
    def create(self, fieldMatrix: org.apache.commons.math.linear.FieldMatrix['AbstractMatrix.FieldElement']) -> 'AbstractMatrix'[_AbstractMatrix__T]: ...
    @typing.overload
    def divide(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def divide(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    def divideElement(self, int: int, int2: int, t: _AbstractMatrix__T) -> None: ...
    def elementDivide(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def elementMultiply(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def get(self, int: int, int2: int) -> _AbstractMatrix__T: ...
    def getColArray(self, int: int) -> typing.MutableSequence[_AbstractMatrix__T]: ...
    def getColMatrix(self, int: int) -> Matrix[_AbstractMatrix__T]: ...
    def getColSums(self) -> Matrix[_AbstractMatrix__T]: ...
    def getData(self) -> typing.MutableSequence[typing.MutableSequence[_AbstractMatrix__T]]: ...
    def getDeterminant(self) -> _AbstractMatrix__T: ...
    def getDiagonal(self) -> Matrix[_AbstractMatrix__T]: ...
    def getFlatData(self) -> typing.MutableSequence[_AbstractMatrix__T]: ...
    def getLU(self) -> LU[_AbstractMatrix__T]: ...
    def getQR(self) -> QR[_AbstractMatrix__T]: ...
    def getRowArray(self, int: int) -> typing.MutableSequence[_AbstractMatrix__T]: ...
    def getRowMatrix(self, int: int) -> Matrix[_AbstractMatrix__T]: ...
    def getRowSums(self) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> Matrix[_AbstractMatrix__T]: ...
    def getTrace(self) -> _AbstractMatrix__T: ...
    def invert(self) -> Matrix[_AbstractMatrix__T]: ...
    def isSingular(self) -> bool: ...
    @typing.overload
    def leftDivide(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def leftDivide(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def leftElementDivide(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def leftElementMultiply(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def leftMultiply(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def leftMultiply(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    _map_0__U = typing.TypeVar('_map_0__U')  # <U>
    _map_1__U = typing.TypeVar('_map_1__U')  # <U>
    @typing.overload
    def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _map_0__U]]) -> None: ...
    @typing.overload
    def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, _AbstractMatrix__T], typing.Callable[[int, int, _AbstractMatrix__T], _map_1__U]]) -> None: ...
    @typing.overload
    def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def map(self, entryMapper: typing.Union[Matrix.EntryMapper[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[int, int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def mapCol(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapCol(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[_AbstractMatrix__T], typing.Callable[[int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[_AbstractMatrix__T], typing.Callable[[int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    def mapElement(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[_AbstractMatrix__T], typing.Callable[[int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[_AbstractMatrix__T], typing.Callable[[int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapSelf(self, gFunction: typing.Union[jisa.maths.functions.GFunction[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[_AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def mapSelf(self, entryMapper: typing.Union[Matrix.EntryMapper[_AbstractMatrix__T, _AbstractMatrix__T], typing.Callable[[int, int, _AbstractMatrix__T], _AbstractMatrix__T]]) -> None: ...
    @typing.overload
    def multiply(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def multiply(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def multiplyElement(self, int: int, int2: int, t: _AbstractMatrix__T) -> None: ...
    def reshape(self, int: int, int2: int) -> Matrix[_AbstractMatrix__T]: ...
    def rows(self) -> int: ...
    def set(self, int: int, int2: int, t: _AbstractMatrix__T) -> None: ...
    @typing.overload
    def setAll(self, t: _AbstractMatrix__T) -> None: ...
    @typing.overload
    def setAll(self, *t: _AbstractMatrix__T) -> None: ...
    @typing.overload
    def setDiagonal(self, t: _AbstractMatrix__T) -> None: ...
    @typing.overload
    def setDiagonal(self, *t: _AbstractMatrix__T) -> None: ...
    @typing.overload
    def subtract(self, t: _AbstractMatrix__T) -> Matrix[_AbstractMatrix__T]: ...
    @typing.overload
    def subtract(self, matrix: Matrix[_AbstractMatrix__T]) -> Matrix[_AbstractMatrix__T]: ...
    def subtractFromElement(self, int: int, int2: int, t: _AbstractMatrix__T) -> None: ...
    def toString(self) -> str: ...
    def transpose(self) -> Matrix[_AbstractMatrix__T]: ...
    class LMatrix(jisa.maths.matrices.AbstractMatrix[_AbstractMatrix__LMatrix__T], typing.Generic[_AbstractMatrix__LMatrix__T]):
        def __init__(self, t: _AbstractMatrix__LMatrix__T, t2: _AbstractMatrix__LMatrix__T, operation: typing.Union[MatrixFactory.Operation[_AbstractMatrix__LMatrix__T], typing.Callable[[_AbstractMatrix__LMatrix__T, _AbstractMatrix__LMatrix__T], _AbstractMatrix__LMatrix__T]], operation2: typing.Union[MatrixFactory.Operation[_AbstractMatrix__LMatrix__T], typing.Callable[[_AbstractMatrix__LMatrix__T, _AbstractMatrix__LMatrix__T], _AbstractMatrix__LMatrix__T]], operation3: typing.Union[MatrixFactory.Operation[_AbstractMatrix__LMatrix__T], typing.Callable[[_AbstractMatrix__LMatrix__T, _AbstractMatrix__LMatrix__T], _AbstractMatrix__LMatrix__T]], operation4: typing.Union[MatrixFactory.Operation[_AbstractMatrix__LMatrix__T], typing.Callable[[_AbstractMatrix__LMatrix__T, _AbstractMatrix__LMatrix__T], _AbstractMatrix__LMatrix__T]], copier: typing.Union[MatrixFactory.Copier[_AbstractMatrix__LMatrix__T], typing.Callable[[_AbstractMatrix__LMatrix__T], _AbstractMatrix__LMatrix__T]], int: int, int2: int): ...
    class FieldElement: ...

class ComplexMatrix(Matrix[org.apache.commons.math.complex.Complex]):
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, *complex: org.apache.commons.math.complex.Complex): ...
    @typing.overload
    def __init__(self, matrix: Matrix[org.apache.commons.math.complex.Complex]): ...
    @typing.overload
    def __init__(self, complexArray: typing.Union[typing.List[typing.MutableSequence[org.apache.commons.math.complex.Complex]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, fieldMatrix: org.apache.commons.math.linear.FieldMatrix[org.apache.commons.math.complex.Complex]): ...
    @typing.overload
    def add(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def add(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    def addToElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
    def appendCols(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    def appendRows(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    def cols(self) -> int: ...
    def copy(self) -> 'ComplexMatrix': ...
    @typing.overload
    def divide(self, matrix: Matrix[typing.Any]) -> Matrix[typing.Any]: ...
    @typing.overload
    def divide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    def divideElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
    def elementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    def elementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    def fieldMatrix(self) -> org.apache.commons.math.linear.FieldMatrix[org.apache.commons.math.complex.Complex]: ...
    def get(self, int: int, int2: int) -> org.apache.commons.math.complex.Complex: ...
    def getColArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
    def getColMatrix(self, int: int) -> 'ComplexMatrix': ...
    def getColSums(self) -> 'ComplexMatrix': ...
    def getData(self) -> typing.MutableSequence[typing.MutableSequence[org.apache.commons.math.complex.Complex]]: ...
    def getDeterminant(self) -> org.apache.commons.math.complex.Complex: ...
    def getDiagonal(self) -> 'ComplexMatrix': ...
    def getFlatData(self) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
    def getLU(self) -> LU[org.apache.commons.math.complex.Complex]: ...
    def getQR(self) -> QR[org.apache.commons.math.complex.Complex]: ...
    def getRowArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
    def getRowMatrix(self, int: int) -> 'ComplexMatrix': ...
    def getRowSums(self) -> 'ComplexMatrix': ...
    @typing.overload
    def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'ComplexMatrix': ...
    @typing.overload
    def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'ComplexMatrix': ...
    def getTrace(self) -> org.apache.commons.math.complex.Complex: ...
    def invert(self) -> 'ComplexMatrix': ...
    def isSingular(self) -> bool: ...
    @typing.overload
    def leftDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def leftDivide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    def leftElementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    def leftElementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def leftMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def leftMultiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    _map_0__U = typing.TypeVar('_map_0__U')  # <U>
    _map_1__U = typing.TypeVar('_map_1__U')  # <U>
    @typing.overload
    def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, typing.Any], typing.Callable[[typing.Any], _map_0__U]]) -> None: ...
    @typing.overload
    def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, typing.Any], typing.Callable[[int, int, typing.Any], _map_1__U]]) -> None: ...
    @typing.overload
    def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
    @typing.overload
    def map(self, entryMapper: typing.Union[Matrix.EntryMapper[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[int, int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
    @typing.overload
    def mapCol(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapCol(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[org.apache.commons.math.complex.Complex], typing.Callable[[int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapColToCol(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[org.apache.commons.math.complex.Complex], typing.Callable[[int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> None: ...
    def mapElement(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapRow(self, int: int, linearMapper: typing.Union[Matrix.LinearMapper[org.apache.commons.math.complex.Complex], typing.Callable[[int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, gFunction: typing.Union[jisa.maths.functions.GFunction[typing.Any, typing.Any], typing.Callable[[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapRowToRow(self, int: int, int2: int, linearMapper: typing.Union[Matrix.LinearMapper[org.apache.commons.math.complex.Complex], typing.Callable[[int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> None: ...
    @typing.overload
    def multiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def multiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    def multiplyElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
    def reshape(self, int: int, int2: int) -> 'ComplexMatrix': ...
    def rows(self) -> int: ...
    def set(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
    @typing.overload
    def setAll(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
    @typing.overload
    def setAll(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
    @typing.overload
    def setDiagonal(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
    @typing.overload
    def setDiagonal(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
    @typing.overload
    def subtract(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
    @typing.overload
    def subtract(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
    def subtractFromElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
    def toString(self) -> str: ...
    def transpose(self) -> 'ComplexMatrix': ...
    class Col(jisa.maths.matrices.ComplexMatrix):
        def __init__(self, *complex: org.apache.commons.math.complex.Complex): ...
        @typing.overload
        def add(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def add(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def addToElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def appendCols(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def appendRows(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def copy(self) -> 'ComplexMatrix': ...
        @typing.overload
        def divide(self, matrix: Matrix[typing.Any]) -> Matrix[typing.Any]: ...
        @typing.overload
        def divide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def divideElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def elementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def elementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def get(self, int: int, int2: int) -> org.apache.commons.math.complex.Complex: ...
        def getColArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getColMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getColSums(self) -> 'ComplexMatrix': ...
        def getData(self) -> typing.MutableSequence[typing.MutableSequence[org.apache.commons.math.complex.Complex]]: ...
        def getDeterminant(self) -> org.apache.commons.math.complex.Complex: ...
        def getDiagonal(self) -> 'ComplexMatrix': ...
        def getFlatData(self) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getRowSums(self) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'ComplexMatrix': ...
        def getTrace(self) -> org.apache.commons.math.complex.Complex: ...
        def invert(self) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def leftElementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def leftElementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        _map_0__U = typing.TypeVar('_map_0__U')  # <U>
        _map_1__U = typing.TypeVar('_map_1__U')  # <U>
        @typing.overload
        def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, typing.Any], typing.Callable[[typing.Any], _map_0__U]]) -> None: ...
        @typing.overload
        def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, typing.Any], typing.Callable[[int, int, typing.Any], _map_1__U]]) -> None: ...
        @typing.overload
        def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def map(self, entryMapper: typing.Union[Matrix.EntryMapper[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[int, int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def multiplyElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def reshape(self, int: int, int2: int) -> 'ComplexMatrix': ...
        def set(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def subtract(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def subtract(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def subtractFromElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def transpose(self) -> 'ComplexMatrix': ...
    class Identity(jisa.maths.matrices.ComplexMatrix):
        def __init__(self, int: int): ...
        @typing.overload
        def add(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def add(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def addToElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def appendCols(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def appendRows(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def copy(self) -> 'ComplexMatrix': ...
        @typing.overload
        def divide(self, matrix: Matrix[typing.Any]) -> Matrix[typing.Any]: ...
        @typing.overload
        def divide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def divideElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def elementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def elementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def get(self, int: int, int2: int) -> org.apache.commons.math.complex.Complex: ...
        def getColArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getColMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getColSums(self) -> 'ComplexMatrix': ...
        def getData(self) -> typing.MutableSequence[typing.MutableSequence[org.apache.commons.math.complex.Complex]]: ...
        def getDeterminant(self) -> org.apache.commons.math.complex.Complex: ...
        def getDiagonal(self) -> 'ComplexMatrix': ...
        def getFlatData(self) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getRowSums(self) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'ComplexMatrix': ...
        def getTrace(self) -> org.apache.commons.math.complex.Complex: ...
        def invert(self) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def leftElementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def leftElementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        _map_0__U = typing.TypeVar('_map_0__U')  # <U>
        _map_1__U = typing.TypeVar('_map_1__U')  # <U>
        @typing.overload
        def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, typing.Any], typing.Callable[[typing.Any], _map_0__U]]) -> None: ...
        @typing.overload
        def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, typing.Any], typing.Callable[[int, int, typing.Any], _map_1__U]]) -> None: ...
        @typing.overload
        def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def map(self, entryMapper: typing.Union[Matrix.EntryMapper[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[int, int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def multiplyElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def reshape(self, int: int, int2: int) -> 'ComplexMatrix': ...
        def set(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def subtract(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def subtract(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def subtractFromElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def transpose(self) -> 'ComplexMatrix': ...
    class Row(jisa.maths.matrices.ComplexMatrix):
        def __init__(self, *complex: org.apache.commons.math.complex.Complex): ...
        @typing.overload
        def add(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def add(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def addToElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def appendCols(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def appendRows(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def copy(self) -> 'ComplexMatrix': ...
        @typing.overload
        def divide(self, matrix: Matrix[typing.Any]) -> Matrix[typing.Any]: ...
        @typing.overload
        def divide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def divideElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def elementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def elementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def get(self, int: int, int2: int) -> org.apache.commons.math.complex.Complex: ...
        def getColArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getColMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getColSums(self) -> 'ComplexMatrix': ...
        def getData(self) -> typing.MutableSequence[typing.MutableSequence[org.apache.commons.math.complex.Complex]]: ...
        def getDeterminant(self) -> org.apache.commons.math.complex.Complex: ...
        def getDiagonal(self) -> 'ComplexMatrix': ...
        def getFlatData(self) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowArray(self, int: int) -> typing.MutableSequence[org.apache.commons.math.complex.Complex]: ...
        def getRowMatrix(self, int: int) -> 'ComplexMatrix': ...
        def getRowSums(self) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, int: int, int2: int, int3: int, int4: int) -> 'ComplexMatrix': ...
        @typing.overload
        def getSubMatrix(self, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> 'ComplexMatrix': ...
        def getTrace(self) -> org.apache.commons.math.complex.Complex: ...
        def invert(self) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftDivide(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def leftElementDivide(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        def leftElementMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def leftMultiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        _map_0__U = typing.TypeVar('_map_0__U')  # <U>
        _map_1__U = typing.TypeVar('_map_1__U')  # <U>
        @typing.overload
        def map(self, matrix: Matrix[_map_0__U], gFunction: typing.Union[jisa.maths.functions.GFunction[_map_0__U, typing.Any], typing.Callable[[typing.Any], _map_0__U]]) -> None: ...
        @typing.overload
        def map(self, matrix: Matrix[_map_1__U], entryMapper: typing.Union[Matrix.EntryMapper[_map_1__U, typing.Any], typing.Callable[[int, int, typing.Any], _map_1__U]]) -> None: ...
        @typing.overload
        def map(self, gFunction: typing.Union[jisa.maths.functions.GFunction[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def map(self, entryMapper: typing.Union[Matrix.EntryMapper[org.apache.commons.math.complex.Complex, org.apache.commons.math.complex.Complex], typing.Callable[[int, int, org.apache.commons.math.complex.Complex], org.apache.commons.math.complex.Complex]]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def multiply(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def multiplyElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def reshape(self, int: int, int2: int) -> 'ComplexMatrix': ...
        def set(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setAll(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def setDiagonal(self, *complex: org.apache.commons.math.complex.Complex) -> None: ...
        @typing.overload
        def subtract(self, matrix: Matrix[org.apache.commons.math.complex.Complex]) -> 'ComplexMatrix': ...
        @typing.overload
        def subtract(self, complex: org.apache.commons.math.complex.Complex) -> 'ComplexMatrix': ...
        def subtractFromElement(self, int: int, int2: int, complex: org.apache.commons.math.complex.Complex) -> None: ...
        def transpose(self) -> 'ComplexMatrix': ...

_MMatrix__U = typing.TypeVar('_MMatrix__U')  # <U>
class MMatrix(AbstractMatrix[Matrix[_MMatrix__U]], typing.Generic[_MMatrix__U]):
    def __init__(self, matrix: Matrix[_MMatrix__U], matrix2: Matrix[_MMatrix__U], int: int, int2: int): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.maths.matrices")``.

    AbstractMatrix: typing.Type[AbstractMatrix]
    ComplexMatrix: typing.Type[ComplexMatrix]
    LU: typing.Type[LU]
    MMatrix: typing.Type[MMatrix]
    Matrix: typing.Type[Matrix]
    MatrixFactory: typing.Type[MatrixFactory]
    QR: typing.Type[QR]
    RealMatrix: typing.Type[RealMatrix]
    exceptions: jisa.maths.matrices.exceptions.__module_protocol__
