
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.awt.image
import java.lang
import java.util
import javafx.scene.image
import jisa
import jisa.addresses
import jisa.control
import jisa.devices
import jisa.enums
import jisa.experiment
import jisa.gui
import jpype
import kotlin.reflect
import org.json
import typing



class FunctionGenerator:
    def applyChanges(self, field: jisa.gui.Field[int], field2: jisa.gui.Field[int], field3: jisa.gui.Field[float], field4: jisa.gui.Field[float], field5: jisa.gui.Field[float], field6: jisa.gui.Field[float]) -> jisa.control.SRunnable: ...
    def readChanges(self, waveformParam: 'FunctionGenerator.WaveformParam') -> 'FunctionGenerator.WaveformParam': ...
    def readDutyCycle(self) -> float: ...
    def readFrequency(self) -> float: ...
    def readFunction(self) -> jisa.enums.WaveForm: ...
    def readVos(self) -> float: ...
    def readVpp(self) -> float: ...
    def setDutyCycle(self) -> None: ...
    def setDutyCycleLevel(self, double: float) -> None: ...
    def setFrequency(self) -> None: ...
    def setFrequencyValue(self, double: float, oscMode: jisa.enums.OscMode) -> None: ...
    def setFunction(self, waveForm: jisa.enums.WaveForm) -> None: ...
    def setFunctionValue(self, waveForm: jisa.enums.WaveForm) -> None: ...
    def setSin(self) -> None: ...
    def setVos(self) -> None: ...
    def setVpp(self) -> None: ...
    def setVppVosValues(self, double: float, double2: float) -> None: ...
    def turnOFF(self) -> None: ...
    def turnON(self) -> None: ...
    class WaveformParam:
        function: jisa.enums.WaveForm = ...
        frequency: float = ...
        Vos: float = ...
        Vpp: float = ...
        DutyCycle: float = ...
        def __init__(self): ...

_Instrument__AutoQuantity__S = typing.TypeVar('_Instrument__AutoQuantity__S')  # <S>
_Instrument__OptionalQuantity__S = typing.TypeVar('_Instrument__OptionalQuantity__S')  # <S>
_Instrument__Parameter__S = typing.TypeVar('_Instrument__Parameter__S')  # <S>
_Instrument__Setter__S = typing.TypeVar('_Instrument__Setter__S')  # <S>
class Instrument:
    def close(self) -> None: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List['Instrument.Parameter'[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List['Instrument.Parameter'[typing.Any]]: ...
    def getIDN(self) -> str: ...
    def getLockObject(self) -> typing.Any: ...
    def getName(self) -> str: ...
    def setTimeout(self, int: int) -> None: ...
    class AutoQuantity(typing.Generic[_Instrument__AutoQuantity__S]):
        def __init__(self, boolean: bool, s2: _Instrument__AutoQuantity__S): ...
        def getValue(self) -> _Instrument__AutoQuantity__S: ...
        def isAuto(self) -> bool: ...
    class OptionalQuantity(typing.Generic[_Instrument__OptionalQuantity__S]):
        def __init__(self, boolean: bool, s2: _Instrument__OptionalQuantity__S): ...
        def getValue(self) -> _Instrument__OptionalQuantity__S: ...
        def isUsed(self) -> bool: ...
    class Parameter(typing.Generic[_Instrument__Parameter__S]):
        def __init__(self, string: str, s3: _Instrument__Parameter__S, setter: typing.Union['Instrument.Setter'[_Instrument__Parameter__S], typing.Callable[[_Instrument__Parameter__S], None]], *s5: _Instrument__Parameter__S): ...
        def getChoices(self) -> java.util.List[_Instrument__Parameter__S]: ...
        def getDefaultValue(self) -> _Instrument__Parameter__S: ...
        def getName(self) -> str: ...
        def isChoice(self) -> bool: ...
        def set(self, s2: _Instrument__Parameter__S) -> None: ...
    class Setter(typing.Generic[_Instrument__Setter__S]):
        def set(self, s2: _Instrument__Setter__S) -> None: ...
    class TableQuantity:
        def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray], list: java.util.List[java.util.List[float]]): ...
        def getColumns(self) -> typing.MutableSequence[str]: ...
        def getValue(self) -> java.util.List[java.util.List[float]]: ...

class LineFilter:
    def isLineFilterEnabled(self) -> bool: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...

class LineFilter2X:
    def is2xLineFilterEnabled(self) -> bool: ...
    def set2xLineFilterEnabled(self, boolean: bool) -> None: ...

class MultiInstrument:
    def contains(self, class_: typing.Type[Instrument]) -> bool: ...
    _get_0__I = typing.TypeVar('_get_0__I', bound=Instrument)  # <I>
    _get_1__I = typing.TypeVar('_get_1__I', bound=Instrument)  # <I>
    _get_2__I = typing.TypeVar('_get_2__I', bound=Instrument)  # <I>
    _get_3__I = typing.TypeVar('_get_3__I', bound=Instrument)  # <I>
    @typing.overload
    def get(self, class_: typing.Type[_get_0__I]) -> java.util.List[_get_0__I]: ...
    @typing.overload
    def get(self, kClass: kotlin.reflect.KClass[_get_1__I]) -> java.util.List[_get_1__I]: ...
    @typing.overload
    def get(self, class_: typing.Type[_get_2__I], int: int) -> _get_2__I: ...
    @typing.overload
    def get(self, kClass: kotlin.reflect.KClass[_get_3__I], int: int) -> _get_3__I: ...
    _getSubInstrument__I = typing.TypeVar('_getSubInstrument__I', bound=Instrument)  # <I>
    def getSubInstrument(self, class_: typing.Type[_getSubInstrument__I], int: int) -> _getSubInstrument__I: ...
    def getSubInstrumentTypes(self) -> java.util.List[typing.Type[Instrument]]: ...
    _getSubInstruments_1__I = typing.TypeVar('_getSubInstruments_1__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_1__I]) -> java.util.List[_getSubInstruments_1__I]: ...

class Camera(Instrument):
    def captureFrame(self) -> 'Camera.Frame': ...
    def getBufferedImage(self) -> java.awt.image.BufferedImage: ...
    def getFrameRate(self) -> float: ...
    def getImage(self) -> javafx.scene.image.Image: ...
    def getMode(self) -> 'Camera.Mode': ...
    def getModes(self) -> java.util.List['Camera.Mode']: ...
    def isOn(self) -> bool: ...
    def setMode(self, mode: 'Camera.Mode') -> None: ...
    def setOn(self, boolean: bool) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    class Frame:
        def __init__(self, bufferedImage: java.awt.image.BufferedImage): ...
        def getBufferedImage(self) -> java.awt.image.BufferedImage: ...
        def getFXImage(self) -> javafx.scene.image.Image: ...
        def saveJPG(self, string: str) -> None: ...
        def savePNG(self, string: str) -> None: ...
    class Mode:
        def __init__(self, int: int, int2: int): ...
        def getPixelCount(self) -> int: ...
        def getXResolution(self) -> int: ...
        def getYResolution(self) -> int: ...

class EMController(Instrument):
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getField(self) -> float: ...
    def getRampForCurrent(self, double: float) -> 'EMController.Ramp': ...
    def getRampLegs(self, double: float, double2: float) -> java.util.List['EMController.Ramp']: ...
    def getRampRates(self) -> java.util.List['EMController.Ramp']: ...
    def setCurrent(self, double: float) -> None: ...
    def setField(self, double: float) -> None: ...
    def setRampRates(self, *ramp: 'EMController.Ramp') -> None: ...
    def turnOff(self) -> None: ...
    class Ramp:
        def __init__(self, double: float, double2: float, double3: float): ...
        def getMaxI(self) -> float: ...
        def getMinI(self) -> float: ...
        def getRate(self) -> float: ...

class FMeter(Instrument):
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    def getFrequency(self) -> float: ...
    def getFrequencyRange(self) -> float: ...
    def setFrequencyRange(self, double: float) -> None: ...

class LevelMeter(Instrument, MultiInstrument):
    def getChannel(self, int: int) -> 'LevelMeter': ...
    @staticmethod
    def getDescription() -> str: ...
    @typing.overload
    def getLevel(self, int: int) -> float: ...
    @typing.overload
    def getLevel(self) -> float: ...
    @typing.overload
    def getName(self, int: int) -> str: ...
    @typing.overload
    def getName(self) -> str: ...

_MCSMU__SMUAcceptor__T = typing.TypeVar('_MCSMU__SMUAcceptor__T', bound='SMU')  # <T>
_MCSMU__T = typing.TypeVar('_MCSMU__T', bound='SMU')  # <T>
class MCSMU(Instrument, MultiInstrument, java.lang.Iterable[_MCSMU__T], typing.Generic[_MCSMU__T]):
    def forEachSMU(self, sMUAcceptor: typing.Union['MCSMU.SMUAcceptor'[_MCSMU__T], typing.Callable[[_MCSMU__T], None]]) -> None: ...
    def getChannel(self, int: int) -> _MCSMU__T: ...
    def getChannels(self) -> java.util.List[_MCSMU__T]: ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMU(self, int: int) -> _MCSMU__T: ...
    def getSMUs(self) -> java.util.List[_MCSMU__T]: ...
    _getSubInstruments_1__I = typing.TypeVar('_getSubInstruments_1__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_1__I]) -> java.util.List[_getSubInstruments_1__I]: ...
    def iterator(self) -> java.util.Iterator[_MCSMU__T]: ...
    def turnOffAll(self) -> None: ...
    class SMUAcceptor(typing.Generic[_MCSMU__SMUAcceptor__T]):
        def accept(self, t: _MCSMU__SMUAcceptor__T) -> None: ...

_MSTMeter__T = typing.TypeVar('_MSTMeter__T', bound='TMeter')  # <T>
class MSTMeter(MultiInstrument, typing.Generic[_MSTMeter__T]):
    _getSubInstruments_1__I = typing.TypeVar('_getSubInstruments_1__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_1__I]) -> java.util.List[_getSubInstruments_1__I]: ...
    def getTemperatures(self, *t: _MSTMeter__T) -> java.util.Map[_MSTMeter__T, float]: ...
    def getThermometer(self, int: int) -> _MSTMeter__T: ...
    def getThermometers(self) -> java.util.List[_MSTMeter__T]: ...

_SPA__A = typing.TypeVar('_SPA__A', bound='SMU')  # <A>
_SPA__B = typing.TypeVar('_SPA__B', bound='VMeter')  # <B>
_SPA__C = typing.TypeVar('_SPA__C', bound='VSource')  # <C>
_SPA__D = typing.TypeVar('_SPA__D', bound='Switch')  # <D>
class SPA(Instrument, MultiInstrument, typing.Generic[_SPA__A, _SPA__B, _SPA__C, _SPA__D]):
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannel(self, int: int) -> _SPA__A: ...
    def getSMUChannels(self) -> java.util.List[_SPA__A]: ...
    _getSubInstruments_0__I = typing.TypeVar('_getSubInstruments_0__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_0__I]) -> java.util.List[_getSubInstruments_0__I]: ...
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    def getSwitchChannel(self, int: int) -> _SPA__D: ...
    def getSwitchChannels(self) -> java.util.List[_SPA__D]: ...
    def getVMeterChannel(self, int: int) -> _SPA__B: ...
    def getVMeterChannels(self) -> java.util.List[_SPA__B]: ...
    def getVSourceChannel(self, int: int) -> _SPA__C: ...
    def getVSourceChannels(self) -> java.util.List[_SPA__C]: ...

class Spectrometer(Instrument):
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    def getDescription(self) -> str: ...
    def setAccessory(self, boolean: bool) -> None: ...
    def takeScan(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> str: ...

_SubInstrument__T = typing.TypeVar('_SubInstrument__T', bound=Instrument)  # <T>
class SubInstrument(Instrument, typing.Generic[_SubInstrument__T]):
    def close(self) -> None: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    def getIDN(self) -> str: ...
    def getParentInstrument(self) -> _SubInstrument__T: ...

class Switch(Instrument):
    @staticmethod
    def getDescription() -> str: ...
    def isOn(self) -> bool: ...
    def setOn(self, boolean: bool) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...

class TMeter(Instrument):
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> jisa.devices.PList: ...
    @staticmethod
    def getDescription() -> str: ...
    def getTemperature(self) -> float: ...
    def getTemperatureRange(self) -> float: ...
    def setTemperatureRange(self, double: float) -> None: ...
    @typing.overload
    def waitForStableTemperature(self, double: float, double2: float, long: int) -> None: ...
    @typing.overload
    def waitForStableTemperature(self, double: float, long: int) -> None: ...
    @typing.overload
    def waitForStableTemperatureMaxTime(self, double: float, double2: float, long: int, long2: int) -> None: ...
    @typing.overload
    def waitForStableTemperatureMaxTime(self, double: float, long: int, long2: int) -> None: ...

class Translator(Instrument):
    def getMaxPosition(self) -> float: ...
    def getMaxSpeed(self) -> float: ...
    def getMinPosition(self) -> float: ...
    def getMinSpeed(self) -> float: ...
    def getPosition(self) -> float: ...
    def getSpeed(self) -> float: ...
    def isLocked(self) -> bool: ...
    def isMoving(self) -> bool: ...
    def moveBy(self, double: float) -> None: ...
    def moveToHome(self) -> None: ...
    def setLocked(self, boolean: bool) -> None: ...
    def setPosition(self, double: float) -> None: ...
    def setSpeed(self, double: float) -> None: ...
    def stop(self) -> None: ...

class VPreAmp(Instrument):
    def getCoupling(self) -> jisa.enums.Coupling: ...
    @staticmethod
    def getDescription() -> str: ...
    def getFilterHighFrequency(self) -> float: ...
    def getFilterLowFrequency(self) -> float: ...
    def getFilterMode(self) -> jisa.enums.Filter: ...
    def getFilterRollOff(self) -> float: ...
    def getGain(self) -> float: ...
    def getInput(self) -> jisa.enums.Input: ...
    def setCoupling(self, coupling: jisa.enums.Coupling) -> None: ...
    def setFilterHighFrequency(self, double: float) -> None: ...
    def setFilterLowFrequency(self, double: float) -> None: ...
    def setFilterMode(self, filter: jisa.enums.Filter) -> None: ...
    def setFilterRollOff(self, double: float) -> None: ...
    def setGain(self, double: float) -> None: ...
    def setInput(self, input: jisa.enums.Input) -> None: ...

class XYTranslationStage(Instrument):
    @staticmethod
    def getDescription() -> str: ...
    def getRotation(self) -> float: ...
    def getXPosition(self) -> float: ...
    def getXYSpeed(self) -> float: ...
    def getYPosition(self) -> float: ...
    def setRotation(self, double: float) -> None: ...
    def setXPosition(self, double: float) -> None: ...
    def setXYPosition(self, double: float, double2: float) -> None: ...
    def setXYSpeed(self, double: float) -> None: ...
    def setYPosition(self, double: float) -> None: ...

class IMeter(Instrument, Switch):
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    def getCurrentRange(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIntegrationTime(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def waitForStableCurrent(self, double: float, int: int, int2: int) -> None: ...

class ISource(Instrument, Switch):
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def isOn(self) -> bool: ...
    def setCurrent(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...

class LockIn(Instrument, FMeter):
    def autoOffset(self) -> None: ...
    @typing.overload
    def autoRange(self, double: float, double2: float, long: int) -> None: ...
    @typing.overload
    def autoRange(self) -> None: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> jisa.devices.PList: ...
    def getCoupling(self) -> jisa.enums.Coupling: ...
    @staticmethod
    def getDescription() -> str: ...
    def getExpansion(self) -> float: ...
    def getExternalTriggerMode(self) -> 'LockIn.TrigMode': ...
    def getFilterRollOff(self) -> float: ...
    def getFrequency(self) -> float: ...
    def getLockedAmplitude(self) -> float: ...
    def getOffset(self) -> float: ...
    def getRange(self) -> float: ...
    def getRefAmplitude(self) -> float: ...
    def getRefMode(self) -> 'LockIn.RefMode': ...
    def getRefPhase(self) -> float: ...
    def getTimeConstant(self) -> float: ...
    def isDifferentialInput(self) -> bool: ...
    def isShieldGrounded(self) -> bool: ...
    def isSyncFilterEnabled(self) -> bool: ...
    def setCoupling(self, coupling: jisa.enums.Coupling) -> None: ...
    def setDifferentialInput(self, boolean: bool) -> None: ...
    def setExpansion(self, double: float) -> None: ...
    def setExternalTriggerMode(self, trigMode: 'LockIn.TrigMode') -> None: ...
    def setFilterRollOff(self, double: float) -> None: ...
    def setOffset(self, double: float) -> None: ...
    def setOscAmplitude(self, double: float) -> None: ...
    def setOscFrequency(self, double: float) -> None: ...
    def setOscPhase(self, double: float) -> None: ...
    def setRange(self, double: float) -> None: ...
    def setRefMode(self, refMode: 'LockIn.RefMode') -> None: ...
    def setShieldGrounded(self, boolean: bool) -> None: ...
    def setSyncFilterEnabled(self, boolean: bool) -> None: ...
    def setTimeConstant(self, double: float) -> None: ...
    @typing.overload
    def waitForStableLock(self) -> None: ...
    @typing.overload
    def waitForStableLock(self, double: float, long: int) -> None: ...
    class RefMode(java.lang.Enum['LockIn.RefMode']):
        INTERNAL: typing.ClassVar['LockIn.RefMode'] = ...
        EXTERNAL: typing.ClassVar['LockIn.RefMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'LockIn.RefMode': ...
        @staticmethod
        def values() -> typing.MutableSequence['LockIn.RefMode']: ...
    class TrigMode(java.lang.Enum['LockIn.TrigMode']):
        SINE: typing.ClassVar['LockIn.TrigMode'] = ...
        POS_TTL: typing.ClassVar['LockIn.TrigMode'] = ...
        NEG_TTL: typing.ClassVar['LockIn.TrigMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'LockIn.TrigMode': ...
        @staticmethod
        def values() -> typing.MutableSequence['LockIn.TrigMode']: ...

class MSwitch(Switch, MultiInstrument):
    def checkChannel(self, int: int) -> None: ...
    def getChannel(self, int: int) -> Switch: ...
    def getChannels(self) -> java.util.List[Switch]: ...
    @staticmethod
    def getDescription() -> str: ...
    @typing.overload
    def getName(self) -> str: ...
    @typing.overload
    def getName(self, int: int) -> str: ...
    def getNumChannels(self) -> int: ...
    _getSubInstruments_1__I = typing.TypeVar('_getSubInstruments_1__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_1__I]) -> java.util.List[_getSubInstruments_1__I]: ...
    @typing.overload
    def isOn(self, int: int) -> bool: ...
    @typing.overload
    def isOn(self) -> bool: ...
    @typing.overload
    def setOn(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def setOn(self, boolean: bool) -> None: ...
    @typing.overload
    def turnOff(self, int: int) -> None: ...
    @typing.overload
    def turnOff(self) -> None: ...
    @typing.overload
    def turnOn(self, int: int) -> None: ...
    @typing.overload
    def turnOn(self) -> None: ...

class TCouple(TMeter):
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> jisa.devices.PList: ...
    def getSensorType(self) -> 'TCouple.Type': ...
    def setSensorType(self, type: 'TCouple.Type') -> None: ...
    class Type(java.lang.Enum['TCouple.Type']):
        UNKNOWN: typing.ClassVar['TCouple.Type'] = ...
        B: typing.ClassVar['TCouple.Type'] = ...
        E: typing.ClassVar['TCouple.Type'] = ...
        J: typing.ClassVar['TCouple.Type'] = ...
        K: typing.ClassVar['TCouple.Type'] = ...
        N: typing.ClassVar['TCouple.Type'] = ...
        R: typing.ClassVar['TCouple.Type'] = ...
        S: typing.ClassVar['TCouple.Type'] = ...
        T: typing.ClassVar['TCouple.Type'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'TCouple.Type': ...
        @staticmethod
        def values() -> typing.MutableSequence['TCouple.Type']: ...

class VMeter(Instrument, Switch):
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIntegrationTime(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isOn(self) -> bool: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...
    def waitForStableVoltage(self, double: float, int: int) -> None: ...

class VSource(Instrument, Switch):
    @staticmethod
    def getDescription() -> str: ...
    def getVoltage(self) -> float: ...
    def isOn(self) -> bool: ...
    def setVoltage(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...

class XYZTranslationStage(XYTranslationStage):
    def getZPosition(self) -> float: ...
    def getZSpeed(self) -> float: ...
    def setZPosition(self, double: float) -> None: ...
    def setZSpeed(self, double: float) -> None: ...

class DPLockIn(LockIn):
    def autoOffset(self) -> None: ...
    def autoOffsetAmplitude(self) -> None: ...
    def autoOffsetX(self) -> None: ...
    def autoOffsetY(self) -> None: ...
    @staticmethod
    def getDescription() -> str: ...
    def getLockedPhase(self) -> float: ...
    def getLockedX(self) -> float: ...
    def getLockedY(self) -> float: ...

class IPALockIn(LockIn):
    def getCurrentInputGain(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def isCurrentInputEnabled(self) -> bool: ...
    def setCurrentInputEnabled(self, boolean: bool) -> None: ...
    def setCurrentInputGain(self, double: float) -> None: ...

class IVMeter(VMeter, IMeter):
    @staticmethod
    def getDescription() -> str: ...
    def getIVPoint(self) -> jisa.experiment.IVPoint: ...
    def setRanges(self, double: float, double2: float) -> None: ...
    def useAutoRanges(self) -> None: ...

class IVSource(ISource, VSource):
    @staticmethod
    def getDescription() -> str: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...

class ProbeStation(XYZTranslationStage):
    def continMovement(self, string: str, double: float) -> None: ...
    @staticmethod
    def getDescription() -> str: ...
    def getGrossUpDistance(self) -> float: ...
    def getLightOn(self) -> bool: ...
    def getLockDistance(self) -> float: ...
    def goLoadPosition(self) -> None: ...
    def goProbingZoneCentre(self) -> None: ...
    def isGrossLocked(self) -> bool: ...
    def isLocked(self) -> bool: ...
    def setGrossUp(self, boolean: bool) -> None: ...
    def setGrossUpDistance(self, double: float) -> None: ...
    def setLightOn(self, boolean: bool) -> None: ...
    def setLockDistance(self, double: float) -> None: ...
    def setLocked(self, boolean: bool) -> None: ...

class DCPower(IVSource):
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def isOn(self) -> bool: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setOn(self, boolean: bool) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def waitForStableCurrent(self, double: float, long: int) -> None: ...
    def waitForStableVoltage(self, double: float, long: int) -> None: ...

class DPIPALockIn(IPALockIn, DPLockIn):
    @staticmethod
    def getDescription() -> str: ...

class SMU(IVMeter, IVSource):
    def asAmmeter(self) -> IMeter: ...
    def asVoltmeter(self) -> VMeter: ...
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    def getCurrentLimit(self) -> float: ...
    def getCurrentRange(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIVPoint(self) -> jisa.experiment.IVPoint: ...
    def getIntegrationTime(self) -> float: ...
    def getMeasureRange(self) -> float: ...
    def getMeasureValue(self) -> float: ...
    def getOffMode(self) -> 'SMU.OffMode': ...
    def getOutputLimit(self) -> float: ...
    def getSource(self) -> jisa.enums.Source: ...
    def getSourceRange(self) -> float: ...
    def getSourceValue(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isAutoRangingMeasure(self) -> bool: ...
    def isAutoRangingSource(self) -> bool: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    def pulseVoltage(self, double: float, double2: float, double3: float) -> float: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setAveraging(self, aMode: jisa.enums.AMode, int: int) -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLimits(self, double: float, double2: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def setMeasureRange(self, double: float) -> None: ...
    def setOffMode(self, offMode: 'SMU.OffMode') -> None: ...
    def setOn(self, boolean: bool) -> None: ...
    def setOutputLimit(self, double: float) -> None: ...
    def setRanges(self, double: float, double2: float) -> None: ...
    def setSource(self, source: jisa.enums.Source) -> None: ...
    def setSourceRange(self, double: float) -> None: ...
    def setSourceValue(self, double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def useAutoMeasureRange(self) -> None: ...
    def useAutoRanges(self) -> None: ...
    def useAutoSourceRange(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...
    class OffMode(java.lang.Enum['SMU.OffMode']):
        NORMAL: typing.ClassVar['SMU.OffMode'] = ...
        ZERO: typing.ClassVar['SMU.OffMode'] = ...
        HIGH_IMPEDANCE: typing.ClassVar['SMU.OffMode'] = ...
        GUARD: typing.ClassVar['SMU.OffMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SMU.OffMode': ...
        @staticmethod
        def values() -> typing.MutableSequence['SMU.OffMode']: ...

class PID(Instrument, MultiInstrument):
    def getInput(self, int: int) -> 'PID.Input': ...
    def getInputs(self) -> java.util.List['PID.Input']: ...
    def getLoop(self, int: int) -> 'PID.Loop': ...
    def getLoops(self) -> java.util.List['PID.Loop']: ...
    def getOutput(self, int: int) -> 'PID.Output': ...
    def getOutputs(self) -> java.util.List['PID.Output']: ...
    class Input(Instrument):
        def close(self) -> None: ...
        def getName(self) -> str: ...
        def getRange(self) -> float: ...
        def getSensorName(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> float: ...
        def getValueName(self) -> str: ...
        def setRange(self, double: float) -> None: ...
    class Loop(Instrument):
        def close(self) -> None: ...
        def getAvailableInputs(self) -> java.util.List['PID.Input']: ...
        def getAvailableOutputs(self) -> java.util.List['PID.Output']: ...
        @typing.overload
        def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
        @typing.overload
        def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[Instrument.Parameter[typing.Any]]: ...
        def getDValue(self) -> float: ...
        def getIValue(self) -> float: ...
        def getInput(self) -> 'PID.Input': ...
        def getManualValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOutput(self) -> 'PID.Output': ...
        def getPIDZones(self) -> java.util.List['PID.Zone']: ...
        def getPValue(self) -> float: ...
        def getRampRate(self) -> float: ...
        def getSetPoint(self) -> float: ...
        def isPIDEnabled(self) -> bool: ...
        def isPIDZoningEnabled(self) -> bool: ...
        def isRampEnabled(self) -> bool: ...
        def setDValue(self, double: float) -> None: ...
        def setIValue(self, double: float) -> None: ...
        def setInput(self, input: 'PID.Input') -> None: ...
        def setManualValue(self, double: float) -> None: ...
        def setOutput(self, output: 'PID.Output') -> None: ...
        def setPIDEnabled(self, boolean: bool) -> None: ...
        def setPIDValues(self, double: float, double2: float, double3: float) -> None: ...
        @typing.overload
        def setPIDZones(self, list: java.util.List['PID.Zone']) -> None: ...
        @typing.overload
        def setPIDZones(self, *zone: 'PID.Zone') -> None: ...
        def setPIDZoningEnabled(self, boolean: bool) -> None: ...
        def setPValue(self, double: float) -> None: ...
        def setRampEnabled(self, boolean: bool) -> None: ...
        def setRampRate(self, double: float) -> None: ...
        def setSetPoint(self, double: float) -> None: ...
        def waitForStableValue(self, double: float, double2: float, long: int) -> None: ...
    class Output(Instrument):
        def close(self) -> None: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> float: ...
        def getValueName(self) -> str: ...
        def setLimit(self, double: float) -> None: ...
    class Zone:
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, double4: float): ...
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float): ...
        @typing.overload
        def __init__(self, jSONObject: org.json.JSONObject): ...
        def getD(self) -> float: ...
        def getI(self) -> float: ...
        def getLimit(self) -> float: ...
        def getMax(self) -> float: ...
        def getMin(self) -> float: ...
        def getOutput(self) -> float: ...
        def getP(self) -> float: ...
        def isAuto(self) -> bool: ...
        def matches(self, double: float) -> bool: ...
        def toJSON(self) -> org.json.JSONObject: ...
    class ZonedLoop(jisa.devices.interfaces.PID.Loop):
        def __init__(self): ...
        def getPIDZones(self) -> java.util.List['PID.Zone']: ...
        def isPIDZoningEnabled(self) -> bool: ...
        @typing.overload
        def setPIDZones(self, *zone: 'PID.Zone') -> None: ...
        @typing.overload
        def setPIDZones(self, list: java.util.List['PID.Zone']) -> None: ...
        def setPIDZoningEnabled(self, boolean: bool) -> None: ...

class TC(PID, MultiInstrument):
    @staticmethod
    def getDescription() -> str: ...
    def getHeaters(self) -> java.util.List['TC.Heater']: ...
    def getLoop(self, int: int) -> 'TC.Loop': ...
    def getLoops(self) -> java.util.List['TC.Loop']: ...
    _getSubInstruments_0__I = typing.TypeVar('_getSubInstruments_0__I', bound=Instrument)  # <I>
    @typing.overload
    def getSubInstruments(self, class_: typing.Type[_getSubInstruments_0__I]) -> java.util.List[_getSubInstruments_0__I]: ...
    @typing.overload
    def getSubInstruments(self) -> java.util.List[Instrument]: ...
    def getThermometers(self) -> java.util.List['TC.TMeter']: ...
    class Heater(PID.Output):
        def getPower(self) -> float: ...
        def getUnits(self) -> str: ...
        def getValueName(self) -> str: ...
    class Loop(PID.Loop):
        def getAvailableHeaters(self) -> java.util.List['TC.Heater']: ...
        def getAvailableThermometers(self) -> java.util.List['TC.TMeter']: ...
        def getSetPoint(self) -> float: ...
        def getTemperature(self) -> float: ...
        def setSetPoint(self, double: float) -> None: ...
        def setTemperature(self, double: float) -> None: ...
        def waitForStableTemperature(self, double: float, double2: float, long: int) -> None: ...
    class TMeter(PID.Input, TMeter):
        def getRange(self) -> float: ...
        def getSensorName(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> float: ...
        def getValueName(self) -> str: ...
        def setRange(self, double: float) -> None: ...
    class ZonedLoop(PID.ZonedLoop, jisa.devices.interfaces.TC.Loop):
        def __init__(self): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.devices.interfaces")``.

    Camera: typing.Type[Camera]
    DCPower: typing.Type[DCPower]
    DPIPALockIn: typing.Type[DPIPALockIn]
    DPLockIn: typing.Type[DPLockIn]
    EMController: typing.Type[EMController]
    FMeter: typing.Type[FMeter]
    FunctionGenerator: typing.Type[FunctionGenerator]
    IMeter: typing.Type[IMeter]
    IPALockIn: typing.Type[IPALockIn]
    ISource: typing.Type[ISource]
    IVMeter: typing.Type[IVMeter]
    IVSource: typing.Type[IVSource]
    Instrument: typing.Type[Instrument]
    LevelMeter: typing.Type[LevelMeter]
    LineFilter: typing.Type[LineFilter]
    LineFilter2X: typing.Type[LineFilter2X]
    LockIn: typing.Type[LockIn]
    MCSMU: typing.Type[MCSMU]
    MSTMeter: typing.Type[MSTMeter]
    MSwitch: typing.Type[MSwitch]
    MultiInstrument: typing.Type[MultiInstrument]
    PID: typing.Type[PID]
    ProbeStation: typing.Type[ProbeStation]
    SMU: typing.Type[SMU]
    SPA: typing.Type[SPA]
    Spectrometer: typing.Type[Spectrometer]
    SubInstrument: typing.Type[SubInstrument]
    Switch: typing.Type[Switch]
    TC: typing.Type[TC]
    TCouple: typing.Type[TCouple]
    TMeter: typing.Type[TMeter]
    Translator: typing.Type[Translator]
    VMeter: typing.Type[VMeter]
    VPreAmp: typing.Type[VPreAmp]
    VSource: typing.Type[VSource]
    XYTranslationStage: typing.Type[XYTranslationStage]
    XYZTranslationStage: typing.Type[XYZTranslationStage]
