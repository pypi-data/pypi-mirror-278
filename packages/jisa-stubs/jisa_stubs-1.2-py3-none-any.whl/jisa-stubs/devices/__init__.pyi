
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jisa.control
import jisa.devices.amp
import jisa.devices.camera
import jisa.devices.funcgen
import jisa.devices.interfaces
import jisa.devices.level
import jisa.devices.power
import jisa.devices.probestation
import jisa.devices.relay
import jisa.devices.smu
import jisa.devices.spectrometer
import jisa.devices.temperature
import jisa.devices.vmeter
import jpype
import kotlin.reflect
import typing



_Configuration__Parameter__S = typing.TypeVar('_Configuration__Parameter__S')  # <S>
_Configuration__T = typing.TypeVar('_Configuration__T', bound=jisa.devices.interfaces.Instrument)  # <T>
class Configuration(typing.Generic[_Configuration__T]):
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Configuration__T]): ...
    @typing.overload
    def __init__(self, string: str, kClass: kotlin.reflect.KClass[_Configuration__T]): ...
    def addChangeListener(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> jisa.control.SRunnable: ...
    def configure(self) -> _Configuration__T: ...
    def get(self) -> _Configuration__T: ...
    def getChoice(self) -> int: ...
    def getChoiceName(self) -> str: ...
    def getChoices(self) -> java.util.List[str]: ...
    def getInputInstrument(self) -> jisa.devices.interfaces.Instrument: ...
    def getInstrument(self) -> _Configuration__T: ...
    def getName(self) -> str: ...
    def getParameters(self) -> java.util.List['Configuration.Parameter'[typing.Any]]: ...
    def getTarget(self) -> typing.Type[_Configuration__T]: ...
    def isChoice(self) -> bool: ...
    def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def removeChangeListener(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def selectChoice(self, int: int) -> None: ...
    def setInputInstrument(self, instrument: jisa.devices.interfaces.Instrument) -> None: ...
    def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    class Parameter(typing.Generic[_Configuration__Parameter__S]):
        @typing.overload
        def __init__(self, parameter: jisa.devices.interfaces.Instrument.Parameter[_Configuration__Parameter__S]): ...
        @typing.overload
        def __init__(self, parameter: jisa.devices.interfaces.Instrument.Parameter[_Configuration__Parameter__S], configuration: 'Configuration'[typing.Any]): ...
        def getChoices(self) -> java.util.List[_Configuration__Parameter__S]: ...
        def getName(self) -> str: ...
        def getType(self) -> typing.Type[_Configuration__Parameter__S]: ...
        def getValue(self) -> _Configuration__Parameter__S: ...
        def isChoice(self) -> bool: ...
        def setValue(self, s2: _Configuration__Parameter__S) -> None: ...
        def write(self) -> None: ...

class DeviceException(java.lang.Exception):
    def __init__(self, string: str, *object: typing.Any): ...
    def getMessage(self) -> str: ...

class PList(java.util.LinkedList[jisa.devices.interfaces.Instrument.Parameter[typing.Any]]):
    def __init__(self): ...
    _addAuto__T = typing.TypeVar('_addAuto__T')  # <T>
    def addAuto(self, string: str, boolean: bool, t: _addAuto__T, setter: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addAuto__T], typing.Callable[[_addAuto__T], None]], setter2: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addAuto__T], typing.Callable[[_addAuto__T], None]]) -> None: ...
    _addChoice__T = typing.TypeVar('_addChoice__T')  # <T>
    def addChoice(self, string: str, t: _addChoice__T, setter: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addChoice__T], typing.Callable[[_addChoice__T], None]], *t2: _addChoice__T) -> None: ...
    def addDoubleTable(self, string: str, stringArray: typing.Union[typing.List[str], jpype.JArray], list: java.util.List[java.util.List[float]], setter: typing.Union[jisa.devices.interfaces.Instrument.Setter[java.util.List[java.util.List[float]]], typing.Callable[[java.util.List[java.util.List[float]]], None]]) -> None: ...
    _addOptional__T = typing.TypeVar('_addOptional__T')  # <T>
    def addOptional(self, string: str, boolean: bool, t: _addOptional__T, setter: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addOptional__T], typing.Callable[[_addOptional__T], None]], setter2: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addOptional__T], typing.Callable[[_addOptional__T], None]]) -> None: ...
    _addValue__T = typing.TypeVar('_addValue__T')  # <T>
    def addValue(self, string: str, t: _addValue__T, setter: typing.Union[jisa.devices.interfaces.Instrument.Setter[_addValue__T], typing.Callable[[_addValue__T], None]]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.devices")``.

    Configuration: typing.Type[Configuration]
    DeviceException: typing.Type[DeviceException]
    PList: typing.Type[PList]
    amp: jisa.devices.amp.__module_protocol__
    camera: jisa.devices.camera.__module_protocol__
    funcgen: jisa.devices.funcgen.__module_protocol__
    interfaces: jisa.devices.interfaces.__module_protocol__
    level: jisa.devices.level.__module_protocol__
    power: jisa.devices.power.__module_protocol__
    probestation: jisa.devices.probestation.__module_protocol__
    relay: jisa.devices.relay.__module_protocol__
    smu: jisa.devices.smu.__module_protocol__
    spectrometer: jisa.devices.spectrometer.__module_protocol__
    temperature: jisa.devices.temperature.__module_protocol__
    vmeter: jisa.devices.vmeter.__module_protocol__
