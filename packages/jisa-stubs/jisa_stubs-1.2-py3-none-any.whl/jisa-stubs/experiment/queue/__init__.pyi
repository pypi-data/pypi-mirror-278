
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import javafx.scene.image
import jisa.control
import jisa.experiment
import jisa.gui.queue
import jisa.results
import typing



_Action__T = typing.TypeVar('_Action__T')  # <T>
class Action(java.io.Serializable, typing.Generic[_Action__T]):
    def addAttributeListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> 'Listener'['Action'[_Action__T]]: ...
    def addChildrenListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> 'Listener'['Action'[_Action__T]]: ...
    def addListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> 'Listener'['Action'[_Action__T]]: ...
    def addNameListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> 'Listener'['Action'[_Action__T]]: ...
    def addStatusListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> 'Listener'['Action'[_Action__T]]: ...
    def addTag(self, string: str) -> None: ...
    def clearTags(self) -> None: ...
    def copy(self) -> 'Action'[_Action__T]: ...
    def getAttribute(self, string: str) -> str: ...
    @typing.overload
    def getAttributeString(self) -> str: ...
    @typing.overload
    def getAttributeString(self, string: str, string2: str) -> str: ...
    def getAttributes(self) -> java.util.Map[str, str]: ...
    def getChildren(self) -> java.util.List['Action']: ...
    def getData(self) -> _Action__T: ...
    def getDisplay(self) -> jisa.gui.queue.ActionDisplay['Action'[_Action__T]]: ...
    def getError(self) -> java.lang.Exception: ...
    def getName(self) -> str: ...
    def getStatus(self) -> 'Action.Status': ...
    def getStatusListeners(self) -> java.util.List['Listener'['Action'[_Action__T]]]: ...
    def getTags(self) -> java.util.List[str]: ...
    def hasAttribute(self, string: str) -> bool: ...
    def isCritical(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def removeAttribute(self, string: str) -> None: ...
    def removeListener(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> None: ...
    def removeTag(self, string: str) -> None: ...
    def reset(self) -> None: ...
    def resume(self) -> None: ...
    def setAttribute(self, string: str, string2: str) -> None: ...
    def setCritical(self, boolean: bool) -> None: ...
    def setName(self, string: str) -> None: ...
    def setOnFinish(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> None: ...
    def setOnStart(self, listener: typing.Union['Listener'['Action'[_Action__T]], typing.Callable[['Action'[_Action__T]], None]]) -> None: ...
    def setStatus(self, status: 'Action.Status') -> None: ...
    def skip(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def userEdit(self) -> None: ...
    class Status(java.lang.Enum['Action.Status']):
        NOT_STARTED: typing.ClassVar['Action.Status'] = ...
        RUNNING: typing.ClassVar['Action.Status'] = ...
        RETRY: typing.ClassVar['Action.Status'] = ...
        STOPPING: typing.ClassVar['Action.Status'] = ...
        INTERRUPTED: typing.ClassVar['Action.Status'] = ...
        SKIPPED: typing.ClassVar['Action.Status'] = ...
        COMPLETED: typing.ClassVar['Action.Status'] = ...
        ERROR: typing.ClassVar['Action.Status'] = ...
        def getImage(self) -> javafx.scene.image.Image: ...
        def getText(self) -> str: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Action.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['Action.Status']: ...

_ActionQueue__ListListener__T = typing.TypeVar('_ActionQueue__ListListener__T')  # <T>
class ActionQueue(java.io.Serializable):
    def __init__(self): ...
    _addAction__T = typing.TypeVar('_addAction__T', bound=Action)  # <T>
    def addAction(self, t: _addAction__T) -> _addAction__T: ...
    @typing.overload
    def addActions(self, collection: typing.Union[java.util.Collection[Action[typing.Any]], typing.Sequence[Action[typing.Any]], typing.Set[Action[typing.Any]]]) -> None: ...
    @typing.overload
    def addActions(self, *action: Action) -> None: ...
    def addListener(self, listListener: typing.Union['ActionQueue.ListListener'[Action[typing.Any]], typing.Callable[[java.util.Collection[typing.Any], java.util.Collection[typing.Any], java.util.Map[int, typing.Any]], None]]) -> 'ActionQueue.ListListener'[Action[typing.Any]]: ...
    def clear(self) -> None: ...
    def getActions(self) -> java.util.List[Action[typing.Any]]: ...
    def getInterruptedAction(self) -> Action[typing.Any]: ...
    def getStartActions(self) -> 'ActionQueue': ...
    def getStopActions(self) -> 'ActionQueue': ...
    def indexOf(self, action: Action[typing.Any]) -> int: ...
    def isInterrupted(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def loadActions(self, string: str) -> None: ...
    def removeAction(self, action: Action) -> None: ...
    @typing.overload
    def removeActions(self, collection: typing.Union[java.util.Collection[Action[typing.Any]], typing.Sequence[Action[typing.Any]], typing.Set[Action[typing.Any]]]) -> None: ...
    @typing.overload
    def removeActions(self, *action: Action) -> None: ...
    def removeListener(self, listListener: typing.Union['ActionQueue.ListListener'[Action], typing.Callable[[java.util.Collection[typing.Any], java.util.Collection[typing.Any], java.util.Map[int, typing.Any]], None]]) -> None: ...
    def resume(self) -> 'ActionQueue.Result': ...
    def saveActions(self, string: str) -> None: ...
    def size(self) -> int: ...
    def start(self) -> 'ActionQueue.Result': ...
    def stop(self) -> None: ...
    @typing.overload
    def swapActions(self, int: int, int2: int) -> None: ...
    @typing.overload
    def swapActions(self, action: Action, action2: Action) -> None: ...
    class ListListener(typing.Generic[_ActionQueue__ListListener__T]):
        @typing.overload
        def added(self, t: _ActionQueue__ListListener__T) -> None: ...
        @typing.overload
        def added(self, collection: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]]) -> None: ...
        def addedAndRemoved(self, collection: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]], collection2: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]]) -> None: ...
        def moved(self, map: typing.Union[java.util.Map[int, _ActionQueue__ListListener__T], typing.Mapping[int, _ActionQueue__ListListener__T]]) -> None: ...
        @typing.overload
        def removed(self, t: _ActionQueue__ListListener__T) -> None: ...
        @typing.overload
        def removed(self, collection: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]]) -> None: ...
        def update(self, collection: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]], collection2: typing.Union[java.util.Collection[_ActionQueue__ListListener__T], typing.Sequence[_ActionQueue__ListListener__T], typing.Set[_ActionQueue__ListListener__T]], map: typing.Union[java.util.Map[int, _ActionQueue__ListListener__T], typing.Mapping[int, _ActionQueue__ListListener__T]]) -> None: ...
    class Result(java.lang.Enum['ActionQueue.Result']):
        SUCCESS: typing.ClassVar['ActionQueue.Result'] = ...
        INTERRUPTED: typing.ClassVar['ActionQueue.Result'] = ...
        ERROR: typing.ClassVar['ActionQueue.Result'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ActionQueue.Result': ...
        @staticmethod
        def values() -> typing.MutableSequence['ActionQueue.Result']: ...

_Listener__T = typing.TypeVar('_Listener__T')  # <T>
class Listener(typing.Generic[_Listener__T]):
    def update(self, t: _Listener__T) -> None: ...
    def updateRegardless(self, t: _Listener__T) -> None: ...

_AbstractAction__T = typing.TypeVar('_AbstractAction__T')  # <T>
class AbstractAction(Action[_AbstractAction__T], typing.Generic[_AbstractAction__T]):
    def __init__(self): ...
    def addAttributeListener(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> Listener[Action[_AbstractAction__T]]: ...
    def addChildrenListener(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> Listener[Action[_AbstractAction__T]]: ...
    def addNameListener(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> Listener[Action[_AbstractAction__T]]: ...
    def addStatusListener(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> Listener[Action[_AbstractAction__T]]: ...
    def addTag(self, string: str) -> None: ...
    def clearTags(self) -> None: ...
    def getAttribute(self, string: str) -> str: ...
    def getAttributes(self) -> java.util.Map[str, str]: ...
    def getChildren(self) -> java.util.List[Action]: ...
    def getData(self) -> _AbstractAction__T: ...
    def getName(self) -> str: ...
    def getStatus(self) -> Action.Status: ...
    def getStatusListeners(self) -> java.util.List[Listener[Action[_AbstractAction__T]]]: ...
    def getTags(self) -> java.util.List[str]: ...
    def hasAttribute(self, string: str) -> bool: ...
    def isCritical(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def removeAttribute(self, string: str) -> None: ...
    def removeListener(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> None: ...
    def removeTag(self, string: str) -> None: ...
    def reset(self) -> None: ...
    def setAttribute(self, string: str, string2: str) -> None: ...
    def setCritical(self, boolean: bool) -> None: ...
    def setName(self, string: str) -> None: ...
    def setOnEdit(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> None: ...
    def setOnFinish(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> None: ...
    def setOnStart(self, listener: typing.Union[Listener[Action[_AbstractAction__T]], typing.Callable[[Action[_AbstractAction__T]], None]]) -> None: ...
    def setStatus(self, status: Action.Status) -> None: ...
    def skip(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def userEdit(self) -> None: ...

class MeasurementAction(AbstractAction[jisa.results.ResultTable]):
    @typing.overload
    def __init__(self, string: str, measurement: jisa.experiment.Measurement): ...
    @typing.overload
    def __init__(self, measurement: jisa.experiment.Measurement): ...
    def copy(self) -> 'MeasurementAction': ...
    def generateFilePath(self) -> str: ...
    def getChildren(self) -> java.util.List[Action]: ...
    def getData(self) -> jisa.results.ResultTable: ...
    def getDisplay(self) -> jisa.gui.queue.SimpleActionDisplay: ...
    def getError(self) -> java.lang.Exception: ...
    def getMeasurement(self) -> jisa.experiment.Measurement: ...
    def getRetryCount(self) -> int: ...
    def isRunning(self) -> bool: ...
    def reset(self) -> None: ...
    def setAttribute(self, string: str, string2: str) -> None: ...
    def setFileNameGenerator(self, nameGenerator: typing.Union['MeasurementAction.NameGenerator', typing.Callable]) -> None: ...
    def setOnMeasurementFinish(self, listener: typing.Union[Listener['MeasurementAction'], typing.Callable[['MeasurementAction'], None]]) -> None: ...
    def setOnMeasurementStart(self, listener: typing.Union[Listener['MeasurementAction'], typing.Callable[['MeasurementAction'], None]]) -> None: ...
    def setRetryCount(self, int: int) -> None: ...
    def skip(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def userEdit(self) -> None: ...
    class NameGenerator:
        def makeName(self, string: str, string2: str) -> str: ...

class SimpleAction(AbstractAction[None]):
    def __init__(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]): ...
    def copy(self) -> 'SimpleAction': ...
    def getChildren(self) -> java.util.List[Action]: ...
    def getData(self) -> None: ...
    def getDisplay(self) -> jisa.gui.queue.SimpleActionDisplay: ...
    def getError(self) -> java.lang.Exception: ...
    def isRunning(self) -> bool: ...
    def reset(self) -> None: ...
    def skip(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

_SweepAction__ActionGenerator__T = typing.TypeVar('_SweepAction__ActionGenerator__T')  # <T>
_SweepAction__Formatter__T = typing.TypeVar('_SweepAction__Formatter__T')  # <T>
_SweepAction__T = typing.TypeVar('_SweepAction__T')  # <T>
class SweepAction(AbstractAction[None], typing.Generic[_SweepAction__T]):
    def __init__(self, string: str, iterable: typing.Union[java.lang.Iterable[_SweepAction__T], typing.Sequence[_SweepAction__T], typing.Set[_SweepAction__T], typing.Callable[[], java.util.Iterator[typing.Any]]], actionGenerator: typing.Union['SweepAction.ActionGenerator'[_SweepAction__T], typing.Callable[[_SweepAction__T, java.util.List[Action[typing.Any]]], java.util.List[Action]]]): ...
    _addAction__R = typing.TypeVar('_addAction__R', bound=Action)  # <R>
    def addAction(self, r: _addAction__R) -> _addAction__R: ...
    def addActions(self, collection: typing.Union[java.util.Collection[Action], typing.Sequence[Action], typing.Set[Action]]) -> None: ...
    _addFinalAction__R = typing.TypeVar('_addFinalAction__R', bound=Action)  # <R>
    def addFinalAction(self, r: _addFinalAction__R) -> _addFinalAction__R: ...
    def addFinalActions(self, collection: typing.Union[java.util.Collection[Action], typing.Sequence[Action], typing.Set[Action]]) -> None: ...
    def addSweepValueListener(self, listener: typing.Union[Listener[_SweepAction__T], typing.Callable[[_SweepAction__T], None]]) -> Listener[_SweepAction__T]: ...
    def addTag(self, string: str) -> None: ...
    def clearActions(self) -> None: ...
    def clearFinalActions(self) -> None: ...
    def clearTags(self) -> None: ...
    def copy(self) -> 'SweepAction'[_SweepAction__T]: ...
    def format(self, t: _SweepAction__T) -> str: ...
    def generateActionsForValue(self, t: _SweepAction__T) -> java.util.List[Action]: ...
    def getActions(self) -> java.util.List[Action]: ...
    def getChildren(self) -> java.util.List[Action]: ...
    def getChildrenByIndex(self, int: int) -> java.util.List[Action]: ...
    def getChildrenByValue(self, t: _SweepAction__T) -> java.util.List[Action]: ...
    def getCurrentSweepIndex(self) -> int: ...
    def getCurrentSweepString(self) -> str: ...
    def getData(self) -> None: ...
    def getDisplay(self) -> jisa.gui.queue.SweepActionDisplay[_SweepAction__T]: ...
    def getError(self) -> java.lang.Exception: ...
    def getFinalActions(self) -> java.util.List[Action]: ...
    def getMeasurement(self) -> jisa.experiment.Measurement: ...
    def getSweepStrings(self) -> java.util.List[str]: ...
    def getSweepValues(self) -> java.util.List[_SweepAction__T]: ...
    def isRunning(self) -> bool: ...
    def removeAction(self, action: Action) -> None: ...
    def removeActions(self, collection: typing.Union[java.util.Collection[Action], typing.Sequence[Action], typing.Set[Action]]) -> None: ...
    def removeFinalAction(self, action: Action) -> None: ...
    def removeSweepValueListener(self, listener: typing.Union[Listener, typing.Callable]) -> None: ...
    def removeTag(self, string: str) -> None: ...
    def reset(self) -> None: ...
    def resume(self) -> None: ...
    def setAttribute(self, string: str, string2: str) -> None: ...
    def setFormatter(self, formatter: typing.Union['SweepAction.Formatter'[_SweepAction__T], typing.Callable[[_SweepAction__T], str]]) -> None: ...
    def setMeasurement(self, measurement: jisa.experiment.Measurement) -> None: ...
    @typing.overload
    def setSweepValues(self, iterable: typing.Union[java.lang.Iterable[_SweepAction__T], typing.Sequence[_SweepAction__T], typing.Set[_SweepAction__T], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> None: ...
    @typing.overload
    def setSweepValues(self, *t: _SweepAction__T) -> None: ...
    def skip(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    class ActionGenerator(typing.Generic[_SweepAction__ActionGenerator__T]):
        def generate(self, t: _SweepAction__ActionGenerator__T, list: java.util.List[Action[typing.Any]]) -> java.util.List[Action]: ...
    class Formatter(typing.Generic[_SweepAction__Formatter__T]):
        def format(self, t: _SweepAction__Formatter__T) -> str: ...
    class MultiException(java.lang.Exception):
        @typing.overload
        def __init__(self, *exception: java.lang.Exception): ...
        @typing.overload
        def __init__(self, collection: typing.Union[java.util.Collection[java.lang.Exception], typing.Sequence[java.lang.Exception], typing.Set[java.lang.Exception]]): ...
        def getExceptions(self) -> java.util.List[java.lang.Exception]: ...

class MeasurementSubAction(SimpleAction):
    def __init__(self, string: str): ...
    def complete(self) -> None: ...
    def fail(self) -> None: ...
    def start(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.experiment.queue")``.

    AbstractAction: typing.Type[AbstractAction]
    Action: typing.Type[Action]
    ActionQueue: typing.Type[ActionQueue]
    Listener: typing.Type[Listener]
    MeasurementAction: typing.Type[MeasurementAction]
    MeasurementSubAction: typing.Type[MeasurementSubAction]
    SimpleAction: typing.Type[SimpleAction]
    SweepAction: typing.Type[SweepAction]
