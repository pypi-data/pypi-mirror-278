
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jisa
import jisa.control
import jisa.devices
import jisa.devices.interfaces
import jisa.experiment.queue
import jisa.gui
import jisa.maths
import jisa.maths.functions
import jisa.maths.matrices
import jisa.results
import typing



class Combination(java.lang.Comparable['Combination']):
    def __init__(self, *object: typing.Any): ...
    def compareTo(self, combination: 'Combination') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def toString(self) -> str: ...

class DataFunction(jisa.maths.functions.Function):
    def __init__(self, list: java.util.List['XYPoint']): ...
    @typing.overload
    def value(self, matrix: jisa.maths.matrices.Matrix[float]) -> jisa.maths.matrices.Matrix[float]: ...
    @typing.overload
    def value(self, double: float) -> float: ...

class IVPoint:
    voltage: float = ...
    current: float = ...
    def __init__(self, double: float, double2: float): ...

class MCIVPoint:
    def __init__(self): ...
    def addAll(self, map: typing.Union[java.util.Map[int, IVPoint], typing.Mapping[int, IVPoint]]) -> None: ...
    def addChannel(self, int: int, iVPoint: IVPoint) -> None: ...
    def getChannel(self, int: int) -> IVPoint: ...

class Spectrum(java.lang.Iterable['Spectrum.DataPoint']):
    def __init__(self, list: java.util.List['Spectrum.DataPoint']): ...
    def get(self, int: int) -> 'Spectrum.DataPoint': ...
    def getNearestPoint(self, double: float) -> 'Spectrum.DataPoint': ...
    def interpolate(self) -> jisa.maths.functions.Function: ...
    def iterator(self) -> java.util.Iterator['Spectrum.DataPoint']: ...
    def size(self) -> int: ...
    def toArray(self) -> typing.MutableSequence['Spectrum.DataPoint']: ...
    def toColumnMatrix(self) -> jisa.maths.matrices.RealMatrix: ...
    def toList(self) -> java.util.List['Spectrum.DataPoint']: ...
    def toResultList(self) -> jisa.results.ResultList: ...
    class DataPoint:
        def __init__(self, double: float, double2: float): ...
        def getFrequency(self) -> float: ...
        def getValue(self) -> float: ...

class XYPoint:
    x: float = ...
    y: float = ...
    def __init__(self, double: float, double2: float): ...

_Measurement__CustomParameter__T = typing.TypeVar('_Measurement__CustomParameter__T')  # <T>
_Measurement__Getter__T = typing.TypeVar('_Measurement__Getter__T')  # <T>
_Measurement__Parameter__T = typing.TypeVar('_Measurement__Parameter__T')  # <T>
_Measurement__Reader__T = typing.TypeVar('_Measurement__Reader__T')  # <T>
_Measurement__Setter__T = typing.TypeVar('_Measurement__Setter__T')  # <T>
_Measurement__Writer__T = typing.TypeVar('_Measurement__Writer__T')  # <T>
class Measurement:
    def __init__(self): ...
    _addInstrument_0__T = typing.TypeVar('_addInstrument_0__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    _addInstrument_1__T = typing.TypeVar('_addInstrument_1__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    @typing.overload
    def addInstrument(self, string: str, class_: typing.Type[_addInstrument_0__T]) -> jisa.devices.Configuration[_addInstrument_0__T]: ...
    @typing.overload
    def addInstrument(self, configuration: jisa.devices.Configuration[_addInstrument_1__T]) -> jisa.devices.Configuration[_addInstrument_1__T]: ...
    def getActions(self) -> java.util.List[jisa.experiment.queue.Action]: ...
    def getColumns(self) -> typing.MutableSequence[jisa.results.Column]: ...
    def getInstruments(self) -> java.util.List[jisa.devices.Configuration[jisa.devices.interfaces.Instrument]]: ...
    def getLabel(self) -> str: ...
    def getName(self) -> str: ...
    def getParameters(self) -> java.util.List['Measurement.Parameter'[typing.Any]]: ...
    def getResults(self) -> jisa.results.ResultTable: ...
    def isRunning(self) -> bool: ...
    @typing.overload
    def newResults(self) -> jisa.results.ResultTable: ...
    @typing.overload
    def newResults(self, string: str) -> jisa.results.ResultTable: ...
    def setLabel(self, string: str) -> None: ...
    def sleep(self, int: int) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def wasStopped(self) -> bool: ...
    class BooleanParameter(jisa.experiment.Measurement.Parameter[bool]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, boolean: bool): ...
    class ChoiceParameter(jisa.experiment.Measurement.Parameter[int]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, int: int, *string3: str): ...
    class CustomParameter(jisa.experiment.Measurement.Parameter[_Measurement__CustomParameter__T], typing.Generic[_Measurement__CustomParameter__T]):
        @typing.overload
        def __init__(self, measurement: 'Measurement', string: str, element: jisa.gui.Element, getter: typing.Union['Measurement.Getter', typing.Callable], setter: typing.Union['Measurement.Setter', typing.Callable]): ...
        @typing.overload
        def __init__(self, measurement: 'Measurement', string: str, element: jisa.gui.Element, getter: typing.Union['Measurement.Getter', typing.Callable], setter: typing.Union['Measurement.Setter', typing.Callable], reader: typing.Union['Measurement.Reader', typing.Callable], writer: typing.Union['Measurement.Writer', typing.Callable]): ...
        def getElement(self) -> jisa.gui.Element: ...
        def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
        def setValue(self, t: _Measurement__CustomParameter__T) -> None: ...
        def update(self) -> None: ...
        def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    class DecimalParameter(jisa.experiment.Measurement.Parameter[float]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, double: float): ...
    class DoubleParameter(jisa.experiment.Measurement.Parameter[float]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, double: float): ...
    class Getter(typing.Generic[_Measurement__Getter__T]):
        def get(self) -> _Measurement__Getter__T: ...
    class IntegerParameter(jisa.experiment.Measurement.Parameter[int]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, integer: int): ...
    class Parameter(typing.Generic[_Measurement__Parameter__T]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, object: typing.Any): ...
        def createField(self, fields: jisa.gui.Fields) -> jisa.gui.Field[_Measurement__Parameter__T]: ...
        def getElement(self) -> jisa.gui.Element: ...
        def getName(self) -> str: ...
        def getSection(self) -> str: ...
        def getTitle(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> _Measurement__Parameter__T: ...
        def setValue(self, t: _Measurement__Parameter__T) -> None: ...
        def update(self) -> None: ...
    class RangeParameter(jisa.experiment.Measurement.Parameter[jisa.maths.Range[float]]):
        @typing.overload
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, double: float, double2: float, int: int): ...
        @typing.overload
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, range: jisa.maths.Range): ...
        @typing.overload
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, range: jisa.maths.Range, double: float, double2: float, int: int, double3: float, int2: int): ...
    class Reader(typing.Generic[_Measurement__Reader__T]):
        def read(self, configBlock: jisa.control.ConfigBlock) -> _Measurement__Reader__T: ...
    class Setter(typing.Generic[_Measurement__Setter__T]):
        def set(self, t: _Measurement__Setter__T) -> None: ...
    class StringParameter(jisa.experiment.Measurement.Parameter[str]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, string3: str, string4: str): ...
    class TimeParameter(jisa.experiment.Measurement.Parameter[int]):
        def __init__(self, measurement: 'Measurement', string: str, string2: str, integer: int): ...
    class Writer(typing.Generic[_Measurement__Writer__T]):
        def write(self, configBlock: jisa.control.ConfigBlock, t: _Measurement__Writer__T) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.experiment")``.

    Combination: typing.Type[Combination]
    DataFunction: typing.Type[DataFunction]
    IVPoint: typing.Type[IVPoint]
    MCIVPoint: typing.Type[MCIVPoint]
    Measurement: typing.Type[Measurement]
    Spectrum: typing.Type[Spectrum]
    XYPoint: typing.Type[XYPoint]
    queue: jisa.experiment.queue.__module_protocol__
