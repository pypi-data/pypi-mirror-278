
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import de.gsi.chart
import de.gsi.chart.axes
import de.gsi.chart.axes.spi
import de.gsi.chart.axes.spi.transforms
import de.gsi.chart.plugins
import de.gsi.chart.renderer
import de.gsi.chart.renderer.spi
import de.gsi.chart.ui
import de.gsi.dataset
import de.gsi.dataset.spi
import java.lang
import java.util
import java.util.function
import javafx.beans.property
import javafx.collections
import javafx.scene
import javafx.scene.canvas
import javafx.scene.input
import javafx.scene.layout
import javafx.scene.paint
import javafx.util
import jisa.gui
import jisa.maths.fits
import jisa.maths.matrices
import jisa.results
import jpype
import org.controlsfx.control
import typing



class JISADefaultAxis(de.gsi.chart.axes.spi.AbstractAxis, de.gsi.chart.axes.Axis):
    DEFAULT_LOG_MIN_VALUE: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    def clear(self) -> bool: ...
    def computePreferredTickUnit(self, double: float) -> float: ...
    def forceZeroInRangeProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def getAxisTransform(self) -> de.gsi.chart.axes.AxisTransform: ...
    def getDisplayPosition(self, double: float) -> float: ...
    def getLogAxisType(self) -> de.gsi.chart.axes.LogAxisType: ...
    def getLogarithmBase(self) -> float: ...
    def getValueForDisplay(self, double: float) -> float: ...
    def getZeroPosition(self) -> float: ...
    def isForceZeroInRange(self) -> bool: ...
    def isLogAxis(self) -> bool: ...
    def isValueOnAxis(self, double: float) -> bool: ...
    def logAxisProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def logarithmBaseProperty(self) -> javafx.beans.property.DoubleProperty: ...
    def recordLogValues(self, *double: float) -> None: ...
    def requestAxisLayout(self) -> None: ...
    def setForceZeroInRange(self, boolean: bool) -> None: ...
    def setLogAxis(self, boolean: bool) -> None: ...
    def setLogarithmBase(self, double: float) -> None: ...

class JISALogTransform(de.gsi.chart.axes.spi.transforms.AbstractAxisTransform):
    DEFAULT_LOGARITHM_BASE: typing.ClassVar[float] = ...
    DEFAULT_LOG_MIN_VALUE: typing.ClassVar[float] = ...
    DB20_LOGARITHM_BASE: typing.ClassVar[float] = ...
    DB10_LOGARITHM_BASE: typing.ClassVar[float] = ...
    def __init__(self, axis: de.gsi.chart.axes.Axis): ...
    def backward(self, double: float) -> float: ...
    def forward(self, double: float) -> float: ...
    def getLogarithmBase(self) -> float: ...
    def getRoundedMaximumRange(self, double: float) -> float: ...
    def getRoundedMinimumRange(self, double: float) -> float: ...
    def logarithmBaseProperty(self) -> javafx.beans.property.DoubleProperty: ...
    def setLogarithmBase(self, double: float) -> None: ...
    def setMaximumRange(self, double: float) -> None: ...
    def setMinimumRange(self, double: float) -> None: ...

class JISAMarker:
    CIRCLE: typing.ClassVar['JISAMarker'] = ...
    DOT: typing.ClassVar['JISAMarker'] = ...
    RECTANGLE: typing.ClassVar['JISAMarker'] = ...
    TRIANGLE: typing.ClassVar['JISAMarker'] = ...
    STAR: typing.ClassVar['JISAMarker'] = ...
    DIAMOND: typing.ClassVar['JISAMarker'] = ...
    DASH: typing.ClassVar['JISAMarker'] = ...
    PLUS: typing.ClassVar['JISAMarker'] = ...
    CROSS: typing.ClassVar['JISAMarker'] = ...
    def draw(self, graphicsContext: javafx.scene.canvas.GraphicsContext, double: float, double2: float, double3: float, double4: float, color: javafx.scene.paint.Color, color2: javafx.scene.paint.Color) -> None: ...
    @staticmethod
    def drawRegularPolygon(graphicsContext: javafx.scene.canvas.GraphicsContext, double: float, double2: float, int: int, double3: float, double4: float) -> None: ...
    @staticmethod
    def drawStarPolygon(graphicsContext: javafx.scene.canvas.GraphicsContext, double: float, double2: float, int: int, double3: float, double4: float, double5: float) -> None: ...

class JISARenderer(de.gsi.chart.renderer.spi.AbstractErrorDataSetRendererParameter['JISARenderer'], de.gsi.chart.renderer.Renderer):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def drawLegendSymbol(self, dataSet: de.gsi.dataset.DataSet, int: int, int2: int, int3: int) -> javafx.scene.canvas.Canvas: ...
    def render(self, graphicsContext: javafx.scene.canvas.GraphicsContext, chart: de.gsi.chart.Chart, int: int, observableList: javafx.collections.ObservableList[de.gsi.dataset.DataSet]) -> java.util.List[de.gsi.dataset.DataSet]: ...

class JISASeries(jisa.gui.Series):
    def __init__(self, string: str, plot: jisa.gui.Plot): ...
    @typing.overload
    def addPoint(self, double: float, double2: float) -> jisa.gui.Series: ...
    @typing.overload
    def addPoint(self, double: float, double2: float, double3: float) -> jisa.gui.Series: ...
    @typing.overload
    def addPoint(self, double: float, double2: float, double3: float, double4: float) -> jisa.gui.Series: ...
    @typing.overload
    def addPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> jisa.gui.Series: ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> jisa.gui.Series: ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable4: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> jisa.gui.Series: ...
    @typing.overload
    def addPoints(self, matrix: jisa.maths.matrices.Matrix[float]) -> jisa.gui.Series: ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> jisa.gui.Series: ...
    def clear(self) -> jisa.gui.Series: ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[jisa.results.Row], typing.Callable[[jisa.results.Row], bool]]) -> jisa.gui.Series: ...
    def fit(self, seriesFitter: typing.Union[jisa.gui.Series.SeriesFitter, typing.Callable]) -> jisa.gui.Series: ...
    def getColour(self) -> javafx.scene.paint.Color: ...
    def getDatasets(self) -> javafx.collections.ObservableList['JISAErrorDataSet']: ...
    def getErrorColour(self) -> javafx.scene.paint.Color: ...
    def getErrorLineWidth(self) -> float: ...
    def getFit(self) -> jisa.maths.fits.Fit: ...
    def getLimit(self) -> int: ...
    def getLineDash(self) -> jisa.gui.Series.Dash: ...
    def getLineWidth(self) -> float: ...
    def getMarkerShape(self) -> jisa.gui.Series.Shape: ...
    def getMarkerSize(self) -> float: ...
    def getName(self) -> str: ...
    def getPointOrdering(self) -> jisa.gui.Series.Ordering: ...
    def getWatched(self) -> jisa.results.ResultTable: ...
    def isFitted(self) -> bool: ...
    def isLineVisible(self) -> bool: ...
    def isMarkerVisible(self) -> bool: ...
    def reduceNow(self) -> jisa.gui.Series: ...
    def remove(self) -> jisa.gui.Series: ...
    def removeFit(self) -> jisa.gui.Series: ...
    def removePoint(self, int: int) -> jisa.gui.Series: ...
    def removePoints(self, int: int, int2: int) -> jisa.gui.Series: ...
    def setAutoReduction(self, int: int, int2: int) -> jisa.gui.Series: ...
    def setColour(self, color: javafx.scene.paint.Color) -> jisa.gui.Series: ...
    def setColourSequence(self, *color: javafx.scene.paint.Color) -> jisa.gui.Series: ...
    def setErrorColour(self, color: javafx.scene.paint.Color) -> jisa.gui.Series: ...
    def setErrorLineWidth(self, double: float) -> jisa.gui.Series: ...
    def setLimit(self, int: int) -> jisa.gui.Series: ...
    def setLineDash(self, dash: jisa.gui.Series.Dash) -> jisa.gui.Series: ...
    def setLineVisible(self, boolean: bool) -> jisa.gui.Series: ...
    def setLineWidth(self, double: float) -> jisa.gui.Series: ...
    def setMarkerShape(self, shape: jisa.gui.Series.Shape) -> jisa.gui.Series: ...
    def setMarkerSize(self, double: float) -> jisa.gui.Series: ...
    def setMarkerVisible(self, boolean: bool) -> jisa.gui.Series: ...
    def setName(self, string: str) -> jisa.gui.Series: ...
    def setPointOrder(self, ordering: jisa.gui.Series.Ordering) -> jisa.gui.Series: ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> jisa.gui.Series: ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray]) -> jisa.gui.Series: ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> jisa.gui.Series: ...
    def setXAutoRemove(self, double: float) -> jisa.gui.Series: ...
    def setYAutoRemove(self, double: float) -> jisa.gui.Series: ...
    @typing.overload
    def split(self, column: jisa.results.Column[typing.Any]) -> jisa.gui.Series: ...
    @typing.overload
    def split(self, column: jisa.results.Column[typing.Any], string: str) -> jisa.gui.Series: ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]]) -> jisa.gui.Series: ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]], string: str) -> jisa.gui.Series: ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]], seriesFormatter: typing.Union[jisa.gui.Series.SeriesFormatter, typing.Callable]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], column3: jisa.results.Column[java.lang.Number], column4: jisa.results.Column[java.lang.Number]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable, typing.Callable], rowEvaluable2: typing.Union[jisa.results.RowEvaluable, typing.Callable]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable2: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable3: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], column3: jisa.results.Column[java.lang.Number]) -> jisa.gui.Series: ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable2: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable3: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable4: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]]) -> jisa.gui.Series: ...
    class DataSetSelector:
        def select(self, row: jisa.results.Row) -> 'JISAErrorDataSet': ...

class JISAXYChart(de.gsi.chart.XYChart):
    def __init__(self, *axis: de.gsi.chart.axes.Axis): ...
    def forceRedraw(self) -> None: ...
    def removeTitle(self) -> None: ...

class JISAZoomer(de.gsi.chart.plugins.ChartPlugin):
    ZOOMER_OMIT_AXIS: typing.ClassVar[str] = ...
    STYLE_CLASS_ZOOM_RECT: typing.ClassVar[str] = ...
    DEFAULT_MOUSE_FILTER: typing.ClassVar[java.util.function.Predicate] = ...
    panFilter: java.util.function.Predicate = ...
    defaultZoomInMouseFilter: java.util.function.Predicate = ...
    defaultZoomOutMouseFilter: java.util.function.Predicate = ...
    defaultZoomOriginFilter: java.util.function.Predicate = ...
    defaultScrollFilter: java.util.function.Predicate = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, axisMode: de.gsi.chart.axes.AxisMode): ...
    @typing.overload
    def __init__(self, axisMode: de.gsi.chart.axes.AxisMode, boolean: bool): ...
    def animatedProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def autoZoomEnabledProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def autoZoomThresholdProperty(self) -> javafx.beans.property.IntegerProperty: ...
    def axisModeProperty(self) -> javafx.beans.property.ObjectProperty[de.gsi.chart.axes.AxisMode]: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, axis: de.gsi.chart.axes.Axis) -> None: ...
    def dragCursorProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.Cursor]: ...
    def getAutoZoomThreshold(self) -> int: ...
    def getAxisMode(self) -> de.gsi.chart.axes.AxisMode: ...
    def getDragCursor(self) -> javafx.scene.Cursor: ...
    def getRangeSlider(self) -> org.controlsfx.control.RangeSlider: ...
    def getZoomCursor(self) -> javafx.scene.Cursor: ...
    def getZoomDuration(self) -> javafx.util.Duration: ...
    def getZoomInMouseFilter(self) -> java.util.function.Predicate[javafx.scene.input.MouseEvent]: ...
    def getZoomInteractorBar(self) -> javafx.scene.layout.HBox: ...
    def getZoomOriginMouseFilter(self) -> java.util.function.Predicate[javafx.scene.input.MouseEvent]: ...
    def getZoomOutMouseFilter(self) -> java.util.function.Predicate[javafx.scene.input.MouseEvent]: ...
    def getZoomScrollFilter(self) -> java.util.function.Predicate[javafx.scene.input.ScrollEvent]: ...
    def isAnimated(self) -> bool: ...
    def isAutoZoomEnabled(self) -> bool: ...
    @staticmethod
    def isOmitZoom(axis: de.gsi.chart.axes.Axis) -> bool: ...
    def isPannerEnabled(self) -> bool: ...
    def isSliderVisible(self) -> bool: ...
    def isUpdateTickUnit(self) -> bool: ...
    def omitAxisZoomList(self) -> javafx.collections.ObservableList[de.gsi.chart.axes.Axis]: ...
    def pannerEnabledProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def setAnimated(self, boolean: bool) -> None: ...
    def setAutoZoomEnabled(self, boolean: bool) -> None: ...
    def setAutoZoomThreshold(self, int: int) -> None: ...
    def setAxisMode(self, axisMode: de.gsi.chart.axes.AxisMode) -> None: ...
    def setDragCursor(self, cursor: javafx.scene.Cursor) -> None: ...
    @staticmethod
    def setOmitZoom(axis: de.gsi.chart.axes.Axis, boolean: bool) -> None: ...
    def setPannerEnabled(self, boolean: bool) -> None: ...
    def setSliderVisible(self, boolean: bool) -> None: ...
    def setUpdateTickUnit(self, boolean: bool) -> None: ...
    def setZoomCursor(self, cursor: javafx.scene.Cursor) -> None: ...
    def setZoomDuration(self, duration: javafx.util.Duration) -> None: ...
    def setZoomInMouseFilter(self, predicate: typing.Union[java.util.function.Predicate[javafx.scene.input.MouseEvent], typing.Callable[[javafx.scene.input.MouseEvent], bool]]) -> None: ...
    def setZoomOriginMouseFilter(self, predicate: typing.Union[java.util.function.Predicate[javafx.scene.input.MouseEvent], typing.Callable[[javafx.scene.input.MouseEvent], bool]]) -> None: ...
    def setZoomOutMouseFilter(self, predicate: typing.Union[java.util.function.Predicate[javafx.scene.input.MouseEvent], typing.Callable[[javafx.scene.input.MouseEvent], bool]]) -> None: ...
    def setZoomScrollFilter(self, predicate: typing.Union[java.util.function.Predicate[javafx.scene.input.ScrollEvent], typing.Callable[[javafx.scene.input.ScrollEvent], bool]]) -> None: ...
    def sliderVisibleProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def updateTickUnitProperty(self) -> javafx.beans.property.BooleanProperty: ...
    def zoomCursorProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.Cursor]: ...
    def zoomDurationProperty(self) -> javafx.beans.property.ObjectProperty[javafx.util.Duration]: ...
    def zoomOrigin(self) -> bool: ...
    def zoomStackDeque(self) -> de.gsi.chart.ui.ObservableDeque[java.util.Map[de.gsi.chart.axes.Axis, 'JISAZoomer.ZoomState']]: ...
    class ZoomState:
        def getZoomRangeMax(self) -> float: ...
        def getZoomRangeMin(self) -> float: ...
        def toString(self) -> str: ...
        def wasAutoGrowRanging(self) -> bool: ...
        def wasAutoRanging(self) -> bool: ...

class TwoErrorDataSet(de.gsi.dataset.spi.AbstractErrorDataSet['TwoErrorDataSet'], de.gsi.dataset.DataSet2D, de.gsi.dataset.DataSetError, de.gsi.dataset.EditableDataSet):
    @typing.overload
    def __init__(self, dataSet: de.gsi.dataset.DataSet): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, int: int): ...
    @typing.overload
    def add(self, double: float, double2: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, double: float, double2: float, double3: float, double4: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, string: str) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray], doubleArray5: typing.Union[typing.List[float], jpype.JArray], doubleArray6: typing.Union[typing.List[float], jpype.JArray]) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, double: float, double2: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, double: float, double2: float, double3: float, double4: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, double: float, double2: float, double3: float, double4: float, double5: float, double6: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, string: str) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, *double: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def add(self, int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> 'TwoErrorDataSet': ...
    def clearData(self) -> 'TwoErrorDataSet': ...
    def get(self, int: int, int2: int) -> float: ...
    def getCapacity(self) -> int: ...
    def getDataCount(self) -> int: ...
    @typing.overload
    def getErrorNegative(self, int: int, double: float) -> float: ...
    @typing.overload
    def getErrorNegative(self, int: int, int2: int) -> float: ...
    @typing.overload
    def getErrorPositive(self, int: int, double: float) -> float: ...
    @typing.overload
    def getErrorPositive(self, int: int, int2: int) -> float: ...
    def getErrorType(self, int: int) -> de.gsi.dataset.DataSetError.ErrorType: ...
    def getErrorsNegative(self, int: int) -> typing.MutableSequence[float]: ...
    def getErrorsPositive(self, int: int) -> typing.MutableSequence[float]: ...
    def getValues(self, int: int) -> typing.MutableSequence[float]: ...
    def increaseCapacity(self, int: int) -> 'TwoErrorDataSet': ...
    @typing.overload
    def remove(self, int: int) -> 'TwoErrorDataSet': ...
    @typing.overload
    def remove(self, int: int, int2: int) -> 'TwoErrorDataSet': ...
    def resize(self, int: int) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, dataSet: de.gsi.dataset.DataSet) -> de.gsi.dataset.DataSet: ...
    @typing.overload
    def set(self, dataSet: de.gsi.dataset.DataSet, boolean: bool) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray], boolean: bool) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, int: int, double: float, double2: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, int: int, double: float, double2: float, double3: float, double4: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, int: int, *double: float) -> 'TwoErrorDataSet': ...
    @typing.overload
    def set(self, int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> 'TwoErrorDataSet': ...
    def setEditConstraints(self, editConstraints: de.gsi.dataset.EditConstraints) -> de.gsi.dataset.spi.AbstractStylable: ...
    def setName(self, string: str) -> de.gsi.dataset.spi.AbstractStylable: ...
    def trim(self) -> 'TwoErrorDataSet': ...

class JISAAxis(JISADefaultAxis):
    KNOWN_UNITS: typing.ClassVar[java.util.List] = ...
    def __init__(self, string: str, string2: str): ...
    def setHeight(self, double: float) -> None: ...
    def setUnit(self, string: str) -> None: ...
    def setWidth(self, double: float) -> None: ...

class JISAErrorDataSet(TwoErrorDataSet):
    def __init__(self, string: str, plot: jisa.gui.Plot): ...
    def colourProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.paint.Color]: ...
    def copyStyleOf(self, jISAErrorDataSet: 'JISAErrorDataSet') -> None: ...
    def dashProperty(self) -> javafx.beans.property.ObjectProperty[jisa.gui.Series.Dash]: ...
    def errorColourProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.paint.Color]: ...
    def errorThicknessProperty(self) -> javafx.beans.property.ObjectProperty[float]: ...
    def fitterProperty(self) -> javafx.beans.property.ObjectProperty[jisa.gui.Series.SeriesFitter]: ...
    def getColour(self) -> javafx.scene.paint.Color: ...
    def getDash(self) -> jisa.gui.Series.Dash: ...
    def getErrorColour(self) -> javafx.scene.paint.Color: ...
    def getErrorThickness(self) -> float: ...
    def getFit(self) -> jisa.maths.fits.Fit: ...
    def getFittedPoints(self, double: float, double2: float) -> de.gsi.dataset.spi.DoubleDataSet: ...
    def getFitter(self) -> jisa.gui.Series.SeriesFitter: ...
    def getOrdering(self) -> jisa.gui.Series.Ordering: ...
    def getShape(self) -> jisa.gui.Series.Shape: ...
    def getSize(self) -> float: ...
    def getThickness(self) -> float: ...
    def isFitted(self) -> bool: ...
    def isLineVisible(self) -> bool: ...
    def isMarkerVisible(self) -> bool: ...
    def lineVisibleProperty(self) -> javafx.beans.property.ObjectProperty[bool]: ...
    def markerVisibleProperty(self) -> javafx.beans.property.ObjectProperty[bool]: ...
    def orderingProperty(self) -> javafx.beans.property.ObjectProperty[jisa.gui.Series.Ordering]: ...
    def setColour(self, color: javafx.scene.paint.Color) -> None: ...
    def setDash(self, dash: jisa.gui.Series.Dash) -> None: ...
    def setErrorColour(self, color: javafx.scene.paint.Color) -> None: ...
    def setErrorThickness(self, double: float) -> None: ...
    def setFitter(self, seriesFitter: typing.Union[jisa.gui.Series.SeriesFitter, typing.Callable]) -> None: ...
    def setLineVisible(self, boolean: bool) -> None: ...
    def setMarkerVisible(self, boolean: bool) -> None: ...
    def setName(self, string: str) -> 'JISAErrorDataSet': ...
    def setOrdering(self, ordering: jisa.gui.Series.Ordering) -> None: ...
    def setShape(self, shape: jisa.gui.Series.Shape) -> None: ...
    def setSize(self, double: float) -> None: ...
    def setThickness(self, double: float) -> None: ...
    def setYValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def shapeProperty(self) -> javafx.beans.property.ObjectProperty[jisa.gui.Series.Shape]: ...
    def sizeProperty(self) -> javafx.beans.property.ObjectProperty[float]: ...
    def thicknessProperty(self) -> javafx.beans.property.ObjectProperty[float]: ...
    def updateStyle(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.gui.plotting")``.

    JISAAxis: typing.Type[JISAAxis]
    JISADefaultAxis: typing.Type[JISADefaultAxis]
    JISAErrorDataSet: typing.Type[JISAErrorDataSet]
    JISALogTransform: typing.Type[JISALogTransform]
    JISAMarker: typing.Type[JISAMarker]
    JISARenderer: typing.Type[JISARenderer]
    JISASeries: typing.Type[JISASeries]
    JISAXYChart: typing.Type[JISAXYChart]
    JISAZoomer: typing.Type[JISAZoomer]
    TwoErrorDataSet: typing.Type[TwoErrorDataSet]
