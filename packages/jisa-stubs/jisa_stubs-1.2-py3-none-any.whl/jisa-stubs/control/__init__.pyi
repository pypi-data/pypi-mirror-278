
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import javafx.scene.image
import jisa.addresses
import jisa.devices.interfaces
import kotlin.reflect
import org.json
import typing



class Asynch:
    def __init__(self): ...
    @staticmethod
    def onConditionMet(iCondition: typing.Union['ICondition', typing.Callable], int: int, sRunnable: typing.Union['SRunnable', typing.Callable], eRunnable: typing.Union['ERunnable', typing.Callable]) -> None: ...
    @staticmethod
    def onInterval(iCondition: typing.Union['ICondition', typing.Callable], int: int, iRunnable: typing.Union['IRunnable', typing.Callable], sRunnable: typing.Union['SRunnable', typing.Callable], eRunnable: typing.Union['ERunnable', typing.Callable]) -> None: ...
    @staticmethod
    def onParamStable(doubleReturn: typing.Union['DoubleReturn', typing.Callable], double2: float, long: int, int: int, sRunnable: typing.Union['SRunnable', typing.Callable], eRunnable: typing.Union['ERunnable', typing.Callable]) -> None: ...
    @staticmethod
    def onParamWithinError(doubleReturn: typing.Union['DoubleReturn', typing.Callable], double2: float, double3: float, long: int, int: int, sRunnable: typing.Union['SRunnable', typing.Callable], eRunnable: typing.Union['ERunnable', typing.Callable]) -> None: ...
    @staticmethod
    def onParamWithinRange(doubleReturn: typing.Union['DoubleReturn', typing.Callable], double2: float, double3: float, long: int, int: int, sRunnable: typing.Union['SRunnable', typing.Callable], eRunnable: typing.Union['ERunnable', typing.Callable]) -> None: ...

class Commandable:
    def getCommand(self, int: int) -> 'DeviceCommand': ...
    def getCommands(self) -> typing.MutableSequence['DeviceCommand']: ...
    def getName(self) -> str: ...
    def getNameableParams(self) -> java.util.HashMap[str, typing.Type]: ...

class Condition:
    def isMet(self) -> bool: ...

_ConfigBlock__Value__T = typing.TypeVar('_ConfigBlock__Value__T')  # <T>
class ConfigBlock:
    def booleanValue(self, string: str) -> 'ConfigBlock.Value'[bool]: ...
    def clear(self) -> None: ...
    def doubleValue(self, string: str) -> 'ConfigBlock.Value'[float]: ...
    def getSubBlocks(self) -> java.util.Map[str, 'ConfigBlock']: ...
    def hasBlock(self, string: str) -> bool: ...
    def hasValue(self, string: str) -> bool: ...
    def intValue(self, string: str) -> 'ConfigBlock.Value'[int]: ...
    def save(self) -> None: ...
    def stringValue(self, string: str) -> 'ConfigBlock.Value'[str]: ...
    def subBlock(self, string: str) -> 'ConfigBlock': ...
    def value(self, string: str) -> 'ConfigBlock.Value'[typing.Any]: ...
    class Value(typing.Generic[_ConfigBlock__Value__T]):
        def get(self) -> _ConfigBlock__Value__T: ...
        def getOrDefault(self, t: _ConfigBlock__Value__T) -> _ConfigBlock__Value__T: ...
        def set(self, object: typing.Any) -> None: ...

class ConfigStore:
    def __init__(self, string: str): ...
    def getBoolean(self, string: str) -> bool: ...
    def getBooleanOrDefault(self, string: str, boolean: bool) -> bool: ...
    def getDouble(self, string: str) -> float: ...
    def getDoubleOrDefault(self, string: str, double: float) -> float: ...
    def getGUIConfigs(self, class_: typing.Type[typing.Any]) -> org.json.JSONObject: ...
    def getInt(self, string: str) -> int: ...
    def getIntOrDefault(self, string: str, int: int) -> int: ...
    def getLastSave(self) -> int: ...
    def getString(self, string: str) -> str: ...
    def getStringOrDefault(self, string: str, string2: str) -> str: ...
    def has(self, string: str) -> bool: ...
    def save(self) -> None: ...
    def set(self, string: str, object: typing.Any) -> None: ...
    class SubStore:
        def __init__(self, configStore: 'ConfigStore', jSONObject: org.json.JSONObject): ...

_Connection__T = typing.TypeVar('_Connection__T', bound=jisa.devices.interfaces.Instrument)  # <T>
class Connection(typing.Generic[_Connection__T]):
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Connection__T]): ...
    @typing.overload
    def __init__(self, string: str, kClass: kotlin.reflect.KClass[_Connection__T]): ...
    def addChangeListener(self, runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> java.lang.Runnable: ...
    @staticmethod
    def addListener(sRunnable: typing.Union['SRunnable', typing.Callable]) -> 'SRunnable': ...
    def connect(self) -> None: ...
    def delete(self) -> None: ...
    def disconnect(self) -> None: ...
    @staticmethod
    def findConnectionFor(instrument: jisa.devices.interfaces.Instrument) -> 'Connection'[typing.Any]: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @staticmethod
    def getAllConnections() -> java.util.List['Connection'[typing.Any]]: ...
    def getAttempts(self) -> int: ...
    _getConnectionsByTarget__T = typing.TypeVar('_getConnectionsByTarget__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    @staticmethod
    def getConnectionsByTarget(class_: typing.Type[_getConnectionsByTarget__T]) -> java.util.List['Connection'[typing.Any]]: ...
    _getConnectionsOf__T = typing.TypeVar('_getConnectionsOf__T')  # <T>
    @staticmethod
    def getConnectionsOf(class_: typing.Type[_getConnectionsOf__T]) -> java.util.List['Connection'[typing.Any]]: ...
    def getDriver(self) -> typing.Type[_Connection__T]: ...
    def getInstrument(self) -> _Connection__T: ...
    def getKotlinDriver(self) -> kotlin.reflect.KClass[_Connection__T]: ...
    def getKotlinType(self) -> kotlin.reflect.KClass[_Connection__T]: ...
    def getName(self) -> str: ...
    def getStatus(self) -> 'Connection.Status': ...
    def getType(self) -> typing.Type[_Connection__T]: ...
    def isConnected(self) -> bool: ...
    def loadFromConfig(self, configBlock: ConfigBlock) -> None: ...
    @staticmethod
    def removeListener(sRunnable: typing.Union['SRunnable', typing.Callable]) -> None: ...
    def setAddress(self, address: jisa.addresses.Address) -> None: ...
    def setAttempts(self, int: int) -> None: ...
    @typing.overload
    def setDriver(self, class_: typing.Type[_Connection__T]) -> None: ...
    @typing.overload
    def setDriver(self, kClass: kotlin.reflect.KClass[_Connection__T]) -> None: ...
    def writeToConfig(self, configBlock: ConfigBlock) -> None: ...
    class Status(java.lang.Enum['Connection.Status']):
        DISCONNECTED: typing.ClassVar['Connection.Status'] = ...
        CONNECTING: typing.ClassVar['Connection.Status'] = ...
        RECONNECTING: typing.ClassVar['Connection.Status'] = ...
        CONNECTED: typing.ClassVar['Connection.Status'] = ...
        ERROR: typing.ClassVar['Connection.Status'] = ...
        def getImage(self) -> javafx.scene.image.Image: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Connection.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['Connection.Status']: ...

_DeviceCommand__DeviceArgument__T = typing.TypeVar('_DeviceCommand__DeviceArgument__T')  # <T>
class DeviceCommand:
    def __init__(self, string: str, string2: str, *deviceArgument: 'DeviceCommand.DeviceArgument'): ...
    def clone(self) -> 'DeviceCommand': ...
    def execute(self) -> float: ...
    def getArgument(self, int: int) -> 'DeviceCommand.DeviceArgument': ...
    def getArgumentValue(self, int: int) -> typing.Any: ...
    def getArguments(self) -> typing.MutableSequence['DeviceCommand.DeviceArgument']: ...
    def getDescription(self) -> str: ...
    def getName(self) -> str: ...
    def reset(self) -> None: ...
    class DeviceArgument(typing.Generic[_DeviceCommand__DeviceArgument__T]):
        def __init__(self, string: str, class_: typing.Type): ...
        def clone(self) -> 'DeviceCommand.DeviceArgument'[_DeviceCommand__DeviceArgument__T]: ...
        def getName(self) -> str: ...
        def getType(self) -> typing.Type: ...
        def getValue(self) -> _DeviceCommand__DeviceArgument__T: ...
        def isEnum(self) -> bool: ...
        def reset(self) -> None: ...
        def setValue(self, t: _DeviceCommand__DeviceArgument__T) -> None: ...

class DoubleReturn:
    def getValue(self) -> float: ...

class DriverException(java.lang.Exception):
    def __init__(self, string: str, exception: java.lang.Exception): ...

class ERunnable:
    def run(self, exception: java.lang.Exception) -> None: ...

class ICondition:
    def isMet(self, int: int) -> bool: ...

_IConf__T = typing.TypeVar('_IConf__T', bound=jisa.devices.interfaces.Instrument)  # <T>
class IConf(typing.Generic[_IConf__T]):
    def get(self) -> _IConf__T: ...

class IRunnable:
    def run(self, int: int) -> None: ...

class MotorController:
    def __init__(self, returnable: typing.Union['Returnable'[float], typing.Callable[[], float]], setGettable: 'SetGettable'[float], setGettable2: 'SetGettable'[bool]): ...
    def calibrate(self, double: float, double2: float, long: int) -> None: ...
    def getFrequency(self) -> float: ...
    def getVoltage(self) -> float: ...
    def isRunning(self) -> bool: ...
    def setFrequency(self, double: float) -> None: ...
    @typing.overload
    def setFrequencyAndWait(self, double: float) -> None: ...
    @typing.overload
    def setFrequencyAndWait(self, double: float, double2: float) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    @typing.overload
    def waitForFrequency(self, double: float) -> None: ...
    @typing.overload
    def waitForFrequency(self, double: float, double2: float) -> None: ...

class Nameable:
    def getName(self) -> str: ...

_PIDController__Input__T = typing.TypeVar('_PIDController__Input__T')  # <T>
_PIDController__Output__T = typing.TypeVar('_PIDController__Output__T')  # <T>
class PIDController:
    def __init__(self, int: int, input: typing.Union['PIDController.Input'[float], typing.Callable[[], float]], output: typing.Union['PIDController.Output'[float], typing.Callable[[float], None]]): ...
    def getD(self) -> float: ...
    def getI(self) -> float: ...
    def getOutputMax(self) -> float: ...
    def getOutputMin(self) -> float: ...
    def getP(self) -> float: ...
    def getTarget(self) -> float: ...
    def setOutputMax(self, double: float) -> None: ...
    def setOutputMin(self, double: float) -> None: ...
    def setPID(self, double: float, double2: float, double3: float) -> None: ...
    def setTarget(self, double: float) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    class Input(typing.Generic[_PIDController__Input__T]):
        def read(self) -> _PIDController__Input__T: ...
    class Output(typing.Generic[_PIDController__Output__T]):
        def write(self, t: _PIDController__Output__T) -> None: ...

class RTask:
    @typing.overload
    def __init__(self, long: int, task: typing.Union['RTask.Task', typing.Callable]): ...
    @typing.overload
    def __init__(self, long: int, sRunnable: typing.Union['SRunnable', typing.Callable]): ...
    def getCount(self) -> int: ...
    def getInterval(self) -> int: ...
    def getMSecFromStart(self) -> int: ...
    def getSecFromStart(self) -> float: ...
    def getTask(self) -> 'RTask.Task': ...
    def getTotalCount(self) -> int: ...
    def isRunning(self) -> bool: ...
    def setInterval(self, long: int) -> None: ...
    def setTask(self, task: typing.Union['RTask.Task', typing.Callable]) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    class Task:
        def run(self, rTask: 'RTask') -> None: ...

class ReadFilter:
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...
    class Setupable:
        def run(self, int: int) -> None: ...

class Repeat(java.lang.Iterable[float]):
    def __init__(self, int: int, int2: int, measurement: typing.Union['Repeat.Measurement', typing.Callable]): ...
    def getCount(self) -> int: ...
    def getDelay(self) -> int: ...
    def getMax(self) -> float: ...
    def getMean(self) -> float: ...
    def getMin(self) -> float: ...
    def getRange(self) -> float: ...
    def getStandardDeviation(self) -> float: ...
    def getSum(self) -> float: ...
    def getValue(self, int: int) -> float: ...
    def getValues(self) -> java.util.List[float]: ...
    def getVariance(self) -> float: ...
    def isComplete(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[float]: ...
    @staticmethod
    def prepare(int: int, int2: int, measurement: typing.Union['Repeat.Measurement', typing.Callable]) -> 'Repeat': ...
    @typing.overload
    @staticmethod
    def run(int: int, int2: int, measurement: typing.Union['Repeat.Measurement', typing.Callable]) -> 'Repeat': ...
    @typing.overload
    def run(self) -> None: ...
    @staticmethod
    def runInParallel(*repeat: 'Repeat') -> None: ...
    @staticmethod
    def runTogether(*repeat: 'Repeat') -> None: ...
    class Measurement:
        def measure(self) -> float: ...

_Returnable__T = typing.TypeVar('_Returnable__T')  # <T>
class Returnable(typing.Generic[_Returnable__T]):
    def get(self) -> _Returnable__T: ...

class SRunnable:
    def run(self) -> None: ...
    @staticmethod
    def start(sRunnable: typing.Union['SRunnable', typing.Callable]) -> None: ...

_SetGettable__T = typing.TypeVar('_SetGettable__T')  # <T>
class SetGettable(typing.Generic[_SetGettable__T]):
    def get(self) -> _SetGettable__T: ...
    def set(self, t: _SetGettable__T) -> None: ...

class Synch:
    def __init__(self): ...
    @staticmethod
    def waitForCondition(iCondition: typing.Union[ICondition, typing.Callable], int: int) -> None: ...
    @staticmethod
    def waitForParamStable(doubleReturn: typing.Union[DoubleReturn, typing.Callable], double2: float, int: int, long: int) -> None: ...
    @staticmethod
    def waitForParamStableMaxTime(doubleReturn: typing.Union[DoubleReturn, typing.Callable], double2: float, int: int, long: int, long2: int) -> None: ...
    @staticmethod
    def waitForParamWithinError(doubleReturn: typing.Union[DoubleReturn, typing.Callable], double2: float, double3: float, int: int) -> None: ...
    @staticmethod
    def waitForParamWithinRange(doubleReturn: typing.Union[DoubleReturn, typing.Callable], double2: float, double3: float, int: int) -> None: ...
    @staticmethod
    def waitForStableTarget(returnable: typing.Union[Returnable[float], typing.Callable[[], float]], double: float, double2: float, int: int, long: int) -> None: ...
    @staticmethod
    def waitForStableTargetMaxTime(returnable: typing.Union[Returnable[float], typing.Callable[[], float]], double: float, double2: float, int: int, long: int, long2: int) -> None: ...

class BypassFilter(ReadFilter):
    def __init__(self, returnable: typing.Union[Returnable[float], typing.Callable[[], float]], setupable: typing.Union[ReadFilter.Setupable, typing.Callable]): ...
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...

class ConfigFile(ConfigBlock):
    def __init__(self, string: str): ...
    def booleanValue(self, string: str) -> ConfigBlock.Value[bool]: ...
    def clear(self) -> None: ...
    def doubleValue(self, string: str) -> ConfigBlock.Value[float]: ...
    def getSubBlocks(self) -> java.util.Map[str, ConfigBlock]: ...
    def hasBlock(self, string: str) -> bool: ...
    def hasValue(self, string: str) -> bool: ...
    def intValue(self, string: str) -> ConfigBlock.Value[int]: ...
    def save(self) -> None: ...
    def stringValue(self, string: str) -> ConfigBlock.Value[str]: ...
    def subBlock(self, string: str) -> ConfigBlock: ...
    def value(self, string: str) -> ConfigBlock.Value[typing.Any]: ...

class DCPowerLockInController(MotorController):
    def __init__(self, dCPower: jisa.devices.interfaces.DCPower, lockIn: jisa.devices.interfaces.LockIn): ...

class MeanMovingFilter(ReadFilter):
    def __init__(self, returnable: typing.Union[Returnable[float], typing.Callable[[], float]], setupable: typing.Union[ReadFilter.Setupable, typing.Callable]): ...
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...

class MeanRepeatFilter(ReadFilter):
    def __init__(self, returnable: typing.Union[Returnable[float], typing.Callable[[], float]], setupable: typing.Union[ReadFilter.Setupable, typing.Callable]): ...
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...

class MedianMovingFilter(ReadFilter):
    def __init__(self, returnable: typing.Union[Returnable[float], typing.Callable[[], float]], setupable: typing.Union[ReadFilter.Setupable, typing.Callable]): ...
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...

class MedianRepeatFilter(ReadFilter):
    def __init__(self, returnable: typing.Union[Returnable[float], typing.Callable[[], float]], setupable: typing.Union[ReadFilter.Setupable, typing.Callable]): ...
    def clear(self) -> None: ...
    def getCount(self) -> int: ...
    def getValue(self) -> float: ...
    def setCount(self, int: int) -> None: ...
    def setUp(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.control")``.

    Asynch: typing.Type[Asynch]
    BypassFilter: typing.Type[BypassFilter]
    Commandable: typing.Type[Commandable]
    Condition: typing.Type[Condition]
    ConfigBlock: typing.Type[ConfigBlock]
    ConfigFile: typing.Type[ConfigFile]
    ConfigStore: typing.Type[ConfigStore]
    Connection: typing.Type[Connection]
    DCPowerLockInController: typing.Type[DCPowerLockInController]
    DeviceCommand: typing.Type[DeviceCommand]
    DoubleReturn: typing.Type[DoubleReturn]
    DriverException: typing.Type[DriverException]
    ERunnable: typing.Type[ERunnable]
    ICondition: typing.Type[ICondition]
    IConf: typing.Type[IConf]
    IRunnable: typing.Type[IRunnable]
    MeanMovingFilter: typing.Type[MeanMovingFilter]
    MeanRepeatFilter: typing.Type[MeanRepeatFilter]
    MedianMovingFilter: typing.Type[MedianMovingFilter]
    MedianRepeatFilter: typing.Type[MedianRepeatFilter]
    MotorController: typing.Type[MotorController]
    Nameable: typing.Type[Nameable]
    PIDController: typing.Type[PIDController]
    RTask: typing.Type[RTask]
    ReadFilter: typing.Type[ReadFilter]
    Repeat: typing.Type[Repeat]
    Returnable: typing.Type[Returnable]
    SRunnable: typing.Type[SRunnable]
    SetGettable: typing.Type[SetGettable]
    Synch: typing.Type[Synch]
