
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import _jpype
import java.io
import java.lang
import java.nio
import java.util
import java.util.function
import javafx.scene.image
import javafx.scene.paint
import javafx.scene.shape
import jisa.addresses
import jisa.control
import jisa.devices
import jisa.enums
import jisa.experiment
import jisa.gui
import jisa.logging
import jisa.maths
import jisa.results
import jisa.visa
import jpype
import typing



class Main:
    def __init__(self): ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...

_Util__Build__T = typing.TypeVar('_Util__Build__T')  # <T>
_Util__MapBuild__K = typing.TypeVar('_Util__MapBuild__K')  # <K>
_Util__MapBuild__V = typing.TypeVar('_Util__MapBuild__V')  # <V>
_Util__MapBuilder__K = typing.TypeVar('_Util__MapBuilder__K')  # <K>
_Util__MapBuilder__V = typing.TypeVar('_Util__MapBuilder__V')  # <V>
class Util:
    errLog: typing.ClassVar[java.io.PrintStream] = ...
    def __init__(self): ...
    @staticmethod
    def addShutdownHook(sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    @staticmethod
    def areAnyNull(*object: typing.Any) -> bool: ...
    @staticmethod
    def arrayAdd(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @staticmethod
    def arrayDiff(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @staticmethod
    def arrayFill(int: int, double: float) -> typing.MutableSequence[float]: ...
    _arraysSameSize_1__T = typing.TypeVar('_arraysSameSize_1__T')  # <T>
    @typing.overload
    @staticmethod
    def arraysSameSize(*doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def arraysSameSize(*tArray: typing.Union[typing.List[_arraysSameSize_1__T], jpype.JArray]) -> bool: ...
    _build__T = typing.TypeVar('_build__T')  # <T>
    @staticmethod
    def build(t: _build__T, build: typing.Union['Util.Build'[_build__T], typing.Callable[[_build__T], None]]) -> _build__T: ...
    _buildMap_0__K = typing.TypeVar('_buildMap_0__K')  # <K>
    _buildMap_0__V = typing.TypeVar('_buildMap_0__V')  # <V>
    _buildMap_1__K = typing.TypeVar('_buildMap_1__K')  # <K>
    _buildMap_1__V = typing.TypeVar('_buildMap_1__V')  # <V>
    @typing.overload
    @staticmethod
    def buildMap(mapBuild: typing.Union['Util.MapBuild'[_buildMap_0__K, _buildMap_0__V], typing.Callable[[java.util.Map[typing.Any, typing.Any]], None]]) -> java.util.Map[_buildMap_0__K, _buildMap_0__V]: ...
    @typing.overload
    @staticmethod
    def buildMap(class_: typing.Type[_buildMap_1__K], class2: typing.Type[_buildMap_1__V]) -> 'Util.MapBuilder'[_buildMap_1__K, _buildMap_1__V]: ...
    _castOrDefault__T = typing.TypeVar('_castOrDefault__T')  # <T>
    @staticmethod
    def castOrDefault(object: typing.Any, t: _castOrDefault__T) -> _castOrDefault__T: ...
    @staticmethod
    def colourImage(image: javafx.scene.image.Image, color: javafx.scene.paint.Color) -> javafx.scene.image.Image: ...
    @staticmethod
    def colourToCSS(color: javafx.scene.paint.Color) -> str: ...
    @staticmethod
    def exceptionHandler(exception: java.lang.Exception) -> None: ...
    @staticmethod
    def getCurrentTimeString() -> str: ...
    @staticmethod
    def getNiceValue(double: float, boolean: bool) -> float: ...
    @staticmethod
    def invertImage(image: javafx.scene.image.Image) -> javafx.scene.image.Image: ...
    @staticmethod
    def isBetween(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number3: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, booleanArray: typing.Union[typing.List[bool], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, charArray: typing.Union[typing.List[str], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, floatArray: typing.Union[typing.List[float], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, intArray: typing.Union[typing.List[int], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, objectArray: typing.Union[typing.List[typing.Any], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, longArray: typing.Union[typing.List[int], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def isValidIndex(int: int, shortArray: typing.Union[typing.List[int], jpype.JArray]) -> bool: ...
    @staticmethod
    def iterableToArray(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> typing.MutableSequence[float]: ...
    _iterableToList__T = typing.TypeVar('_iterableToList__T')  # <T>
    @staticmethod
    def iterableToList(iterable: typing.Union[java.lang.Iterable[_iterableToList__T], typing.Sequence[_iterableToList__T], typing.Set[_iterableToList__T], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> java.util.List[_iterableToList__T]: ...
    _iterateCombined_0__U = typing.TypeVar('_iterateCombined_0__U')  # <U>
    _iterateCombined_0__V = typing.TypeVar('_iterateCombined_0__V')  # <V>
    _iterateCombined_1__T = typing.TypeVar('_iterateCombined_1__T')  # <T>
    @typing.overload
    @staticmethod
    def iterateCombined(iterable: typing.Union[java.lang.Iterable[_iterateCombined_0__U], typing.Sequence[_iterateCombined_0__U], typing.Set[_iterateCombined_0__U], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[_iterateCombined_0__V], typing.Sequence[_iterateCombined_0__V], typing.Set[_iterateCombined_0__V], typing.Callable[[], java.util.Iterator[typing.Any]]], biConsumer: typing.Union[java.util.function.BiConsumer[_iterateCombined_0__U, _iterateCombined_0__V], typing.Callable[[_iterateCombined_0__U, _iterateCombined_0__V], None]]) -> None: ...
    @typing.overload
    @staticmethod
    def iterateCombined(consumer: typing.Union[java.util.function.Consumer[typing.Union[typing.List[_iterateCombined_1__T], jpype.JArray]], typing.Callable[[typing.Union[typing.List[_iterateCombined_1__T], jpype.JArray]], None]], *iterable: typing.Union[java.lang.Iterable[_iterateCombined_1__T], typing.Sequence[_iterateCombined_1__T], typing.Set[_iterateCombined_1__T], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> None: ...
    @staticmethod
    def joinDoubles(string: str, collection: typing.Union[java.util.Collection[float], typing.Sequence[float], typing.Set[float]]) -> str: ...
    @staticmethod
    def joinInts(string: str, *int: int) -> str: ...
    @staticmethod
    def joinPath(string: str, *string2: str) -> str: ...
    @staticmethod
    def makeCountingArray(int: int, int2: int) -> typing.MutableSequence[int]: ...
    @staticmethod
    def makeCountingString(int: int, int2: int, string: str) -> typing.MutableSequence[str]: ...
    @staticmethod
    def makeLinearArray(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> typing.MutableSequence[float]: ...
    @staticmethod
    def makeLogarithmicArray(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> typing.MutableSequence[float]: ...
    @staticmethod
    def makeSymLinearArray(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], int: int) -> typing.MutableSequence[float]: ...
    _mapOf__K = typing.TypeVar('_mapOf__K')  # <K>
    _mapOf__V = typing.TypeVar('_mapOf__V')  # <V>
    @staticmethod
    def mapOf(*object: typing.Any) -> java.util.Map[_mapOf__K, _mapOf__V]: ...
    @staticmethod
    def msToPaddedString(long: int) -> str: ...
    @staticmethod
    def msToString(long: int) -> str: ...
    @staticmethod
    def oneSigFigCeil(double: float) -> float: ...
    @staticmethod
    def oneSigFigFloor(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> float: ...
    @staticmethod
    def openInBrowser(string: str) -> None: ...
    @staticmethod
    def padArray(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.MutableSequence[int]: ...
    @staticmethod
    def pathToSVG(path: javafx.scene.shape.Path) -> str: ...
    @typing.overload
    @staticmethod
    def pluralise(string: str, number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> str: ...
    @typing.overload
    @staticmethod
    def pluralise(string: str, string2: str, number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> str: ...
    @staticmethod
    def polygonToSVG(polygon: javafx.scene.shape.Polygon) -> str: ...
    @staticmethod
    def primitiveArray(*double: float) -> typing.MutableSequence[float]: ...
    _reverseArray_1__T = typing.TypeVar('_reverseArray_1__T')  # <T>
    @typing.overload
    @staticmethod
    def reverseArray(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def reverseArray(tArray: typing.Union[typing.List[_reverseArray_1__T], jpype.JArray]) -> typing.MutableSequence[_reverseArray_1__T]: ...
    @staticmethod
    def roundSigFig(double: float, int: int, int2: int) -> float: ...
    @staticmethod
    def runAsync(runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> None: ...
    @staticmethod
    def runInParallel(*sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def runRegardless(sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def runRegardless(*sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    @staticmethod
    def setExceptionHandler(eRunnable: typing.Union[jisa.control.ERunnable, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def sleep(int: int) -> None: ...
    @typing.overload
    @staticmethod
    def sleep(long: int) -> None: ...
    @staticmethod
    def symArray(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def trimBytes(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def trimBytes(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def trimBytes(byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def truncate(number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number3: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> float: ...
    @typing.overload
    @staticmethod
    def truncate(int: int, int2: int, int3: int) -> int: ...
    class Build(typing.Generic[_Util__Build__T]):
        def build(self, t: _Util__Build__T) -> None: ...
    class MapBuild(typing.Generic[_Util__MapBuild__K, _Util__MapBuild__V]):
        def map(self, map: typing.Union[java.util.Map[_Util__MapBuild__K, _Util__MapBuild__V], typing.Mapping[_Util__MapBuild__K, _Util__MapBuild__V]]) -> None: ...
    class MapBuilder(typing.Generic[_Util__MapBuilder__K, _Util__MapBuilder__V]):
        def __init__(self, class_: typing.Type[_Util__MapBuilder__K], class2: typing.Type[_Util__MapBuilder__V]): ...
        def map(self) -> java.util.Map[_Util__MapBuilder__K, _Util__MapBuilder__V]: ...
        def put(self, k: _Util__MapBuilder__K, v: _Util__MapBuilder__V) -> 'Util.MapBuilder'[_Util__MapBuilder__K, _Util__MapBuilder__V]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa")``.

    Main: typing.Type[Main]
    Util: typing.Type[Util]
    addresses: jisa.addresses.__module_protocol__
    control: jisa.control.__module_protocol__
    devices: jisa.devices.__module_protocol__
    enums: jisa.enums.__module_protocol__
    experiment: jisa.experiment.__module_protocol__
    gui: jisa.gui.__module_protocol__
    logging: jisa.logging.__module_protocol__
    maths: jisa.maths.__module_protocol__
    results: jisa.results.__module_protocol__
    visa: jisa.visa.__module_protocol__
