
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import _jpype
import com.sun.javafx.scene.control
import de.gsi.dataset
import java.io
import java.lang
import java.net
import java.util
import java.util.function
import java.util.regex
import javafx.application
import javafx.beans.property
import javafx.collections
import javafx.geometry
import javafx.scene
import javafx.scene.chart
import javafx.scene.control
import javafx.scene.image
import javafx.scene.input
import javafx.scene.layout
import javafx.scene.paint
import javafx.scene.text
import javafx.stage
import jisa
import jisa.addresses
import jisa.control
import jisa.devices
import jisa.devices.interfaces
import jisa.enums
import jisa.experiment
import jisa.gui.fields
import jisa.gui.fxml
import jisa.gui.plotting
import jisa.gui.queue
import jisa.gui.svg
import jisa.maths
import jisa.maths.fits
import jisa.maths.matrices
import jisa.results
import jpype
import kotlin.reflect
import typing



class App(javafx.application.Application):
    def __init__(self): ...
    def start(self, stage: javafx.stage.Stage) -> None: ...

class Clearable:
    def clear(self) -> None: ...

class Colour:
    TRANSPARENT: typing.ClassVar[javafx.scene.paint.Color] = ...
    ALICEBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    ANTIQUEWHITE: typing.ClassVar[javafx.scene.paint.Color] = ...
    AQUA: typing.ClassVar[javafx.scene.paint.Color] = ...
    AQUAMARINE: typing.ClassVar[javafx.scene.paint.Color] = ...
    AZURE: typing.ClassVar[javafx.scene.paint.Color] = ...
    BEIGE: typing.ClassVar[javafx.scene.paint.Color] = ...
    BISQUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    BLACK: typing.ClassVar[javafx.scene.paint.Color] = ...
    BLANCHEDALMOND: typing.ClassVar[javafx.scene.paint.Color] = ...
    BLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    BLUEVIOLET: typing.ClassVar[javafx.scene.paint.Color] = ...
    BROWN: typing.ClassVar[javafx.scene.paint.Color] = ...
    BURLYWOOD: typing.ClassVar[javafx.scene.paint.Color] = ...
    CADETBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    CHARTREUSE: typing.ClassVar[javafx.scene.paint.Color] = ...
    CHOCOLATE: typing.ClassVar[javafx.scene.paint.Color] = ...
    CORAL: typing.ClassVar[javafx.scene.paint.Color] = ...
    CORNFLOWERBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    CORNSILK: typing.ClassVar[javafx.scene.paint.Color] = ...
    CRIMSON: typing.ClassVar[javafx.scene.paint.Color] = ...
    CYAN: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKCYAN: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKGOLDENROD: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKKHAKI: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKMAGENTA: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKOLIVEGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKORANGE: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKORCHID: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKRED: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKSALMON: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKSEAGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKSLATEBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKSLATEGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKSLATEGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKTURQUOISE: typing.ClassVar[javafx.scene.paint.Color] = ...
    DARKVIOLET: typing.ClassVar[javafx.scene.paint.Color] = ...
    DEEPPINK: typing.ClassVar[javafx.scene.paint.Color] = ...
    DEEPSKYBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    DIMGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DIMGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    DODGERBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    FIREBRICK: typing.ClassVar[javafx.scene.paint.Color] = ...
    FLORALWHITE: typing.ClassVar[javafx.scene.paint.Color] = ...
    FORESTGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    FUCHSIA: typing.ClassVar[javafx.scene.paint.Color] = ...
    GAINSBORO: typing.ClassVar[javafx.scene.paint.Color] = ...
    GHOSTWHITE: typing.ClassVar[javafx.scene.paint.Color] = ...
    GOLD: typing.ClassVar[javafx.scene.paint.Color] = ...
    GOLDENROD: typing.ClassVar[javafx.scene.paint.Color] = ...
    GRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    GREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    GREENYELLOW: typing.ClassVar[javafx.scene.paint.Color] = ...
    GREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    HONEYDEW: typing.ClassVar[javafx.scene.paint.Color] = ...
    HOTPINK: typing.ClassVar[javafx.scene.paint.Color] = ...
    INDIANRED: typing.ClassVar[javafx.scene.paint.Color] = ...
    INDIGO: typing.ClassVar[javafx.scene.paint.Color] = ...
    IVORY: typing.ClassVar[javafx.scene.paint.Color] = ...
    KHAKI: typing.ClassVar[javafx.scene.paint.Color] = ...
    LAVENDER: typing.ClassVar[javafx.scene.paint.Color] = ...
    LAVENDERBLUSH: typing.ClassVar[javafx.scene.paint.Color] = ...
    LAWNGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    LEMONCHIFFON: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTCORAL: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTCYAN: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTGOLDENRODYELLOW: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTPINK: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSALMON: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSEAGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSKYBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSLATEGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSLATEGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTSTEELBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIGHTYELLOW: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIME: typing.ClassVar[javafx.scene.paint.Color] = ...
    LIMEGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    LINEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    MAGENTA: typing.ClassVar[javafx.scene.paint.Color] = ...
    MAROON: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMAQUAMARINE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMORCHID: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMPURPLE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMSEAGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMSLATEBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMSPRINGGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMTURQUOISE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MEDIUMVIOLETRED: typing.ClassVar[javafx.scene.paint.Color] = ...
    MIDNIGHTBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MINTCREAM: typing.ClassVar[javafx.scene.paint.Color] = ...
    MISTYROSE: typing.ClassVar[javafx.scene.paint.Color] = ...
    MOCCASIN: typing.ClassVar[javafx.scene.paint.Color] = ...
    NAVAJOWHITE: typing.ClassVar[javafx.scene.paint.Color] = ...
    NAVY: typing.ClassVar[javafx.scene.paint.Color] = ...
    OLDLACE: typing.ClassVar[javafx.scene.paint.Color] = ...
    OLIVE: typing.ClassVar[javafx.scene.paint.Color] = ...
    OLIVEDRAB: typing.ClassVar[javafx.scene.paint.Color] = ...
    ORANGE: typing.ClassVar[javafx.scene.paint.Color] = ...
    ORANGERED: typing.ClassVar[javafx.scene.paint.Color] = ...
    ORCHID: typing.ClassVar[javafx.scene.paint.Color] = ...
    PALEGOLDENROD: typing.ClassVar[javafx.scene.paint.Color] = ...
    PALEGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    PALETURQUOISE: typing.ClassVar[javafx.scene.paint.Color] = ...
    PALEVIOLETRED: typing.ClassVar[javafx.scene.paint.Color] = ...
    PAPAYAWHIP: typing.ClassVar[javafx.scene.paint.Color] = ...
    PEACHPUFF: typing.ClassVar[javafx.scene.paint.Color] = ...
    PERU: typing.ClassVar[javafx.scene.paint.Color] = ...
    PINK: typing.ClassVar[javafx.scene.paint.Color] = ...
    PLUM: typing.ClassVar[javafx.scene.paint.Color] = ...
    POWDERBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    PURPLE: typing.ClassVar[javafx.scene.paint.Color] = ...
    RED: typing.ClassVar[javafx.scene.paint.Color] = ...
    ROSYBROWN: typing.ClassVar[javafx.scene.paint.Color] = ...
    ROYALBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    SADDLEBROWN: typing.ClassVar[javafx.scene.paint.Color] = ...
    SALMON: typing.ClassVar[javafx.scene.paint.Color] = ...
    SANDYBROWN: typing.ClassVar[javafx.scene.paint.Color] = ...
    SEAGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    SEASHELL: typing.ClassVar[javafx.scene.paint.Color] = ...
    SIENNA: typing.ClassVar[javafx.scene.paint.Color] = ...
    SILVER: typing.ClassVar[javafx.scene.paint.Color] = ...
    SKYBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    SLATEBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    SLATEGRAY: typing.ClassVar[javafx.scene.paint.Color] = ...
    SLATEGREY: typing.ClassVar[javafx.scene.paint.Color] = ...
    SNOW: typing.ClassVar[javafx.scene.paint.Color] = ...
    SPRINGGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    STEELBLUE: typing.ClassVar[javafx.scene.paint.Color] = ...
    TAN: typing.ClassVar[javafx.scene.paint.Color] = ...
    TEAL: typing.ClassVar[javafx.scene.paint.Color] = ...
    THISTLE: typing.ClassVar[javafx.scene.paint.Color] = ...
    TOMATO: typing.ClassVar[javafx.scene.paint.Color] = ...
    TURQUOISE: typing.ClassVar[javafx.scene.paint.Color] = ...
    VIOLET: typing.ClassVar[javafx.scene.paint.Color] = ...
    WHEAT: typing.ClassVar[javafx.scene.paint.Color] = ...
    WHITE: typing.ClassVar[javafx.scene.paint.Color] = ...
    WHITESMOKE: typing.ClassVar[javafx.scene.paint.Color] = ...
    YELLOW: typing.ClassVar[javafx.scene.paint.Color] = ...
    YELLOWGREEN: typing.ClassVar[javafx.scene.paint.Color] = ...
    def __init__(self): ...
    @staticmethod
    def rgb(int: int, int2: int, int3: int) -> javafx.scene.paint.Color: ...
    @staticmethod
    def string(string: str) -> javafx.scene.paint.Color: ...
    @staticmethod
    def toRGBA(color: javafx.scene.paint.Color) -> str: ...

class Container:
    def add(self, element: 'Element') -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection['Element'], typing.Sequence['Element'], typing.Set['Element']]) -> None: ...
    @typing.overload
    def addAll(self, *element: 'Element') -> None: ...
    def clear(self) -> None: ...
    def getElements(self) -> java.util.List['Element']: ...
    def remove(self, element: 'Element') -> None: ...
    @typing.overload
    def removeAll(self, collection: typing.Union[java.util.Collection['Element'], typing.Sequence['Element'], typing.Set['Element']]) -> None: ...
    @typing.overload
    def removeAll(self, *element: 'Element') -> None: ...

class DecimalField(javafx.scene.control.TextField):
    def __init__(self): ...
    def getDecimalValue(self) -> float: ...

class DoubleField(javafx.scene.control.TextField):
    def __init__(self): ...
    def getDoubleValue(self) -> float: ...

class DoubleInput(javafx.scene.layout.HBox):
    mantissa: javafx.scene.control.TextField = ...
    exponent: javafx.scene.control.TextField = ...
    leading: int = ...
    root: javafx.scene.layout.HBox = ...
    onChange: 'DoubleInput.DoubleChange' = ...
    def __init__(self): ...
    @typing.overload
    def disabled(self) -> bool: ...
    @typing.overload
    def disabled(self, boolean: bool) -> None: ...
    def getExponent(self) -> int: ...
    def getMantissa(self) -> float: ...
    def getValue(self) -> float: ...
    def setOnChange(self, doubleChange: typing.Union['DoubleInput.DoubleChange', typing.Callable]) -> None: ...
    def setValue(self, double: float) -> None: ...
    class DoubleChange:
        def change(self, double: float) -> None: ...

class Element:
    def close(self) -> None: ...
    def getBorderedNode(self) -> javafx.scene.Node: ...
    def getIcon(self) -> javafx.scene.image.Image: ...
    def getNode(self) -> javafx.scene.Node: ...
    def getTitle(self) -> str: ...
    def hide(self) -> None: ...
    def isVisible(self) -> bool: ...
    def setTitle(self, string: str) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...
    def show(self) -> None: ...
    def titleProperty(self) -> javafx.beans.property.ObjectProperty[str]: ...
    class ElementBorder(javafx.scene.control.TitledPane):
        def __init__(self, objectProperty: javafx.beans.property.ObjectProperty[str], node: javafx.scene.Node): ...

class GUI:
    SPACING: typing.ClassVar[float] = ...
    def __init__(self): ...
    _askUserForInstrument_0__T = typing.TypeVar('_askUserForInstrument_0__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    _askUserForInstrument_1__T = typing.TypeVar('_askUserForInstrument_1__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    @typing.overload
    @staticmethod
    def askUserForInstrument(string: str, class_: typing.Type[_askUserForInstrument_0__T]) -> _askUserForInstrument_0__T: ...
    @typing.overload
    @staticmethod
    def askUserForInstrument(string: str, kClass: kotlin.reflect.KClass[_askUserForInstrument_1__T]) -> _askUserForInstrument_1__T: ...
    @staticmethod
    def browseVISA() -> jisa.addresses.Address: ...
    @staticmethod
    def choiceWindow(string: str, string2: str, string3: str, *string4: str) -> int: ...
    @staticmethod
    def confirmWindow(string: str, string2: str, string3: str) -> bool: ...
    _connectTo__T = typing.TypeVar('_connectTo__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    @staticmethod
    def connectTo(class_: typing.Type[_connectTo__T], address: jisa.addresses.Address) -> _connectTo__T: ...
    @typing.overload
    @staticmethod
    def directorySelect() -> str: ...
    @typing.overload
    @staticmethod
    def directorySelect(string: str) -> str: ...
    @typing.overload
    @staticmethod
    def errorAlert(string: str) -> None: ...
    @typing.overload
    @staticmethod
    def errorAlert(string: str, string2: str) -> None: ...
    @typing.overload
    @staticmethod
    def errorAlert(string: str, string2: str, string3: str) -> None: ...
    @typing.overload
    @staticmethod
    def errorAlert(string: str, string2: str, string3: str, double: float) -> None: ...
    @staticmethod
    def getCurrentScreen() -> javafx.stage.Screen: ...
    @typing.overload
    @staticmethod
    def infoAlert(string: str) -> None: ...
    @typing.overload
    @staticmethod
    def infoAlert(string: str, string2: str) -> None: ...
    @typing.overload
    @staticmethod
    def infoAlert(string: str, string2: str, string3: str) -> None: ...
    @typing.overload
    @staticmethod
    def infoAlert(string: str, string2: str, string3: str, double: float) -> None: ...
    @staticmethod
    def inputWindow(string: str, string2: str, string3: str, *string4: str) -> typing.MutableSequence[str]: ...
    @typing.overload
    @staticmethod
    def openFileMultipleSelect() -> java.util.List[str]: ...
    @typing.overload
    @staticmethod
    def openFileMultipleSelect(string: str) -> java.util.List[str]: ...
    @typing.overload
    @staticmethod
    def openFileSelect() -> str: ...
    @typing.overload
    @staticmethod
    def openFileSelect(string: str) -> str: ...
    def runMeasurement(self, measurement: jisa.experiment.Measurement) -> None: ...
    @staticmethod
    def runNow(runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def saveFileSelect() -> str: ...
    @typing.overload
    @staticmethod
    def saveFileSelect(string: str) -> str: ...
    @staticmethod
    def showException(throwable: java.lang.Throwable) -> None: ...
    @staticmethod
    def stopGUI() -> None: ...
    @staticmethod
    def touch() -> None: ...
    @staticmethod
    def waitForExit() -> None: ...
    @typing.overload
    @staticmethod
    def warningAlert(string: str) -> None: ...
    @typing.overload
    @staticmethod
    def warningAlert(string: str, string2: str) -> None: ...
    @typing.overload
    @staticmethod
    def warningAlert(string: str, string2: str, string3: str) -> None: ...
    @typing.overload
    @staticmethod
    def warningAlert(string: str, string2: str, string3: str, double: float) -> None: ...

class IntegerField(javafx.scene.control.TextField):
    def __init__(self): ...
    def getIntValue(self) -> int: ...

class JISALegend(javafx.scene.layout.GridPane):
    def __init__(self): ...
    def addItem(self, series: javafx.scene.chart.XYChart.Series[float, float], node: javafx.scene.Node) -> None: ...
    def clear(self) -> None: ...
    def getMaxColumns(self) -> int: ...
    def getMaxRows(self) -> int: ...
    def removeItem(self, series: javafx.scene.chart.XYChart.Series[float, float]) -> None: ...
    def setMaxColumns(self, int: int) -> None: ...
    def setMaxRows(self, int: int) -> None: ...

class JavaFX:
    def __init__(self): ...
    @staticmethod
    def launch() -> None: ...

class Legend(javafx.scene.layout.TilePane):
    def __init__(self): ...
    def getItems(self) -> javafx.collections.ObservableList['Legend.LegendItem']: ...
    def isVertical(self) -> bool: ...
    def itemsProperty(self) -> javafx.beans.property.ObjectProperty[javafx.collections.ObservableList['Legend.LegendItem']]: ...
    def setItems(self, observableList: javafx.collections.ObservableList['Legend.LegendItem']) -> None: ...
    def setVertical(self, boolean: bool) -> None: ...
    def verticalProperty(self) -> javafx.beans.property.BooleanProperty: ...
    class LegendItem:
        @typing.overload
        def __init__(self, string: str): ...
        @typing.overload
        def __init__(self, string: str, node: javafx.scene.Node): ...
        def getSymbol(self) -> javafx.scene.Node: ...
        def getText(self) -> str: ...
        def setSymbol(self, node: javafx.scene.Node) -> None: ...
        def setText(self, string: str) -> None: ...
        def symbolProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.Node]: ...
        def textProperty(self) -> javafx.beans.property.StringProperty: ...

class NotBordered:
    def getNoBorderPane(self, boolean: bool) -> javafx.scene.layout.Pane: ...

class Series:
    defaultColours: typing.ClassVar[typing.MutableSequence[javafx.scene.paint.Color]] = ...
    @typing.overload
    def addPoint(self, double: float, double2: float, double3: float, double4: float) -> 'Series': ...
    @typing.overload
    def addPoint(self, double: float, double2: float) -> 'Series': ...
    @typing.overload
    def addPoint(self, double: float, double2: float, double3: float) -> 'Series': ...
    @typing.overload
    def addPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'Series': ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'Series': ...
    @typing.overload
    def addPoints(self, iterable: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable4: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'Series': ...
    @typing.overload
    def addPoints(self, matrix: jisa.maths.matrices.Matrix[float]) -> 'Series': ...
    def clear(self) -> 'Series': ...
    def disableAutoReduction(self) -> 'Series': ...
    def disableXAutoRemove(self) -> 'Series': ...
    def disableYAutoRemove(self) -> 'Series': ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[jisa.results.Row], typing.Callable[[jisa.results.Row], bool]]) -> 'Series': ...
    def fit(self, seriesFitter: typing.Union['Series.SeriesFitter', typing.Callable]) -> 'Series': ...
    def getColour(self) -> javafx.scene.paint.Color: ...
    def getDatasets(self) -> javafx.collections.ObservableList[de.gsi.dataset.DataSet]: ...
    def getErrorColour(self) -> javafx.scene.paint.Color: ...
    def getErrorLineWidth(self) -> float: ...
    def getFit(self) -> jisa.maths.fits.Fit: ...
    def getLimit(self) -> int: ...
    def getLineDash(self) -> 'Series.Dash': ...
    def getLineWidth(self) -> float: ...
    def getMarkerShape(self) -> 'Series.Shape': ...
    def getMarkerSize(self) -> float: ...
    def getName(self) -> str: ...
    def getPointOrdering(self) -> 'Series.Ordering': ...
    def getWatched(self) -> jisa.results.ResultTable: ...
    def isFitted(self) -> bool: ...
    def isLineVisible(self) -> bool: ...
    def isMarkerVisible(self) -> bool: ...
    def polyFit(self, int: int) -> 'Series': ...
    def reduceNow(self) -> 'Series': ...
    def remove(self) -> 'Series': ...
    def removeFit(self) -> 'Series': ...
    def removePoint(self, int: int) -> 'Series': ...
    def removePoints(self, int: int, int2: int) -> 'Series': ...
    def setAutoReduction(self, int: int, int2: int) -> 'Series': ...
    def setColour(self, color: javafx.scene.paint.Color) -> 'Series': ...
    def setColourSequence(self, *color: javafx.scene.paint.Color) -> 'Series': ...
    def setErrorColour(self, color: javafx.scene.paint.Color) -> 'Series': ...
    def setErrorLineWidth(self, double: float) -> 'Series': ...
    def setLimit(self, int: int) -> 'Series': ...
    def setLineDash(self, dash: 'Series.Dash') -> 'Series': ...
    def setLineVisible(self, boolean: bool) -> 'Series': ...
    def setLineWidth(self, double: float) -> 'Series': ...
    def setMarkerShape(self, shape: 'Series.Shape') -> 'Series': ...
    def setMarkerSize(self, double: float) -> 'Series': ...
    def setMarkerVisible(self, boolean: bool) -> 'Series': ...
    def setName(self, string: str) -> 'Series': ...
    def setPointOrder(self, ordering: 'Series.Ordering') -> 'Series': ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    @typing.overload
    def setPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    def setXAutoRemove(self, double: float) -> 'Series': ...
    def setXPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    def setYAutoRemove(self, double: float) -> 'Series': ...
    def setYPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'Series': ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]], seriesFormatter: typing.Union['Series.SeriesFormatter', typing.Callable]) -> 'Series': ...
    @typing.overload
    def split(self, column: jisa.results.Column[typing.Any]) -> 'Series': ...
    @typing.overload
    def split(self, column: jisa.results.Column[typing.Any], string: str) -> 'Series': ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]]) -> 'Series': ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[jisa.results.RowEvaluable[typing.Any], typing.Callable[[jisa.results.Row], typing.Any]], string: str) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable2: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable3: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable4: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]]) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], column3: jisa.results.Column[java.lang.Number]) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], column3: jisa.results.Column[java.lang.Number], column4: jisa.results.Column[java.lang.Number]) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable, typing.Callable], rowEvaluable2: typing.Union[jisa.results.RowEvaluable, typing.Callable]) -> 'Series': ...
    @typing.overload
    def watch(self, resultTable: jisa.results.ResultTable, rowEvaluable: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable2: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]], rowEvaluable3: typing.Union[jisa.results.RowEvaluable[java.lang.Number], typing.Callable[[jisa.results.Row], java.lang.Number]]) -> 'Series': ...
    class Dash(java.lang.Enum['Series.Dash']):
        SOLID: typing.ClassVar['Series.Dash'] = ...
        DASHED: typing.ClassVar['Series.Dash'] = ...
        DOTTED: typing.ClassVar['Series.Dash'] = ...
        TWO_DASH: typing.ClassVar['Series.Dash'] = ...
        DOT_DASH: typing.ClassVar['Series.Dash'] = ...
        LONG_DASH: typing.ClassVar['Series.Dash'] = ...
        def getArray(self) -> typing.MutableSequence[float]: ...
        def getDoubleArray(self) -> typing.MutableSequence[float]: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Series.Dash': ...
        @staticmethod
        def values() -> typing.MutableSequence['Series.Dash']: ...
    class Ordering(java.lang.Enum['Series.Ordering']):
        NONE: typing.ClassVar['Series.Ordering'] = ...
        X_AXIS: typing.ClassVar['Series.Ordering'] = ...
        Y_AXIS: typing.ClassVar['Series.Ordering'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Series.Ordering': ...
        @staticmethod
        def values() -> typing.MutableSequence['Series.Ordering']: ...
    class SeriesFitter:
        @typing.overload
        def fit(self, iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> jisa.maths.fits.Fit: ...
        @typing.overload
        def fit(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> jisa.maths.fits.Fit: ...
    class SeriesFormatter:
        def getName(self, row: jisa.results.Row) -> str: ...
    class Shape(java.lang.Enum['Series.Shape']):
        CIRCLE: typing.ClassVar['Series.Shape'] = ...
        DOT: typing.ClassVar['Series.Shape'] = ...
        SQUARE: typing.ClassVar['Series.Shape'] = ...
        TRIANGLE: typing.ClassVar['Series.Shape'] = ...
        STAR: typing.ClassVar['Series.Shape'] = ...
        DIAMOND: typing.ClassVar['Series.Shape'] = ...
        DASH: typing.ClassVar['Series.Shape'] = ...
        PLUS: typing.ClassVar['Series.Shape'] = ...
        CROSS: typing.ClassVar['Series.Shape'] = ...
        def getMarker(self) -> jisa.gui.plotting.JISAMarker: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Series.Shape': ...
        @staticmethod
        def values() -> typing.MutableSequence['Series.Shape']: ...

class SubElement:
    def isVisible(self) -> bool: ...
    def remove(self) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...

class TimeInput(javafx.scene.layout.HBox):
    hours: javafx.scene.control.TextField = ...
    minutes: javafx.scene.control.TextField = ...
    seconds: javafx.scene.control.TextField = ...
    millis: javafx.scene.control.TextField = ...
    root: javafx.scene.layout.HBox = ...
    onChange: 'TimeInput.DoubleChange' = ...
    def __init__(self): ...
    @typing.overload
    def disabled(self) -> bool: ...
    @typing.overload
    def disabled(self, boolean: bool) -> None: ...
    def getHours(self) -> int: ...
    def getMillis(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getValue(self) -> int: ...
    def setOnChange(self, doubleChange: typing.Union['TimeInput.DoubleChange', typing.Callable]) -> None: ...
    def setValue(self, int: int) -> None: ...
    class DoubleChange:
        def change(self, double: float) -> None: ...

_Field__T = typing.TypeVar('_Field__T')  # <T>
class Field(SubElement, typing.Generic[_Field__T]):
    def editValues(self, *string: str) -> None: ...
    def get(self) -> _Field__T: ...
    def getText(self) -> str: ...
    def getValue(self) -> _Field__T: ...
    def isDisabled(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def loadOtherDefaults(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def remove(self) -> None: ...
    def set(self, t: _Field__T) -> None: ...
    def setDisabled(self, boolean: bool) -> None: ...
    def setOnChange(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def setText(self, string: str) -> None: ...
    def setValue(self, t: _Field__T) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...
    def writeOtherDefaults(self, configBlock: jisa.control.ConfigBlock) -> None: ...

class JFXElement(Element):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, uRL: java.net.URL): ...
    @typing.overload
    def __init__(self, string: str, node: javafx.scene.Node): ...
    def addDialogButton(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> 'Button': ...
    def addDialogMenuButton(self, string: str) -> 'MenuButton': ...
    def addToolbarButton(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> 'Button': ...
    def addToolbarMenuButton(self, string: str) -> 'MenuButton': ...
    def addToolbarSeparator(self) -> 'Separator': ...
    def autoAdjustSize(self) -> None: ...
    def autoSizeWindow(self) -> None: ...
    def clearDialogButtons(self) -> None: ...
    def clearToolbar(self) -> None: ...
    def close(self) -> None: ...
    def getIcon(self) -> javafx.scene.image.Image: ...
    def getMaxHeight(self) -> float: ...
    def getMaxWidth(self) -> float: ...
    def getMaxWindowHeight(self) -> float: ...
    def getMaxWindowWidth(self) -> float: ...
    def getMinHeight(self) -> float: ...
    def getMinWidth(self) -> float: ...
    def getNode(self) -> javafx.scene.layout.BorderPane: ...
    def getStage(self) -> javafx.stage.Stage: ...
    def getTitle(self) -> str: ...
    def getWindowHeight(self) -> float: ...
    def getWindowWidth(self) -> float: ...
    def hide(self) -> None: ...
    def iconProperty(self) -> javafx.beans.property.ObjectProperty[javafx.scene.image.Image]: ...
    def isDecorated(self) -> bool: ...
    def isExitOnClose(self) -> bool: ...
    def isMaximised(self) -> bool: ...
    def isShowing(self) -> bool: ...
    def setCentreNode(self, node: javafx.scene.Node) -> None: ...
    def setDecorated(self, boolean: bool) -> None: ...
    def setExitOnClose(self, boolean: bool) -> None: ...
    @typing.overload
    def setIcon(self, uRL: java.net.URL) -> None: ...
    @typing.overload
    def setIcon(self, icon: jisa.enums.Icon) -> None: ...
    def setMaxHeight(self, double: float) -> None: ...
    def setMaxWidth(self, double: float) -> None: ...
    def setMaxWindowHeight(self, double: float) -> None: ...
    def setMaxWindowWidth(self, double: float) -> None: ...
    def setMaximised(self, boolean: bool) -> None: ...
    def setMinHeight(self, double: float) -> None: ...
    def setMinWidth(self, double: float) -> None: ...
    def setOnClose(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def setTitle(self, string: str) -> None: ...
    def setWindowHeight(self, double: float) -> None: ...
    def setWindowSize(self, double: float, double2: float) -> None: ...
    def setWindowWidth(self, double: float) -> None: ...
    def show(self) -> None: ...
    def showAsAlert(self) -> None: ...
    def showAsConfirmation(self) -> bool: ...
    def showAsDialog(self, *string: str) -> int: ...
    def titleProperty(self) -> javafx.beans.property.ObjectProperty[str]: ...

class SeriesGroup(Series):
    def getSeries(self) -> java.util.Collection[Series]: ...
    def getSeriesFor(self, double: float) -> Series: ...

class BorderDisplay(JFXElement):
    def __init__(self, string: str): ...
    def getBorderedNode(self) -> javafx.scene.Node: ...
    def getBottomElement(self) -> Element: ...
    def getCentreElement(self) -> Element: ...
    def getLeftElement(self) -> Element: ...
    def getRightElement(self) -> Element: ...
    def getTopElement(self) -> Element: ...
    def setBottomElement(self, element: Element) -> None: ...
    def setCentreElement(self, element: Element) -> None: ...
    def setLeftElement(self, element: Element) -> None: ...
    def setRightElement(self, element: Element) -> None: ...
    def setTopElement(self, element: Element) -> None: ...

class CameraFeed(JFXElement):
    def __init__(self, string: str, camera: jisa.devices.interfaces.Camera): ...
    def getCamera(self) -> jisa.devices.interfaces.Camera: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class CheckGrid(JFXElement):
    def __init__(self, string: str, int: int, int2: int): ...
    def getColumnCount(self) -> int: ...
    def getRowCount(self) -> int: ...
    def getValues(self) -> typing.MutableSequence[typing.MutableSequence[bool]]: ...
    def isChecked(self, int: int, int2: int) -> bool: ...
    def setAll(self, boolean: bool) -> None: ...
    def setChecked(self, int: int, int2: int, boolean: bool) -> None: ...
    def setColumn(self, int: int, boolean: bool) -> None: ...
    def setRow(self, int: int, boolean: bool) -> None: ...
    def setSize(self, int: int, int2: int) -> None: ...
    def setValues(self, booleanArray: typing.Union[typing.List[typing.MutableSequence[bool]], jpype.JArray]) -> None: ...

_Configurator__I = typing.TypeVar('_Configurator__I', bound=jisa.devices.interfaces.Instrument)  # <I>
class Configurator(JFXElement, typing.Generic[_Configurator__I]):
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Configurator__I]): ...
    @typing.overload
    def __init__(self, string: str, kClass: kotlin.reflect.KClass[_Configurator__I]): ...
    @typing.overload
    def __init__(self, configuration: jisa.devices.Configuration[_Configurator__I]): ...
    def getConfiguration(self) -> jisa.devices.Configuration[_Configurator__I]: ...
    def linkToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...

_Connector__T = typing.TypeVar('_Connector__T', bound=jisa.devices.interfaces.Instrument)  # <T>
class Connector(JFXElement, typing.Generic[_Connector__T]):
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Connector__T]): ...
    @typing.overload
    def __init__(self, string: str, kClass: kotlin.reflect.KClass[_Connector__T]): ...
    @typing.overload
    def __init__(self, connection: jisa.control.Connection[_Connector__T]): ...
    def apply(self) -> None: ...
    def applySettings(self) -> None: ...
    def browse(self) -> None: ...
    def connect(self) -> None: ...
    def getConnection(self) -> jisa.control.Connection[_Connector__T]: ...
    def linkToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def removeRemoveButton(self) -> None: ...
    def setRemoveButton(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...

class DataDisplay(JFXElement):
    def __init__(self, string: str): ...
    def addParameter(self, string: str, object: typing.Any) -> 'DataDisplay.Parameter': ...
    class Parameter:
        def getBooleanValue(self) -> bool: ...
        def getDoubleValue(self) -> float: ...
        def getIntValue(self) -> int: ...
        def getValue(self) -> str: ...
        def setName(self, string: str) -> None: ...
        def setValue(self, object: typing.Any) -> None: ...

class DeviceShell(JFXElement):
    terminal: javafx.scene.control.ListView = ...
    input: javafx.scene.control.TextField = ...
    timeOut: com.sun.javafx.scene.control.IntegerField = ...
    writeTerm: javafx.scene.control.TextField = ...
    readTerm: javafx.scene.control.TextField = ...
    eoi: javafx.scene.control.CheckBox = ...
    baud: com.sun.javafx.scene.control.IntegerField = ...
    data: com.sun.javafx.scene.control.IntegerField = ...
    def __init__(self, address: jisa.addresses.Address): ...
    def connect(self) -> None: ...
    def queryLine(self) -> None: ...
    def readLine(self) -> None: ...
    def showAndWait(self) -> None: ...
    def textEnter(self) -> None: ...
    def updateParameters(self) -> None: ...
    def writeLine(self) -> None: ...

class Doc(JFXElement):
    def __init__(self, string: str): ...
    def addHeading(self, string: str) -> 'Doc.Heading': ...
    @typing.overload
    def addImage(self, string: str) -> 'Doc.Image': ...
    @typing.overload
    def addImage(self, uRL: java.net.URL) -> 'Doc.Image': ...
    @typing.overload
    def addImage(self, image: javafx.scene.image.Image) -> 'Doc.Image': ...
    def addLink(self, string: str, string2: str) -> 'Doc.Link': ...
    def addList(self, boolean: bool) -> 'Doc.List': ...
    def addSubHeading(self, string: str) -> 'Doc.Heading': ...
    def addText(self, string: str) -> 'Doc.Paragraph': ...
    def addValue(self, string: str, string2: str) -> 'Doc.Value': ...
    def getBackgroundColour(self) -> javafx.scene.paint.Color: ...
    def setBackgroundColour(self, color: javafx.scene.paint.Color) -> None: ...
    class Align(java.lang.Enum['Doc.Align']):
        LEFT: typing.ClassVar['Doc.Align'] = ...
        RIGHT: typing.ClassVar['Doc.Align'] = ...
        CENTRE: typing.ClassVar['Doc.Align'] = ...
        def getAlignment(self) -> javafx.scene.text.TextAlignment: ...
        def getPos(self) -> javafx.geometry.Pos: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Doc.Align': ...
        @staticmethod
        def values() -> typing.MutableSequence['Doc.Align']: ...
    class Heading(SubElement):
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.Heading': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.Heading': ...
        def setText(self, string: str) -> 'Doc.Heading': ...
    class Image(SubElement):
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.Image': ...
    class Link(SubElement):
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.Link': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.Link': ...
        def setText(self, string: str) -> 'Doc.Link': ...
        def setURL(self, string: str) -> 'Doc.Link': ...
    class List(SubElement):
        def addItem(self, string: str) -> 'Doc.List': ...
        def clear(self) -> 'Doc.List': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.List': ...
    class Paragraph(SubElement):
        def addLine(self, string: str) -> 'Doc.Paragraph': ...
        def clear(self) -> 'Doc.Paragraph': ...
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.Paragraph': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.Paragraph': ...
        def setText(self, string: str) -> 'Doc.Paragraph': ...
    class Table(SubElement):
        def addRow(self) -> 'Doc.TableRow': ...
    class TableCell(SubElement):
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.TableCell': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.TableCell': ...
        def setText(self, string: str) -> 'Doc.TableCell': ...
    class TableRow(SubElement):
        def addCell(self) -> 'Doc.TableCell': ...
    class Value(SubElement):
        def clear(self) -> 'Doc.Value': ...
        def setAlignment(self, align: 'Doc.Align') -> 'Doc.Value': ...
        def setColour(self, color: javafx.scene.paint.Color) -> 'Doc.Value': ...
        def setText(self, string: str) -> 'Doc.Value': ...
        def setValue(self, string: str) -> 'Doc.Value': ...

class Fields(JFXElement, Element, java.lang.Iterable[Field[typing.Any]]):
    pane: javafx.scene.layout.BorderPane = ...
    list: javafx.scene.layout.GridPane = ...
    def __init__(self, string: str): ...
    def addButton(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> 'Button': ...
    @typing.overload
    def addCheckBox(self, string: str) -> Field[bool]: ...
    @typing.overload
    def addCheckBox(self, string: str, boolean: bool) -> Field[bool]: ...
    @typing.overload
    def addChoice(self, string: str, int: int, *string2: str) -> Field[int]: ...
    @typing.overload
    def addChoice(self, string: str, *string2: str) -> Field[int]: ...
    @typing.overload
    def addDecimalField(self, string: str) -> Field[float]: ...
    @typing.overload
    def addDecimalField(self, string: str, double: float) -> Field[float]: ...
    @typing.overload
    def addDirectorySelect(self, string: str) -> Field[str]: ...
    @typing.overload
    def addDirectorySelect(self, string: str, string2: str) -> Field[str]: ...
    def addDoubleDisplay(self, string: str, double: float) -> Field[float]: ...
    @typing.overload
    def addDoubleField(self, string: str) -> Field[float]: ...
    @typing.overload
    def addDoubleField(self, string: str, double: float) -> Field[float]: ...
    @typing.overload
    def addDoubleRange(self, string: str, range: jisa.maths.Range[float]) -> Field[jisa.maths.Range[float]]: ...
    @typing.overload
    def addDoubleRange(self, string: str, range: jisa.maths.Range[float], double: float, double2: float, int: int, double3: float, int2: int) -> Field[jisa.maths.Range[float]]: ...
    @typing.overload
    def addFileOpen(self, string: str) -> Field[str]: ...
    @typing.overload
    def addFileOpen(self, string: str, string2: str) -> Field[str]: ...
    @typing.overload
    def addFileSave(self, string: str) -> Field[str]: ...
    @typing.overload
    def addFileSave(self, string: str, string2: str) -> Field[str]: ...
    @typing.overload
    def addIntegerField(self, string: str) -> Field[int]: ...
    @typing.overload
    def addIntegerField(self, string: str, int: int) -> Field[int]: ...
    def addSeparator(self) -> 'Separator': ...
    def addTable(self, string: str, *string2: str) -> Field[java.util.List[java.util.List[float]]]: ...
    @typing.overload
    def addTextField(self, string: str) -> Field[str]: ...
    @typing.overload
    def addTextField(self, string: str, string2: str) -> Field[str]: ...
    @typing.overload
    def addTimeField(self, string: str) -> Field[int]: ...
    @typing.overload
    def addTimeField(self, string: str, int: int) -> Field[int]: ...
    def clear(self) -> None: ...
    def iterator(self) -> java.util.Iterator[Field[typing.Any]]: ...
    def linkToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def setFieldsDisabled(self, boolean: bool) -> None: ...
    def updateGridding(self) -> None: ...
    def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...

class Grid(JFXElement, Element, Container):
    pane: javafx.scene.layout.GridPane = ...
    scroll: javafx.scene.control.ScrollPane = ...
    @typing.overload
    def __init__(self, int: int, *element: Element): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, int: int): ...
    @typing.overload
    def __init__(self, string: str, int: int, *element: Element): ...
    @typing.overload
    def __init__(self, string: str, *element: Element): ...
    @typing.overload
    def __init__(self, *element: Element): ...
    def add(self, element: Element) -> None: ...
    def autoAdjustSize(self) -> None: ...
    def clear(self) -> None: ...
    def getBorderedNode(self) -> javafx.scene.Node: ...
    def getElements(self) -> java.util.List[Element]: ...
    def getNumColumns(self) -> int: ...
    def remove(self, element: Element) -> None: ...
    def scrollTo(self, double: float) -> None: ...
    def scrollToEnd(self) -> None: ...
    def scrollToTop(self) -> None: ...
    @typing.overload
    def setGrowth(self, boolean: bool, boolean2: bool) -> None: ...
    @typing.overload
    def setGrowth(self, element: Element, boolean: bool, boolean2: bool) -> None: ...
    def setNumColumns(self, int: int) -> None: ...
    def slideInElement(self, element: Element) -> None: ...
    def slideOutElement(self, element: Element) -> None: ...

_ListDisplay__Item__T = typing.TypeVar('_ListDisplay__Item__T')  # <T>
_ListDisplay__ItemRunnable__T = typing.TypeVar('_ListDisplay__ItemRunnable__T')  # <T>
_ListDisplay__T = typing.TypeVar('_ListDisplay__T')  # <T>
class ListDisplay(JFXElement, java.lang.Iterable['ListDisplay.Item'[_ListDisplay__T]], typing.Generic[_ListDisplay__T]):
    def __init__(self, string: str): ...
    def add(self, t: _ListDisplay__T, string: str, string2: str, image: javafx.scene.image.Image) -> 'ListDisplay.Item'[_ListDisplay__T]: ...
    def addDefaultMenuItem(self, string: str, itemRunnable: typing.Union['ListDisplay.ItemRunnable'[_ListDisplay__T], typing.Callable[['ListDisplay.Item'[typing.Any]], None]]) -> None: ...
    def clear(self) -> None: ...
    def getItems(self) -> java.util.List['ListDisplay.Item'[_ListDisplay__T]]: ...
    def getSelected(self) -> 'ListDisplay.Item'[_ListDisplay__T]: ...
    def getSelectedIndex(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator['ListDisplay.Item'[_ListDisplay__T]]: ...
    def remove(self, item: 'ListDisplay.Item'[_ListDisplay__T]) -> None: ...
    @typing.overload
    def select(self, int: int) -> None: ...
    @typing.overload
    def select(self, item: 'ListDisplay.Item'[_ListDisplay__T]) -> None: ...
    def setOnChange(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def size(self) -> int: ...
    class Item(SubElement, typing.Generic[_ListDisplay__Item__T]):
        def addMenuItem(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> 'Button': ...
        def getObject(self) -> _ListDisplay__Item__T: ...
        def getSubTitle(self) -> str: ...
        def getTitle(self) -> str: ...
        def select(self) -> None: ...
        def setImage(self, image: javafx.scene.image.Image) -> None: ...
        def setOnSelected(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
        def setSubTitle(self, string: str) -> None: ...
        def setTitle(self, string: str) -> None: ...
    class ItemRunnable(typing.Generic[_ListDisplay__ItemRunnable__T]):
        def run(self, item: 'ListDisplay.Item'[_ListDisplay__ItemRunnable__T]) -> None: ...
        def runRegardless(self, item: 'ListDisplay.Item'[_ListDisplay__ItemRunnable__T]) -> None: ...
        def start(self, item: 'ListDisplay.Item'[_ListDisplay__ItemRunnable__T]) -> None: ...

class Logger(JFXElement):
    pane: javafx.scene.layout.BorderPane = ...
    list: javafx.scene.control.ListView = ...
    def __init__(self, string: str): ...
    def addLine(self, string: str, *object: typing.Any) -> 'Logger.Line': ...
    def clear(self) -> None: ...
    class Line:
        def delete(self) -> None: ...
        def edit(self, string: str) -> None: ...
    class PLine:
        def delete(self) -> None: ...
        def edit(self, string: str) -> None: ...
        @typing.overload
        def setProgress(self, double: float) -> None: ...
        @typing.overload
        def setProgress(self, int: int, int2: int) -> None: ...

class Pages(JFXElement, Element, Container):
    pane: javafx.scene.layout.BorderPane = ...
    sidebar: javafx.scene.layout.VBox = ...
    scrollPane: javafx.scene.control.ScrollPane = ...
    def __init__(self, string: str, *element: Element): ...
    def add(self, element: Element) -> None: ...
    @typing.overload
    def addSeparator(self) -> 'Separator': ...
    @typing.overload
    def addSeparator(self, string: str) -> 'Separator': ...
    def clear(self) -> None: ...
    def getElements(self) -> java.util.List[Element]: ...
    def getTitle(self) -> str: ...
    def remove(self, element: Element) -> None: ...
    @typing.overload
    def select(self, int: int) -> None: ...
    @typing.overload
    def select(self, element: Element) -> None: ...

class Plot(JFXElement, Element, Clearable):
    UNIT_PATTERN: typing.ClassVar[java.util.regex.Pattern] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, iterable: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[java.lang.Number], typing.Sequence[java.lang.Number], typing.Set[java.lang.Number], typing.Callable[[], java.util.Iterator[typing.Any]]]): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str, string4: str, string5: str): ...
    @typing.overload
    def __init__(self, string: str, resultTable: jisa.results.ResultTable): ...
    @typing.overload
    def __init__(self, string: str, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number]): ...
    @typing.overload
    def __init__(self, string: str, resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]): ...
    def addClickListener(self, clickListener: typing.Union['Plot.ClickListener', typing.Callable]) -> 'Plot.ClickListener': ...
    def addSaveButton(self, string: str) -> 'Button': ...
    def autoRangeX(self) -> None: ...
    def autoRangeY(self) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'Plot': ...
    def createSeries(self) -> Series: ...
    def forceRedraw(self) -> None: ...
    def getChart(self) -> jisa.gui.plotting.JISAXYChart: ...
    def getSVG(self, double: float, double2: float) -> jisa.gui.svg.SVG: ...
    def getSeries(self) -> java.util.List[Series]: ...
    def getXAxisLogarithmBase(self) -> float: ...
    def getXAxisType(self) -> 'Plot.AxisType': ...
    def getXLabel(self) -> str: ...
    def getXMax(self) -> float: ...
    def getXMin(self) -> float: ...
    def getXUnit(self) -> str: ...
    def getYAxisLogarithmBase(self) -> float: ...
    def getYAxisType(self) -> 'Plot.AxisType': ...
    def getYLabel(self) -> str: ...
    def getYMax(self) -> float: ...
    def getYMin(self) -> float: ...
    def getYUnit(self) -> str: ...
    def isLegendVisible(self) -> bool: ...
    def isMouseEnabled(self) -> bool: ...
    def isXAutoRanging(self) -> bool: ...
    def isYAutoRanging(self) -> bool: ...
    @typing.overload
    def outputSVG(self, double: float, double2: float) -> None: ...
    @typing.overload
    def outputSVG(self, printStream: java.io.PrintStream, double: float, double2: float) -> None: ...
    def removeClickListener(self, clickListener: typing.Union['Plot.ClickListener', typing.Callable]) -> None: ...
    def removeSeries(self, series: Series) -> None: ...
    def savePNG(self, string: str, double: float, double2: float) -> None: ...
    def saveSVG(self, string: str, double: float, double2: float) -> None: ...
    def saveTex(self, string: str) -> None: ...
    def setLegendVisible(self, boolean: bool) -> None: ...
    def setMouseEnabled(self, boolean: bool) -> None: ...
    def setTitle(self, string: str) -> None: ...
    def setXAxisLogarithmBase(self, double: float) -> None: ...
    def setXAxisType(self, axisType: 'Plot.AxisType') -> None: ...
    @typing.overload
    def setXLabel(self, string: str) -> None: ...
    @typing.overload
    def setXLabel(self, string: str, string2: str) -> None: ...
    def setXLimits(self, double: float, double2: float) -> None: ...
    def setXMax(self, double: float) -> None: ...
    def setXMin(self, double: float) -> None: ...
    def setXUnit(self, string: str) -> None: ...
    def setYAxisLogarithmBase(self, double: float) -> None: ...
    def setYAxisType(self, axisType: 'Plot.AxisType') -> None: ...
    @typing.overload
    def setYLabel(self, string: str) -> None: ...
    @typing.overload
    def setYLabel(self, string: str, string2: str) -> None: ...
    def setYLimits(self, double: float, double2: float) -> None: ...
    def setYMax(self, double: float) -> None: ...
    def setYMin(self, double: float) -> None: ...
    def setYUnit(self, string: str) -> None: ...
    def showSaveDialog(self) -> None: ...
    def updateLegend(self) -> None: ...
    class AxisType(java.lang.Enum['Plot.AxisType']):
        LINEAR: typing.ClassVar['Plot.AxisType'] = ...
        LOGARITHMIC: typing.ClassVar['Plot.AxisType'] = ...
        TIME: typing.ClassVar['Plot.AxisType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Plot.AxisType': ...
        @staticmethod
        def values() -> typing.MutableSequence['Plot.AxisType']: ...
    class ClickListener:
        def clicked(self, mouseEvent: javafx.scene.input.MouseEvent, double: float, double2: float) -> None: ...
        def runRegardless(self, mouseEvent: javafx.scene.input.MouseEvent, double: float, double2: float) -> None: ...

class Progress(JFXElement):
    def __init__(self, string: str): ...
    def getFractionProgress(self) -> float: ...
    def getPercentProgress(self) -> float: ...
    def getProgress(self) -> float: ...
    def getStatus(self) -> str: ...
    @typing.overload
    def incrementProgress(self) -> None: ...
    @typing.overload
    def incrementProgress(self, number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> None: ...
    @typing.overload
    def setProgress(self, double: float) -> None: ...
    @typing.overload
    def setProgress(self, int: int) -> None: ...
    @typing.overload
    def setProgress(self, number: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat], number2: typing.Union[_jpype._JNumberLong, _jpype._JNumberFloat, typing.SupportsIndex, typing.SupportsFloat]) -> None: ...
    def setStatus(self, string: str) -> None: ...
    def setTitle(self, string: str) -> None: ...

class Section(JFXElement):
    pane: javafx.scene.layout.Pane = ...
    titled: javafx.scene.control.TitledPane = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, element: Element): ...
    def addTitleButton(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> 'Button': ...
    def clear(self) -> None: ...
    def getBorderedNode(self) -> javafx.scene.Node: ...
    def getTitle(self) -> str: ...
    def isExpandable(self) -> bool: ...
    def isExpanded(self) -> bool: ...
    def setElement(self, element: Element) -> None: ...
    def setExpandable(self, boolean: bool) -> None: ...
    def setExpanded(self, boolean: bool) -> None: ...
    def setTitle(self, string: str) -> None: ...

class SplashScreen(JFXElement):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, uRL: java.net.URL): ...
    @typing.overload
    def __init__(self, string: str, image: javafx.scene.image.Image): ...
    def getImage(self) -> javafx.scene.image.Image: ...
    @typing.overload
    def setImage(self, string: str) -> None: ...
    @typing.overload
    def setImage(self, uRL: java.net.URL) -> None: ...
    @typing.overload
    def setImage(self, image: javafx.scene.image.Image) -> None: ...

class Table(JFXElement, Element, Clearable):
    table: javafx.scene.control.TableView = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, resultTable: jisa.results.ResultTable): ...
    def clear(self) -> None: ...
    def update(self, row: jisa.results.Row) -> None: ...
    def watch(self, resultTable: jisa.results.ResultTable) -> None: ...
    def watchList(self, resultTable: jisa.results.ResultTable) -> None: ...

class Tabs(JFXElement, Container):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, *element: Element): ...
    def add(self, element: Element) -> None: ...
    def clear(self) -> None: ...
    def getBorderedNode(self) -> javafx.scene.Node: ...
    def getElements(self) -> java.util.List[Element]: ...
    def getSelectedElement(self) -> Element: ...
    def getSelectedIndex(self) -> int: ...
    def getTabPane(self) -> javafx.scene.layout.Pane: ...
    def getTabsPosition(self) -> javafx.geometry.Side: ...
    def remove(self, element: Element) -> None: ...
    @typing.overload
    def select(self, int: int) -> None: ...
    @typing.overload
    def select(self, element: Element) -> None: ...
    def setTabsPosition(self, side: javafx.geometry.Side) -> None: ...

class ConnectorGrid(Grid):
    def __init__(self, string: str, int: int): ...
    _addConnector_1__T = typing.TypeVar('_addConnector_1__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    _addConnector_2__T = typing.TypeVar('_addConnector_2__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    _addConnector_3__T = typing.TypeVar('_addConnector_3__T', bound=jisa.devices.interfaces.Instrument)  # <T>
    @typing.overload
    def addConnector(self, class_: typing.Type) -> Connector[typing.Any]: ...
    @typing.overload
    def addConnector(self, string: str, class_: typing.Type[_addConnector_1__T]) -> Connector[_addConnector_1__T]: ...
    @typing.overload
    def addConnector(self, connection: jisa.control.Connection[_addConnector_2__T]) -> Connector[_addConnector_2__T]: ...
    @typing.overload
    def addConnector(self, connector: Connector[_addConnector_3__T]) -> Connector[_addConnector_3__T]: ...
    def connectAll(self) -> None: ...
    def connectAllWithList(self) -> Element: ...
    def getConnections(self) -> java.util.List[jisa.control.Connection[typing.Any]]: ...
    def getConnectors(self) -> java.util.List[Connector[typing.Any]]: ...
    def linkToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def loadFromConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def removeConnector(self, connector: Connector) -> None: ...
    def removeConnectors(self) -> None: ...
    def writeToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...

class MeasurementConfigurator(Tabs):
    @typing.overload
    def __init__(self, string: str, measurement: jisa.experiment.Measurement): ...
    @typing.overload
    def __init__(self, measurement: jisa.experiment.Measurement): ...
    _getField__T = typing.TypeVar('_getField__T')  # <T>
    def getField(self, parameter: jisa.experiment.Measurement.Parameter[_getField__T]) -> Field[_getField__T]: ...
    def getNumColumns(self) -> int: ...
    def isColSpanning(self) -> bool: ...
    def linkToConfig(self, configBlock: jisa.control.ConfigBlock) -> None: ...
    def setColSpanning(self, boolean: bool) -> None: ...
    def setNumColumns(self, int: int) -> None: ...
    def showInput(self) -> bool: ...
    def update(self) -> None: ...

class RangeInput(Fields):
    def __init__(self, string: str, string2: str): ...
    def getRange(self) -> jisa.maths.Range[float]: ...

class SwapGrid(Grid):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, int: int): ...
    @typing.overload
    def add(self, element: Element) -> None: ...
    @typing.overload
    def add(self, element: Element, *int: int) -> None: ...
    def clear(self) -> None: ...
    def getConfiguration(self) -> int: ...
    def getElements(self) -> java.util.List[Element]: ...
    def remove(self, element: Element) -> None: ...
    def setConfiguration(self, int: int) -> None: ...

class VISABrowser(ListDisplay[jisa.addresses.Address]):
    def __init__(self, string: str): ...
    def getSelectedAddress(self) -> jisa.addresses.Address: ...
    def selectAddress(self) -> jisa.addresses.Address: ...
    def updateList(self) -> None: ...

class Button(SubElement):
    def getText(self) -> str: ...
    def isDisabled(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def remove(self) -> None: ...
    def setDisabled(self, boolean: bool) -> None: ...
    def setOnClick(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
    def setText(self, string: str) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...
    class ButtonWrapper(jisa.gui.Button):
        def __init__(self, button: javafx.scene.control.Button): ...
        def getText(self) -> str: ...
        def isDisabled(self) -> bool: ...
        def isVisible(self) -> bool: ...
        def setDisabled(self, boolean: bool) -> None: ...
        def setOnClick(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
        def setText(self, string: str) -> None: ...
        def setVisible(self, boolean: bool) -> None: ...
    class MenuItemWrapper(jisa.gui.Button):
        def __init__(self, menuItem: javafx.scene.control.MenuItem): ...
        def getText(self) -> str: ...
        def isDisabled(self) -> bool: ...
        def isVisible(self) -> bool: ...
        def setDisabled(self, boolean: bool) -> None: ...
        def setOnClick(self, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> None: ...
        def setText(self, string: str) -> None: ...
        def setVisible(self, boolean: bool) -> None: ...

class MenuButton(SubElement):
    def addItem(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> Button: ...
    @typing.overload
    def addSeparator(self) -> 'Separator': ...
    @typing.overload
    def addSeparator(self, string: str) -> 'Separator': ...
    def getText(self) -> str: ...
    def isDisabled(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def removeAllItems(self) -> None: ...
    def setDisabled(self, boolean: bool) -> None: ...
    def setText(self, string: str) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...
    class MenuButtonWrapper(jisa.gui.MenuButton):
        def addItem(self, string: str, sRunnable: typing.Union[jisa.control.SRunnable, typing.Callable]) -> Button: ...
        @typing.overload
        def addSeparator(self) -> 'Separator': ...
        @typing.overload
        def addSeparator(self, string: str) -> 'Separator': ...
        def getText(self) -> str: ...
        def isDisabled(self) -> bool: ...
        def isVisible(self) -> bool: ...
        def removeAllItems(self) -> None: ...
        def setDisabled(self, boolean: bool) -> None: ...
        def setText(self, string: str) -> None: ...
        def setVisible(self, boolean: bool) -> None: ...

class Separator(SubElement):
    def isVisible(self) -> bool: ...
    def remove(self) -> None: ...
    def setVisible(self, boolean: bool) -> None: ...
    class MenuSeparatorWrapper(jisa.gui.Separator):
        def isVisible(self) -> bool: ...
        def setVisible(self, boolean: bool) -> None: ...
    class SeparatorWrapper(jisa.gui.Separator):
        def isVisible(self) -> bool: ...
        def setVisible(self, boolean: bool) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.gui")``.

    App: typing.Type[App]
    BorderDisplay: typing.Type[BorderDisplay]
    Button: typing.Type[Button]
    CameraFeed: typing.Type[CameraFeed]
    CheckGrid: typing.Type[CheckGrid]
    Clearable: typing.Type[Clearable]
    Colour: typing.Type[Colour]
    Configurator: typing.Type[Configurator]
    Connector: typing.Type[Connector]
    ConnectorGrid: typing.Type[ConnectorGrid]
    Container: typing.Type[Container]
    DataDisplay: typing.Type[DataDisplay]
    DecimalField: typing.Type[DecimalField]
    DeviceShell: typing.Type[DeviceShell]
    Doc: typing.Type[Doc]
    DoubleField: typing.Type[DoubleField]
    DoubleInput: typing.Type[DoubleInput]
    Element: typing.Type[Element]
    Field: typing.Type[Field]
    Fields: typing.Type[Fields]
    GUI: typing.Type[GUI]
    Grid: typing.Type[Grid]
    IntegerField: typing.Type[IntegerField]
    JFXElement: typing.Type[JFXElement]
    JISALegend: typing.Type[JISALegend]
    JavaFX: typing.Type[JavaFX]
    Legend: typing.Type[Legend]
    ListDisplay: typing.Type[ListDisplay]
    Logger: typing.Type[Logger]
    MeasurementConfigurator: typing.Type[MeasurementConfigurator]
    MenuButton: typing.Type[MenuButton]
    NotBordered: typing.Type[NotBordered]
    Pages: typing.Type[Pages]
    Plot: typing.Type[Plot]
    Progress: typing.Type[Progress]
    RangeInput: typing.Type[RangeInput]
    Section: typing.Type[Section]
    Separator: typing.Type[Separator]
    Series: typing.Type[Series]
    SeriesGroup: typing.Type[SeriesGroup]
    SplashScreen: typing.Type[SplashScreen]
    SubElement: typing.Type[SubElement]
    SwapGrid: typing.Type[SwapGrid]
    Table: typing.Type[Table]
    Tabs: typing.Type[Tabs]
    TimeInput: typing.Type[TimeInput]
    VISABrowser: typing.Type[VISABrowser]
    fields: jisa.gui.fields.__module_protocol__
    fxml: jisa.gui.fxml.__module_protocol__
    plotting: jisa.gui.plotting.__module_protocol__
    queue: jisa.gui.queue.__module_protocol__
    svg: jisa.gui.svg.__module_protocol__
