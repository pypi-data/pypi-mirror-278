
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.nio.charset
import jpype
import typing



class Connection:
    def clear(self) -> None: ...
    def close(self) -> None: ...
    def getEncoding(self) -> java.nio.charset.Charset: ...
    @typing.overload
    def read(self) -> str: ...
    @typing.overload
    def read(self, int: int) -> str: ...
    def readBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def setEncoding(self, charset: java.nio.charset.Charset) -> None: ...
    @typing.overload
    def setReadTerminator(self, long: int) -> None: ...
    @typing.overload
    def setReadTerminator(self, string: str) -> None: ...
    def setTimeout(self, int: int) -> None: ...
    def write(self, string: str) -> None: ...
    def writeBytes(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...

class GPIBConnection(Connection):
    def isEOIEnabled(self) -> bool: ...
    def setEOIEnabled(self, boolean: bool) -> None: ...

class LXIConnection(Connection): ...

class SerialConnection(Connection):
    @typing.overload
    def setSerialParameters(self, int: int, int2: int, parity: 'SerialConnection.Parity', stop: 'SerialConnection.Stop', *flowControl: 'SerialConnection.FlowControl') -> None: ...
    @typing.overload
    def setSerialParameters(self, int: int, int2: int) -> None: ...
    @typing.overload
    def setSerialParameters(self, int: int, int2: int, parity: 'SerialConnection.Parity', double: float, *flowControl: 'SerialConnection.FlowControl') -> None: ...
    @typing.overload
    def setSerialParameters(self, int: int, int2: int, parity: 'SerialConnection.Parity', int3: int, *flowControl: 'SerialConnection.FlowControl') -> None: ...
    class FlowControl(java.lang.Enum['SerialConnection.FlowControl']):
        NONE: typing.ClassVar['SerialConnection.FlowControl'] = ...
        XON_XOFF: typing.ClassVar['SerialConnection.FlowControl'] = ...
        RTS_CTS: typing.ClassVar['SerialConnection.FlowControl'] = ...
        DTR_DSR: typing.ClassVar['SerialConnection.FlowControl'] = ...
        def toInt(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SerialConnection.FlowControl': ...
        @staticmethod
        def values() -> typing.MutableSequence['SerialConnection.FlowControl']: ...
    class Parity(java.lang.Enum['SerialConnection.Parity']):
        NONE: typing.ClassVar['SerialConnection.Parity'] = ...
        ODD: typing.ClassVar['SerialConnection.Parity'] = ...
        EVEN: typing.ClassVar['SerialConnection.Parity'] = ...
        MARK: typing.ClassVar['SerialConnection.Parity'] = ...
        SPACE: typing.ClassVar['SerialConnection.Parity'] = ...
        def toInt(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SerialConnection.Parity': ...
        @staticmethod
        def values() -> typing.MutableSequence['SerialConnection.Parity']: ...
    class Stop(java.lang.Enum['SerialConnection.Stop']):
        BITS_10: typing.ClassVar['SerialConnection.Stop'] = ...
        BITS_15: typing.ClassVar['SerialConnection.Stop'] = ...
        BITS_20: typing.ClassVar['SerialConnection.Stop'] = ...
        def toInt(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'SerialConnection.Stop': ...
        @staticmethod
        def values() -> typing.MutableSequence['SerialConnection.Stop']: ...

class TCPIPConnection(Connection):
    def isKeepAliveEnabled(self) -> bool: ...
    def setKeepAliveEnabled(self, boolean: bool) -> None: ...

class USBConnection(Connection): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.visa.connections")``.

    Connection: typing.Type[Connection]
    GPIBConnection: typing.Type[GPIBConnection]
    LXIConnection: typing.Type[LXIConnection]
    SerialConnection: typing.Type[SerialConnection]
    TCPIPConnection: typing.Type[TCPIPConnection]
    USBConnection: typing.Type[USBConnection]
