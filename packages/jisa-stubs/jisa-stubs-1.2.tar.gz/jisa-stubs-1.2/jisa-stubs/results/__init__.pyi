
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.function
import java.util.stream
import jisa
import jisa.maths.matrices
import kotlin
import kotlin.reflect
import typing



_Column__T = typing.TypeVar('_Column__T')  # <T>
class Column(typing.Generic[_Column__T]):
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Column__T]): ...
    @typing.overload
    def __init__(self, string: str, class_: typing.Type[_Column__T], rowEvaluable: typing.Union['RowEvaluable'[_Column__T], typing.Callable[['Row'], _Column__T]]): ...
    @typing.overload
    def __init__(self, string: str, string2: str, class_: typing.Type[_Column__T]): ...
    @typing.overload
    def __init__(self, string: str, string2: str, class_: typing.Type[_Column__T], rowEvaluable: typing.Union['RowEvaluable'[_Column__T], typing.Callable[['Row'], _Column__T]]): ...
    _byExample__T = typing.TypeVar('_byExample__T')  # <T>
    @staticmethod
    def byExample(t: _byExample__T, string: str, string2: str) -> 'Column'[_byExample__T]: ...
    def calculate(self, row: 'Row') -> _Column__T: ...
    def getMatcherName(self) -> str: ...
    def getMatcherTitle(self) -> str: ...
    def getName(self) -> str: ...
    def getTitle(self) -> str: ...
    def getType(self) -> typing.Type[_Column__T]: ...
    def getUnits(self) -> str: ...
    def hasUnits(self) -> bool: ...
    def isCalculated(self) -> bool: ...
    _of_0__T = typing.TypeVar('_of_0__T')  # <T>
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    @typing.overload
    @staticmethod
    def of(class_: typing.Type[_of_0__T], string: str, string2: str) -> 'Column'[_of_0__T]: ...
    @typing.overload
    @staticmethod
    def of(kClass: kotlin.reflect.KClass[_of_1__T], string: str, string2: str) -> 'Column'[_of_1__T]: ...
    @typing.overload
    @staticmethod
    def ofBooleans(string: str) -> 'Column'[bool]: ...
    @typing.overload
    @staticmethod
    def ofBooleans(string: str, string2: str) -> 'Column'[bool]: ...
    @typing.overload
    @staticmethod
    def ofBooleans(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[bool], typing.Callable[['Row'], bool]]) -> 'Column'[bool]: ...
    @typing.overload
    @staticmethod
    def ofBooleans(string: str, rowEvaluable: typing.Union['RowEvaluable'[bool], typing.Callable[['Row'], bool]]) -> 'Column'[bool]: ...
    @typing.overload
    @staticmethod
    def ofDecimals(string: str) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDecimals(string: str, string2: str) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDecimals(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[float], typing.Callable[['Row'], float]]) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDecimals(string: str, rowEvaluable: typing.Union['RowEvaluable'[float], typing.Callable[['Row'], float]]) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDoubles(string: str) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDoubles(string: str, string2: str) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDoubles(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[float], typing.Callable[['Row'], float]]) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofDoubles(string: str, rowEvaluable: typing.Union['RowEvaluable'[float], typing.Callable[['Row'], float]]) -> 'Column'[float]: ...
    @typing.overload
    @staticmethod
    def ofIntegers(string: str) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofIntegers(string: str, string2: str) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofIntegers(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[int], typing.Callable[['Row'], int]]) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofIntegers(string: str, rowEvaluable: typing.Union['RowEvaluable'[int], typing.Callable[['Row'], int]]) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofLongs(string: str) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofLongs(string: str, string2: str) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofLongs(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[int], typing.Callable[['Row'], int]]) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofLongs(string: str, rowEvaluable: typing.Union['RowEvaluable'[int], typing.Callable[['Row'], int]]) -> 'Column'[int]: ...
    @typing.overload
    @staticmethod
    def ofStrings(string: str) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofStrings(string: str, string2: str) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofStrings(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[str], typing.Callable[['Row'], str]]) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofStrings(string: str, rowEvaluable: typing.Union['RowEvaluable'[str], typing.Callable[['Row'], str]]) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofText(string: str) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofText(string: str, string2: str) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofText(string: str, string2: str, rowEvaluable: typing.Union['RowEvaluable'[str], typing.Callable[['Row'], str]]) -> 'Column'[str]: ...
    @typing.overload
    @staticmethod
    def ofText(string: str, rowEvaluable: typing.Union['RowEvaluable'[str], typing.Callable[['Row'], str]]) -> 'Column'[str]: ...
    def parse(self, string: str) -> _Column__T: ...
    def stringify(self, object: typing.Any) -> str: ...
    def to(self, t: _Column__T) -> java.util.Map.Entry['Column', typing.Any]: ...

class Row:
    @typing.overload
    def __init__(self, list: java.util.List[Column[typing.Any]], map: typing.Union[java.util.Map[Column[typing.Any], typing.Any], typing.Mapping[Column[typing.Any], typing.Any]]): ...
    @typing.overload
    def __init__(self, map: typing.Union[java.util.Map[Column[typing.Any], typing.Any], typing.Mapping[Column[typing.Any], typing.Any]]): ...
    _get_2__T = typing.TypeVar('_get_2__T')  # <T>
    _get_3__T = typing.TypeVar('_get_3__T')  # <T>
    @typing.overload
    def get(self, int: int) -> float: ...
    @typing.overload
    def get(self, string: str) -> float: ...
    @typing.overload
    def get(self, string: str, class_: typing.Type[_get_2__T]) -> _get_2__T: ...
    @typing.overload
    def get(self, column: Column[_get_3__T]) -> _get_3__T: ...
    def getColumnArray(self) -> typing.MutableSequence[Column]: ...
    def getColumnSet(self) -> java.util.Set[Column[typing.Any]]: ...
    def getValues(self) -> java.util.Map[Column[typing.Any], typing.Any]: ...
    def stringList(self) -> java.util.List[str]: ...

_RowEvaluable__T = typing.TypeVar('_RowEvaluable__T')  # <T>
class RowEvaluable(typing.Generic[_RowEvaluable__T]):
    def evaluate(self, row: Row) -> _RowEvaluable__T: ...

class BooleanColumn(Column[bool]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[bool], typing.Callable[[Row], bool]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[bool], typing.Callable[[Row], bool]]): ...
    def parse(self, string: str) -> bool: ...
    def stringify(self, object: typing.Any) -> str: ...

class DoubleColumn(Column[float]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[float], typing.Callable[[Row], float]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[float], typing.Callable[[Row], float]]): ...
    def parse(self, string: str) -> float: ...
    def stringify(self, object: typing.Any) -> str: ...

class IntColumn(Column[int]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[int], typing.Callable[[Row], int]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[int], typing.Callable[[Row], int]]): ...
    def parse(self, string: str) -> int: ...
    def stringify(self, object: typing.Any) -> str: ...

class LongColumn(Column[int]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[int], typing.Callable[[Row], int]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[int], typing.Callable[[Row], int]]): ...
    def parse(self, string: str) -> int: ...
    def stringify(self, object: typing.Any) -> str: ...

class StringColumn(Column[str]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[str], typing.Callable[[Row], str]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[str], typing.Callable[[Row], str]]): ...
    def parse(self, string: str) -> str: ...
    def stringify(self, object: typing.Any) -> str: ...

class Col(DoubleColumn):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, rowEvaluable: typing.Union[RowEvaluable[float], typing.Callable[[Row], float]]): ...
    @typing.overload
    def __init__(self, string: str, rowEvaluable: typing.Union[RowEvaluable[float], typing.Callable[[Row], float]]): ...

class ResultList(jisa.results.ResultTable):
    @typing.overload
    def __init__(self, *string: str): ...
    @typing.overload
    def __init__(self, collection: typing.Union[java.util.Collection[Column], typing.Sequence[Column], typing.Set[Column]]): ...
    @typing.overload
    def __init__(self, *column: Column): ...
    @typing.overload
    @staticmethod
    def collect() -> java.util.stream.Collector[Row, typing.Any, 'ResultList']: ...
    @typing.overload
    @staticmethod
    def collect(*column: Column) -> java.util.stream.Collector[Row, typing.Any, 'ResultList']: ...
    @typing.overload
    @staticmethod
    def collect(resultTable: 'ResultTable') -> java.util.stream.Collector[Row, typing.Any, 'ResultList']: ...
    @staticmethod
    def copyOf(resultTable: 'ResultTable') -> 'ResultList': ...
    @staticmethod
    def emptyCopyOf(resultTable: 'ResultTable') -> 'ResultList': ...
    def getRow(self, int: int) -> Row: ...
    def getRowCount(self) -> int: ...
    def iterator(self) -> java.util.Iterator[Row]: ...
    @staticmethod
    def loadFile(string: str) -> 'ResultList': ...
    @staticmethod
    def mapCollector() -> java.util.stream.Collector[java.util.Map, typing.Any, 'ResultList']: ...
    def stream(self) -> java.util.stream.Stream[Row]: ...
    class ColumnBuilder:
        def create(self, string: str, string2: str) -> Column[typing.Any]: ...

class ResultStream(jisa.results.ResultTable):
    @typing.overload
    def __init__(self, string: str, *string2: str): ...
    @typing.overload
    def __init__(self, string: str, *column: Column[typing.Any]): ...
    @typing.overload
    def __init__(self, *column: Column[typing.Any]): ...
    def close(self) -> None: ...
    def getRow(self, int: int) -> Row: ...
    def getRowCount(self) -> int: ...
    def iterator(self) -> java.util.Iterator[Row]: ...
    @staticmethod
    def loadFile(string: str) -> 'ResultStream': ...
    @typing.overload
    def setAttribute(self, string: str, string2: str) -> None: ...
    @typing.overload
    def setAttribute(self, string: str, object: typing.Any) -> None: ...
    def stream(self) -> java.util.stream.Stream[Row]: ...

class ResultTable(java.lang.Iterable[Row]):
    STANDARD_TYPES: typing.ClassVar[java.util.Map] = ...
    def __init__(self, *column: Column[typing.Any]): ...
    def addClearListener(self, clearListener: typing.Union['ResultTable.ClearListener', typing.Callable]) -> 'ResultTable.ClearListener': ...
    def addData(self, *object: typing.Any) -> None: ...
    @typing.overload
    def addRow(self, rowable: typing.Union['ResultTable.Rowable', typing.Callable]) -> None: ...
    @typing.overload
    def addRow(self, row: Row) -> None: ...
    def addRowListener(self, rowListener: typing.Union['ResultTable.RowListener', typing.Callable]) -> 'ResultTable.RowListener': ...
    def allMatch(self, predicate: typing.Union[java.util.function.Predicate[Row], typing.Callable[[Row], bool]]) -> bool: ...
    def clear(self) -> None: ...
    def collector(self) -> java.util.stream.Collector[Row, typing.Any, ResultList]: ...
    @typing.overload
    def directionalSplit(self, column: Column[java.lang.Number]) -> java.util.List[ResultList]: ...
    @typing.overload
    def directionalSplit(self, rowEvaluable: typing.Union[RowEvaluable[java.lang.Number], typing.Callable[[Row], java.lang.Number]]) -> java.util.List[ResultList]: ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[Row], typing.Callable[[Row], bool]]) -> ResultList: ...
    def findBooleanColumn(self, string: str) -> Column[bool]: ...
    _findColumn_1__T = typing.TypeVar('_findColumn_1__T')  # <T>
    _findColumn_2__T = typing.TypeVar('_findColumn_2__T')  # <T>
    _findColumn_3__T = typing.TypeVar('_findColumn_3__T')  # <T>
    @typing.overload
    def findColumn(self, string: str) -> Column[java.lang.Number]: ...
    @typing.overload
    def findColumn(self, string: str, class_: typing.Type[_findColumn_1__T]) -> Column[_findColumn_1__T]: ...
    @typing.overload
    def findColumn(self, string: str, kClass: kotlin.reflect.KClass[_findColumn_2__T]) -> Column[_findColumn_2__T]: ...
    @typing.overload
    def findColumn(self, column: Column[_findColumn_3__T]) -> Column[_findColumn_3__T]: ...
    def findDecimalColumn(self, string: str) -> Column[float]: ...
    def findDoubleColumn(self, string: str) -> Column[float]: ...
    def findIntegerColumn(self, string: str) -> Column[int]: ...
    def findLongColumn(self, string: str) -> Column[int]: ...
    def findRow(self, predicate: typing.Union[java.util.function.Predicate[Row], typing.Callable[[Row], bool]]) -> Row: ...
    def findStringColumn(self, string: str) -> Column[str]: ...
    def findTextColumn(self, string: str) -> Column[str]: ...
    def get(self, int: int) -> Row: ...
    def getAttribute(self, string: str) -> str: ...
    def getAttributes(self) -> java.util.Map[str, str]: ...
    def getColumn(self, int: int) -> Column[typing.Any]: ...
    def getColumnCount(self) -> int: ...
    def getColumns(self) -> java.util.List[Column[typing.Any]]: ...
    def getColumnsAsArray(self) -> typing.MutableSequence[Column]: ...
    def getFirstNumericColumn(self) -> Column[java.lang.Number]: ...
    def getHTML(self) -> str: ...
    _getMax_0__T = typing.TypeVar('_getMax_0__T', bound=java.lang.Number)  # <T>
    _getMax_1__T = typing.TypeVar('_getMax_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def getMax(self, column: Column[_getMax_0__T]) -> _getMax_0__T: ...
    @typing.overload
    def getMax(self, rowEvaluable: typing.Union[RowEvaluable[_getMax_1__T], typing.Callable[[Row], _getMax_1__T]]) -> _getMax_1__T: ...
    _getMin_0__T = typing.TypeVar('_getMin_0__T', bound=java.lang.Number)  # <T>
    _getMin_1__T = typing.TypeVar('_getMin_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def getMin(self, column: Column[_getMin_0__T]) -> _getMin_0__T: ...
    @typing.overload
    def getMin(self, rowEvaluable: typing.Union[RowEvaluable[_getMin_1__T], typing.Callable[[Row], _getMin_1__T]]) -> _getMin_1__T: ...
    def getNthNumericColumn(self, int: int) -> Column[java.lang.Number]: ...
    def getNumericColumns(self) -> java.util.List[Column[java.lang.Number]]: ...
    def getRow(self, int: int) -> Row: ...
    def getRowCount(self) -> int: ...
    def getRows(self) -> java.util.List[Row]: ...
    _getUniqueValues_0__T = typing.TypeVar('_getUniqueValues_0__T')  # <T>
    _getUniqueValues_1__T = typing.TypeVar('_getUniqueValues_1__T')  # <T>
    @typing.overload
    def getUniqueValues(self, column: Column[_getUniqueValues_0__T]) -> java.util.List[_getUniqueValues_0__T]: ...
    @typing.overload
    def getUniqueValues(self, rowEvaluable: typing.Union[RowEvaluable[_getUniqueValues_1__T], typing.Callable[[Row], _getUniqueValues_1__T]]) -> java.util.List[_getUniqueValues_1__T]: ...
    @typing.overload
    def mapRow(self, *entry: java.util.Map.Entry[Column, typing.Any]) -> None: ...
    @typing.overload
    def mapRow(self, map: typing.Union[java.util.Map[Column[typing.Any], typing.Any], typing.Mapping[Column[typing.Any], typing.Any]]) -> None: ...
    @typing.overload
    def mapRow(self, *pair: kotlin.Pair[Column, typing.Any]) -> None: ...
    @typing.overload
    def mapRows(self, map: typing.Union[java.util.Map[Column, typing.Union[java.lang.Iterable, typing.Sequence, typing.Set, typing.Callable]], typing.Mapping[Column, typing.Union[java.lang.Iterable, typing.Sequence, typing.Set, typing.Callable]]]) -> None: ...
    @typing.overload
    def mapRows(self, *pair: kotlin.Pair[Column, typing.Union[java.lang.Iterable, typing.Sequence, typing.Set, typing.Callable]]) -> None: ...
    _max_0__T = typing.TypeVar('_max_0__T', bound=java.lang.Number)  # <T>
    _max_1__T = typing.TypeVar('_max_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def max(self, column: Column[_max_0__T]) -> _max_0__T: ...
    @typing.overload
    def max(self, rowEvaluable: typing.Union[RowEvaluable[_max_1__T], typing.Callable[[Row], _max_1__T]]) -> _max_1__T: ...
    _maxBy_0__T = typing.TypeVar('_maxBy_0__T', bound=java.lang.Number)  # <T>
    _maxBy_1__T = typing.TypeVar('_maxBy_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def maxBy(self, column: Column[_maxBy_0__T]) -> Row: ...
    @typing.overload
    def maxBy(self, rowEvaluable: typing.Union[RowEvaluable[_maxBy_1__T], typing.Callable[[Row], _maxBy_1__T]]) -> Row: ...
    @typing.overload
    def mean(self, column: Column[java.lang.Number]) -> float: ...
    @typing.overload
    def mean(self, rowEvaluable: typing.Union[RowEvaluable[java.lang.Number], typing.Callable[[Row], java.lang.Number]]) -> float: ...
    _min_0__T = typing.TypeVar('_min_0__T', bound=java.lang.Number)  # <T>
    _min_1__T = typing.TypeVar('_min_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def min(self, column: Column[_min_0__T]) -> _min_0__T: ...
    @typing.overload
    def min(self, rowEvaluable: typing.Union[RowEvaluable[_min_1__T], typing.Callable[[Row], _min_1__T]]) -> _min_1__T: ...
    _minBy_0__T = typing.TypeVar('_minBy_0__T', bound=java.lang.Number)  # <T>
    _minBy_1__T = typing.TypeVar('_minBy_1__T', bound=java.lang.Number)  # <T>
    @typing.overload
    def minBy(self, column: Column[_minBy_0__T]) -> Row: ...
    @typing.overload
    def minBy(self, rowEvaluable: typing.Union[RowEvaluable[_minBy_1__T], typing.Callable[[Row], _minBy_1__T]]) -> Row: ...
    def noneMatch(self, predicate: typing.Union[java.util.function.Predicate[Row], typing.Callable[[Row], bool]]) -> bool: ...
    @typing.overload
    def output(self) -> None: ...
    @typing.overload
    def output(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def output(self, string: str) -> None: ...
    @typing.overload
    def outputHTML(self) -> None: ...
    @typing.overload
    def outputHTML(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def outputHTML(self, string: str) -> None: ...
    @typing.overload
    def outputTable(self) -> None: ...
    @typing.overload
    def outputTable(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def outputTable(self, printStream: java.io.PrintStream, string: str) -> None: ...
    @typing.overload
    def outputTable(self, string: str) -> None: ...
    @staticmethod
    def parseColumnHeaderLine(string: str) -> typing.MutableSequence[Column]: ...
    def removeClearListener(self, clearListener: typing.Union['ResultTable.ClearListener', typing.Callable]) -> None: ...
    def removeRowListener(self, rowListener: typing.Union['ResultTable.RowListener', typing.Callable]) -> None: ...
    def reverse(self) -> ResultList: ...
    @typing.overload
    def setAttribute(self, string: str, object: typing.Any) -> None: ...
    @typing.overload
    def setAttribute(self, string: str, string2: str) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def sorted(self, column: Column[typing.Any]) -> ResultList: ...
    @typing.overload
    def sorted(self, rowEvaluable: typing.Union[RowEvaluable[typing.Any], typing.Callable[[Row], typing.Any]]) -> ResultList: ...
    _split_0__T = typing.TypeVar('_split_0__T')  # <T>
    _split_1__T = typing.TypeVar('_split_1__T')  # <T>
    @typing.overload
    def split(self, column: Column[_split_0__T]) -> java.util.Map[_split_0__T, ResultList]: ...
    @typing.overload
    def split(self, rowEvaluable: typing.Union[RowEvaluable[_split_1__T], typing.Callable[[Row], _split_1__T]]) -> java.util.Map[_split_1__T, ResultList]: ...
    def startRow(self) -> 'ResultTable.RowBuilder': ...
    def stream(self) -> java.util.stream.Stream[Row]: ...
    @typing.overload
    def subTable(self, int: int, int2: int) -> ResultList: ...
    @typing.overload
    def subTable(self, int: int, int2: int, *column: Column) -> ResultList: ...
    @typing.overload
    def subTable(self, *column: Column) -> ResultList: ...
    _toList_0__T = typing.TypeVar('_toList_0__T')  # <T>
    _toList_1__T = typing.TypeVar('_toList_1__T')  # <T>
    @typing.overload
    def toList(self, column: Column[_toList_0__T]) -> java.util.List[_toList_0__T]: ...
    @typing.overload
    def toList(self, rowEvaluable: typing.Union[RowEvaluable[_toList_1__T], typing.Callable[[Row], _toList_1__T]]) -> java.util.List[_toList_1__T]: ...
    @typing.overload
    def toMatrix(self, *column: Column[java.lang.Number]) -> jisa.maths.matrices.RealMatrix: ...
    @typing.overload
    def toMatrix(self, *rowEvaluable: typing.Union[RowEvaluable[java.lang.Number], typing.Callable[[Row], java.lang.Number]]) -> jisa.maths.matrices.RealMatrix: ...
    def transform(self, map: typing.Union[java.util.Map[Column[typing.Any], typing.Union[RowEvaluable[typing.Any], typing.Callable[[Row], typing.Any]]], typing.Mapping[Column[typing.Any], typing.Union[RowEvaluable[typing.Any], typing.Callable[[Row], typing.Any]]]]) -> ResultList: ...
    class ClearListener:
        def cleared(self) -> None: ...
    class RowBuilder(jisa.results.ResultTable.RowSetter):
        def __init__(self, resultTable: 'ResultTable'): ...
        def endRow(self) -> 'ResultTable': ...
        _set__T = typing.TypeVar('_set__T')  # <T>
        def set(self, column: Column[_set__T], t: _set__T) -> 'ResultTable.RowBuilder': ...
    class RowListener:
        def added(self, row: Row) -> None: ...
    class RowSetter:
        def __init__(self, resultTable: 'ResultTable'): ...
        _get__T = typing.TypeVar('_get__T')  # <T>
        def get(self, column: Column[_get__T]) -> _get__T: ...
        _set__T = typing.TypeVar('_set__T')  # <T>
        def set(self, column: Column[_set__T], t: _set__T) -> 'ResultTable.RowSetter': ...
    class Rowable:
        def build(self, rowSetter: 'ResultTable.RowSetter') -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.results")``.

    BooleanColumn: typing.Type[BooleanColumn]
    Col: typing.Type[Col]
    Column: typing.Type[Column]
    DoubleColumn: typing.Type[DoubleColumn]
    IntColumn: typing.Type[IntColumn]
    LongColumn: typing.Type[LongColumn]
    ResultList: typing.Type[ResultList]
    ResultStream: typing.Type[ResultStream]
    ResultTable: typing.Type[ResultTable]
    Row: typing.Type[Row]
    RowEvaluable: typing.Type[RowEvaluable]
    StringColumn: typing.Type[StringColumn]
