
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jisa.addresses
import jisa.devices.interfaces
import jisa.enums
import jisa.experiment
import jisa.visa
import jisa.visa.drivers
import jpype
import typing



_AgilentSPA__T = typing.TypeVar('_AgilentSPA__T', bound='AgilentSPA')  # <T>
class AgilentSPA(jisa.visa.VISADevice, jisa.devices.interfaces.SPA['AgilentSPA.ASMU', 'AgilentSPA.AVMU', 'AgilentSPA.AVSU', 'AgilentSPA.GNDU'], typing.Generic[_AgilentSPA__T]):
    C_RESET: typing.ClassVar[str] = ...
    C_FLEX: typing.ClassVar[str] = ...
    C_FMT: typing.ClassVar[str] = ...
    def __init__(self, address: jisa.addresses.Address, boolean: bool): ...
    class ASMU(jisa.devices.interfaces.SMU, jisa.devices.interfaces.SubInstrument[_AgilentSPA__T]):
        def __init__(self, agilentSPA: 'AgilentSPA', string: str, int: int, rangeArray: typing.Union[typing.List['AgilentSPA.Range'], jpype.JArray], rangeArray2: typing.Union[typing.List['AgilentSPA.Range'], jpype.JArray]): ...
        def getAverageCount(self) -> int: ...
        def getAverageMode(self) -> jisa.enums.AMode: ...
        @typing.overload
        def getCurrent(self, double: float) -> float: ...
        @typing.overload
        def getCurrent(self) -> float: ...
        def getCurrentLimit(self) -> float: ...
        def getCurrentRange(self) -> float: ...
        def getIntegrationTime(self) -> float: ...
        def getMeasureRange(self) -> float: ...
        def getMeasureValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
        def getOutputLimit(self) -> float: ...
        def getParentInstrument(self) -> _AgilentSPA__T: ...
        def getSetCurrent(self) -> float: ...
        def getSetVoltage(self) -> float: ...
        def getSource(self) -> jisa.enums.Source: ...
        def getSourceRange(self) -> float: ...
        def getSourceValue(self) -> float: ...
        def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
        def getTerminals(self) -> jisa.enums.Terminals: ...
        @typing.overload
        def getVoltage(self, double: float) -> float: ...
        @typing.overload
        def getVoltage(self) -> float: ...
        def getVoltageLimit(self) -> float: ...
        def getVoltageRange(self) -> float: ...
        def isAutoRangingCurrent(self) -> bool: ...
        def isAutoRangingMeasure(self) -> bool: ...
        def isAutoRangingSource(self) -> bool: ...
        def isAutoRangingVoltage(self) -> bool: ...
        def isFourProbeEnabled(self) -> bool: ...
        def isLineFilterEnabled(self) -> bool: ...
        def isOn(self) -> bool: ...
        def setAverageCount(self, int: int) -> None: ...
        def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
        def setCurrent(self, double: float) -> None: ...
        def setCurrentLimit(self, double: float) -> None: ...
        def setCurrentRange(self, double: float) -> None: ...
        def setFourProbeEnabled(self, boolean: bool) -> None: ...
        def setIntegrationTime(self, double: float) -> None: ...
        def setLineFilterEnabled(self, boolean: bool) -> None: ...
        def setMeasureRange(self, double: float) -> None: ...
        def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
        def setOutputLimit(self, double: float) -> None: ...
        def setSource(self, source: jisa.enums.Source) -> None: ...
        def setSourceRange(self, double: float) -> None: ...
        def setSourceValue(self, double: float) -> None: ...
        def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
        def setVoltage(self, double: float) -> None: ...
        def setVoltageLimit(self, double: float) -> None: ...
        def setVoltageRange(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
        def useAutoCurrentRange(self) -> None: ...
        def useAutoMeasureRange(self) -> None: ...
        def useAutoSourceRange(self) -> None: ...
        def useAutoVoltageRange(self) -> None: ...
    class AVMU(jisa.devices.interfaces.VMeter, jisa.devices.interfaces.SubInstrument[_AgilentSPA__T]):
        def __init__(self, agilentSPA: 'AgilentSPA', string: str, int: int, rangeArray: typing.Union[typing.List['AgilentSPA.Range'], jpype.JArray]): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAverageCount(self) -> int: ...
        def getAverageMode(self) -> jisa.enums.AMode: ...
        def getIntegrationTime(self) -> float: ...
        def getName(self) -> str: ...
        def getParentInstrument(self) -> _AgilentSPA__T: ...
        def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
        def getTerminals(self) -> jisa.enums.Terminals: ...
        @typing.overload
        def getVoltage(self, double: float) -> float: ...
        @typing.overload
        def getVoltage(self) -> float: ...
        def getVoltageRange(self) -> float: ...
        def isAutoRangingVoltage(self) -> bool: ...
        def isOn(self) -> bool: ...
        def setAverageCount(self, int: int) -> None: ...
        def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
        def setIntegrationTime(self, double: float) -> None: ...
        def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
        def setVoltageRange(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
        def useAutoVoltageRange(self) -> None: ...
    class AVSU(jisa.devices.interfaces.VSource, jisa.devices.interfaces.SubInstrument[_AgilentSPA__T]):
        def __init__(self, agilentSPA: 'AgilentSPA', string: str, int: int): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
        def getParentInstrument(self) -> _AgilentSPA__T: ...
        def getVoltage(self) -> float: ...
        def isOn(self) -> bool: ...
        def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
        def setVoltage(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
    class GNDU(jisa.devices.interfaces.Switch, jisa.devices.interfaces.SubInstrument[_AgilentSPA__T]):
        def __init__(self, agilentSPA: 'AgilentSPA', string: str, int: int): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getParentInstrument(self) -> _AgilentSPA__T: ...
        def isOn(self) -> bool: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
    class Range:
        AUTO_RANGING: typing.ClassVar['AgilentSPA.Range'] = ...
        def getCompliance(self) -> float: ...
        def getRange(self) -> float: ...
        def toInt(self) -> int: ...

class DummyMCSMU(jisa.devices.interfaces.MCSMU['DummyMCSMU.DSMU']):
    def __init__(self): ...
    def close(self) -> None: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIDN(self) -> str: ...
    def getName(self) -> str: ...
    def getSMUs(self) -> java.util.List['DummyMCSMU.DSMU']: ...
    class DSMU(jisa.devices.interfaces.SMU, jisa.devices.interfaces.SubInstrument['DummyMCSMU']):
        def __init__(self, dummyMCSMU: 'DummyMCSMU', int: int): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAverageCount(self) -> int: ...
        def getAverageMode(self) -> jisa.enums.AMode: ...
        @typing.overload
        def getCurrent(self, double: float) -> float: ...
        @typing.overload
        def getCurrent(self) -> float: ...
        def getCurrentLimit(self) -> float: ...
        def getCurrentRange(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIntegrationTime(self) -> float: ...
        def getMeasureRange(self) -> float: ...
        def getMeasureValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
        def getOutputLimit(self) -> float: ...
        def getParentInstrument(self) -> 'DummyMCSMU': ...
        def getSetCurrent(self) -> float: ...
        def getSetVoltage(self) -> float: ...
        def getSource(self) -> jisa.enums.Source: ...
        def getSourceRange(self) -> float: ...
        def getSourceValue(self) -> float: ...
        def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
        def getTerminals(self) -> jisa.enums.Terminals: ...
        @typing.overload
        def getVoltage(self, double: float) -> float: ...
        @typing.overload
        def getVoltage(self) -> float: ...
        def getVoltageLimit(self) -> float: ...
        def getVoltageRange(self) -> float: ...
        def isAutoRangingCurrent(self) -> bool: ...
        def isAutoRangingMeasure(self) -> bool: ...
        def isAutoRangingSource(self) -> bool: ...
        def isAutoRangingVoltage(self) -> bool: ...
        def isFourProbeEnabled(self) -> bool: ...
        def isLineFilterEnabled(self) -> bool: ...
        def isOn(self) -> bool: ...
        def setAverageCount(self, int: int) -> None: ...
        def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
        def setCurrent(self, double: float) -> None: ...
        def setCurrentLimit(self, double: float) -> None: ...
        def setCurrentRange(self, double: float) -> None: ...
        def setFourProbeEnabled(self, boolean: bool) -> None: ...
        def setIntegrationTime(self, double: float) -> None: ...
        def setLineFilterEnabled(self, boolean: bool) -> None: ...
        def setMeasureRange(self, double: float) -> None: ...
        def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
        def setOutputLimit(self, double: float) -> None: ...
        def setSource(self, source: jisa.enums.Source) -> None: ...
        def setSourceRange(self, double: float) -> None: ...
        def setSourceValue(self, double: float) -> None: ...
        def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
        def setVoltage(self, double: float) -> None: ...
        def setVoltageLimit(self, double: float) -> None: ...
        def setVoltageRange(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
        def useAutoCurrentRange(self) -> None: ...
        def useAutoMeasureRange(self) -> None: ...
        def useAutoSourceRange(self) -> None: ...
        def useAutoVoltageRange(self) -> None: ...

class K236(jisa.visa.VISADevice, jisa.devices.interfaces.SMU):
    def __init__(self, address: jisa.addresses.Address): ...
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    def getCurrentLimit(self) -> float: ...
    def getCurrentRange(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getFunction(self) -> 'K236.Function': ...
    def getIDN(self) -> str: ...
    def getIntegrationTime(self) -> float: ...
    def getMeasureRange(self) -> float: ...
    def getMeasureValue(self) -> float: ...
    def getName(self) -> str: ...
    def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
    def getOutputLimit(self) -> float: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getSource(self) -> jisa.enums.Source: ...
    def getSourceRange(self) -> float: ...
    def getSourceValue(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isAutoRangingMeasure(self) -> bool: ...
    def isAutoRangingSource(self) -> bool: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    def manuallyClearReadBuffer(self) -> None: ...
    @typing.overload
    def read(self) -> str: ...
    @typing.overload
    def read(self, int: int) -> str: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def setMeasureRange(self, double: float) -> None: ...
    def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
    def setOutputLimit(self, double: float) -> None: ...
    def setSource(self, source: jisa.enums.Source) -> None: ...
    def setSourceFunction(self, source: 'K236.Source', function: 'K236.Function') -> None: ...
    def setSourceRange(self, double: float) -> None: ...
    def setSourceValue(self, double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def useAutoMeasureRange(self) -> None: ...
    def useAutoSourceRange(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...
    def write(self, string: str, *object: typing.Any) -> None: ...
    class Function(java.lang.Enum['K236.Function']):
        DC: typing.ClassVar['K236.Function'] = ...
        SWEEP: typing.ClassVar['K236.Function'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'K236.Function': ...
        @staticmethod
        def values() -> typing.MutableSequence['K236.Function']: ...
    class Source(java.lang.Enum['K236.Source']):
        CURRENT: typing.ClassVar['K236.Source'] = ...
        VOLTAGE: typing.ClassVar['K236.Source'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'K236.Source': ...
        @staticmethod
        def values() -> typing.MutableSequence['K236.Source']: ...

class K2400(jisa.visa.VISADevice, jisa.devices.interfaces.SMU):
    def __init__(self, address: jisa.addresses.Address): ...
    def disableAveraging(self) -> None: ...
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    def getCurrentLimit(self) -> float: ...
    def getCurrentRange(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIntegrationTime(self) -> float: ...
    def getMeasureMode(self) -> jisa.enums.Source: ...
    def getMeasureRange(self) -> float: ...
    def getMeasureValue(self) -> float: ...
    def getName(self) -> str: ...
    def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
    def getOutputLimit(self) -> float: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getSource(self) -> jisa.enums.Source: ...
    def getSourceMode(self) -> jisa.enums.Source: ...
    def getSourceRange(self) -> float: ...
    def getSourceValue(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isAutoRangingMeasure(self) -> bool: ...
    def isAutoRangingSource(self) -> bool: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def mario(self) -> None: ...
    def measureCurrent(self) -> float: ...
    def measureVoltage(self) -> float: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def setMeasureRange(self, double: float) -> None: ...
    def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
    def setOutputLimit(self, double: float) -> None: ...
    def setSource(self, source: jisa.enums.Source) -> None: ...
    def setSourceRange(self, double: float) -> None: ...
    def setSourceValue(self, double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def useAutoMeasureRange(self) -> None: ...
    def useAutoSourceRange(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...

class KeithleySCPI(jisa.visa.VISADevice, jisa.devices.interfaces.SMU):
    @typing.overload
    def __init__(self, address: jisa.addresses.Address): ...
    @typing.overload
    def __init__(self, address: jisa.addresses.Address, class_: typing.Type[jisa.visa.drivers.Driver]): ...
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    def getCurrentLimit(self) -> float: ...
    def getCurrentRange(self) -> float: ...
    def getIntegrationTime(self) -> float: ...
    def getMeasureMode(self) -> 'KeithleySCPI.Source': ...
    def getMeasureRange(self) -> float: ...
    def getMeasureValue(self) -> float: ...
    def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
    def getOutputLimit(self) -> float: ...
    def getSource(self) -> jisa.enums.Source: ...
    def getSourceMode(self) -> 'KeithleySCPI.Source': ...
    def getSourceRange(self) -> float: ...
    def getSourceValue(self) -> float: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isAutoRangingMeasure(self) -> bool: ...
    def isAutoRangingSource(self) -> bool: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    def mario(self) -> None: ...
    def pulseVoltage(self, double: float, double2: float, double3: float) -> float: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setMeasureRange(self, double: float) -> None: ...
    def setOutputLimit(self, double: float) -> None: ...
    def setOutputState(self, boolean: bool) -> None: ...
    @typing.overload
    def setSource(self, source: 'KeithleySCPI.Source') -> None: ...
    @typing.overload
    def setSource(self, source: jisa.enums.Source) -> None: ...
    def setSourceRange(self, double: float) -> None: ...
    @typing.overload
    def setSourceValue(self, double: float) -> None: ...
    @typing.overload
    def setSourceValue(self, source: 'KeithleySCPI.Source', double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def useAutoMeasureRange(self) -> None: ...
    def useAutoSourceRange(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...
    def youDidIt(self) -> None: ...
    class Source(java.lang.Enum['KeithleySCPI.Source']):
        VOLTAGE: typing.ClassVar['KeithleySCPI.Source'] = ...
        CURRENT: typing.ClassVar['KeithleySCPI.Source'] = ...
        @staticmethod
        def fromSMU(source: jisa.enums.Source) -> 'KeithleySCPI.Source': ...
        @staticmethod
        def fromTag(string: str) -> 'KeithleySCPI.Source': ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'KeithleySCPI.Source': ...
        @staticmethod
        def values() -> typing.MutableSequence['KeithleySCPI.Source']: ...

_KeithleyTSP__KSMU__T = typing.TypeVar('_KeithleyTSP__KSMU__T', bound='KeithleyTSP')  # <T>
class KeithleyTSP(jisa.visa.VISADevice):
    def __init__(self, address: jisa.addresses.Address, string: str): ...
    def clearErrorQueue(self) -> None: ...
    def errorsEmpty(self) -> bool: ...
    def getNextError(self) -> str: ...
    def getNumErrors(self) -> int: ...
    class KSMU(jisa.devices.interfaces.SMU, jisa.devices.interfaces.SubInstrument['KeithleyTSP'], typing.Generic[_KeithleyTSP__KSMU__T]):
        def __init__(self, keithleyTSP: 'KeithleyTSP', string: str, keithleyTSP2: 'KeithleyTSP'): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAverageCount(self) -> int: ...
        def getAverageMode(self) -> jisa.enums.AMode: ...
        @typing.overload
        def getCurrent(self, double: float) -> float: ...
        @typing.overload
        def getCurrent(self) -> float: ...
        def getCurrentLimit(self) -> float: ...
        def getCurrentRange(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIntegrationTime(self) -> float: ...
        def getMeasureRange(self) -> float: ...
        def getMeasureValue(self) -> float: ...
        def getMeasured(self) -> jisa.enums.Source: ...
        def getName(self) -> str: ...
        def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
        def getOutputLimit(self) -> float: ...
        def getParentInstrument(self) -> _KeithleyTSP__KSMU__T: ...
        def getSetCurrent(self) -> float: ...
        def getSetVoltage(self) -> float: ...
        def getSource(self) -> jisa.enums.Source: ...
        def getSourceRange(self) -> float: ...
        def getSourceValue(self) -> float: ...
        def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
        def getTerminals(self) -> jisa.enums.Terminals: ...
        @typing.overload
        def getVoltage(self, double: float) -> float: ...
        @typing.overload
        def getVoltage(self) -> float: ...
        def getVoltageLimit(self) -> float: ...
        def getVoltageRange(self) -> float: ...
        def isAutoRangingCurrent(self) -> bool: ...
        def isAutoRangingMeasure(self) -> bool: ...
        def isAutoRangingSource(self) -> bool: ...
        def isAutoRangingVoltage(self) -> bool: ...
        def isFourProbeEnabled(self) -> bool: ...
        def isLineFilterEnabled(self) -> bool: ...
        def isOn(self) -> bool: ...
        def setAverageCount(self, int: int) -> None: ...
        def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
        def setCurrent(self, double: float) -> None: ...
        def setCurrentLimit(self, double: float) -> None: ...
        def setCurrentRange(self, double: float) -> None: ...
        def setFourProbeEnabled(self, boolean: bool) -> None: ...
        def setIntegrationTime(self, double: float) -> None: ...
        def setLineFilterEnabled(self, boolean: bool) -> None: ...
        def setMeasureRange(self, double: float) -> None: ...
        def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
        def setOutputLimit(self, double: float) -> None: ...
        def setSource(self, source: jisa.enums.Source) -> None: ...
        def setSourceRange(self, double: float) -> None: ...
        def setSourceValue(self, double: float) -> None: ...
        def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
        def setVoltage(self, double: float) -> None: ...
        def setVoltageLimit(self, double: float) -> None: ...
        def setVoltageRange(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
        def useAutoCurrentRange(self) -> None: ...
        def useAutoMeasureRange(self) -> None: ...
        def useAutoSourceRange(self) -> None: ...
        def useAutoVoltageRange(self) -> None: ...

class TestFET(jisa.devices.interfaces.MCSMU[jisa.devices.interfaces.SMU]):
    SD_CHANNEL: 'TestFET.SMU' = ...
    SG_CHANNEL: 'TestFET.SMU' = ...
    CHANNEL_SD: typing.ClassVar[int] = ...
    CHANNEL_SG: typing.ClassVar[int] = ...
    def __init__(self, address: jisa.addresses.Address): ...
    def close(self) -> None: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIDN(self) -> str: ...
    def getName(self) -> str: ...
    def getSMUs(self) -> java.util.List[jisa.devices.interfaces.SMU]: ...
    class SMU(jisa.devices.interfaces.SMU):
        def __init__(self, testFET: 'TestFET', int: int): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAverageCount(self) -> int: ...
        def getAverageMode(self) -> jisa.enums.AMode: ...
        @typing.overload
        def getCurrent(self, double: float) -> float: ...
        @typing.overload
        def getCurrent(self) -> float: ...
        def getCurrentLimit(self) -> float: ...
        def getCurrentRange(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIntegrationTime(self) -> float: ...
        def getMeasureRange(self) -> float: ...
        def getMeasureValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
        def getOutputLimit(self) -> float: ...
        def getSetCurrent(self) -> float: ...
        def getSetVoltage(self) -> float: ...
        def getSource(self) -> jisa.enums.Source: ...
        def getSourceRange(self) -> float: ...
        def getSourceValue(self) -> float: ...
        def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
        def getTerminals(self) -> jisa.enums.Terminals: ...
        @typing.overload
        def getVoltage(self, double: float) -> float: ...
        @typing.overload
        def getVoltage(self) -> float: ...
        def getVoltageLimit(self) -> float: ...
        def getVoltageRange(self) -> float: ...
        def isAutoRangingCurrent(self) -> bool: ...
        def isAutoRangingMeasure(self) -> bool: ...
        def isAutoRangingSource(self) -> bool: ...
        def isAutoRangingVoltage(self) -> bool: ...
        def isFourProbeEnabled(self) -> bool: ...
        def isLineFilterEnabled(self) -> bool: ...
        def isOn(self) -> bool: ...
        def setAverageCount(self, int: int) -> None: ...
        def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
        def setCurrent(self, double: float) -> None: ...
        def setCurrentLimit(self, double: float) -> None: ...
        def setCurrentRange(self, double: float) -> None: ...
        def setFourProbeEnabled(self, boolean: bool) -> None: ...
        def setIntegrationTime(self, double: float) -> None: ...
        def setLineFilterEnabled(self, boolean: bool) -> None: ...
        def setMeasureRange(self, double: float) -> None: ...
        def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
        def setOutputLimit(self, double: float) -> None: ...
        def setSource(self, source: jisa.enums.Source) -> None: ...
        def setSourceRange(self, double: float) -> None: ...
        def setSourceValue(self, double: float) -> None: ...
        def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
        def setVoltage(self, double: float) -> None: ...
        def setVoltageLimit(self, double: float) -> None: ...
        def setVoltageRange(self, double: float) -> None: ...
        def turnOff(self) -> None: ...
        def turnOn(self) -> None: ...
        def useAutoCurrentRange(self) -> None: ...
        def useAutoMeasureRange(self) -> None: ...
        def useAutoSourceRange(self) -> None: ...
        def useAutoVoltageRange(self) -> None: ...

class Agilent4155B(AgilentSPA['Agilent4155B']):
    SMU1: AgilentSPA.ASMU = ...
    SMU2: AgilentSPA.ASMU = ...
    SMU3: AgilentSPA.ASMU = ...
    SMU4: AgilentSPA.ASMU = ...
    SMU5: AgilentSPA.ASMU = ...
    SMU6: AgilentSPA.ASMU = ...
    HPSMU: AgilentSPA.ASMU = ...
    VSU1: AgilentSPA.AVSU = ...
    VSU2: AgilentSPA.AVSU = ...
    VMU1: AgilentSPA.AVMU = ...
    VMU2: AgilentSPA.AVMU = ...
    GNDU: AgilentSPA.GNDU = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannels(self) -> java.util.List[AgilentSPA.ASMU]: ...
    def getSwitchChannels(self) -> java.util.List[AgilentSPA.GNDU]: ...
    def getVMeterChannels(self) -> java.util.List[AgilentSPA.AVMU]: ...
    def getVSourceChannels(self) -> java.util.List[AgilentSPA.AVSU]: ...

class Agilent4155C(AgilentSPA):
    SMU1: AgilentSPA.ASMU = ...
    SMU2: AgilentSPA.ASMU = ...
    SMU3: AgilentSPA.ASMU = ...
    SMU4: AgilentSPA.ASMU = ...
    SMU5: AgilentSPA.ASMU = ...
    SMU6: AgilentSPA.ASMU = ...
    HPSMU: AgilentSPA.ASMU = ...
    VSU1: AgilentSPA.AVSU = ...
    VSU2: AgilentSPA.AVSU = ...
    VMU1: AgilentSPA.AVMU = ...
    VMU2: AgilentSPA.AVMU = ...
    GNDU: AgilentSPA.GNDU = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannels(self) -> java.util.List[AgilentSPA.ASMU]: ...
    def getSwitchChannels(self) -> java.util.List[AgilentSPA.GNDU]: ...
    def getVMeterChannels(self) -> java.util.List[AgilentSPA.AVMU]: ...
    def getVSourceChannels(self) -> java.util.List[AgilentSPA.AVSU]: ...

class Agilent4156B(AgilentSPA):
    SMU1: AgilentSPA.ASMU = ...
    SMU2: AgilentSPA.ASMU = ...
    SMU3: AgilentSPA.ASMU = ...
    SMU4: AgilentSPA.ASMU = ...
    SMU5: AgilentSPA.ASMU = ...
    SMU6: AgilentSPA.ASMU = ...
    HPSMU: AgilentSPA.ASMU = ...
    VSU1: AgilentSPA.AVSU = ...
    VSU2: AgilentSPA.AVSU = ...
    VMU1: AgilentSPA.AVMU = ...
    VMU2: AgilentSPA.AVMU = ...
    GNDU: AgilentSPA.GNDU = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannels(self) -> java.util.List[AgilentSPA.ASMU]: ...
    def getSwitchChannels(self) -> java.util.List[AgilentSPA.GNDU]: ...
    def getVMeterChannels(self) -> java.util.List[AgilentSPA.AVMU]: ...
    def getVSourceChannels(self) -> java.util.List[AgilentSPA.AVSU]: ...

class Agilent4156C(AgilentSPA['Agilent4156C']):
    SMU1: AgilentSPA.ASMU = ...
    SMU2: AgilentSPA.ASMU = ...
    SMU3: AgilentSPA.ASMU = ...
    SMU4: AgilentSPA.ASMU = ...
    SMU5: AgilentSPA.ASMU = ...
    SMU6: AgilentSPA.ASMU = ...
    HPSMU: AgilentSPA.ASMU = ...
    VSU1: AgilentSPA.AVSU = ...
    VSU2: AgilentSPA.AVSU = ...
    VMU1: AgilentSPA.AVMU = ...
    VMU2: AgilentSPA.AVMU = ...
    GNDU: AgilentSPA.GNDU = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannels(self) -> java.util.List[AgilentSPA.ASMU]: ...
    def getSwitchChannels(self) -> java.util.List[AgilentSPA.GNDU]: ...
    def getVMeterChannels(self) -> java.util.List[AgilentSPA.AVMU]: ...
    def getVSourceChannels(self) -> java.util.List[AgilentSPA.AVSU]: ...

class AgilentB1500A(AgilentSPA['AgilentB1500A']):
    GNDU: AgilentSPA.GNDU = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getSMUChannels(self) -> java.util.List[AgilentSPA.ASMU]: ...
    def getSwitchChannels(self) -> java.util.List[AgilentSPA.GNDU]: ...
    def getVMeterChannels(self) -> java.util.List[AgilentSPA.AVMU]: ...
    def getVSourceChannels(self) -> java.util.List[AgilentSPA.AVSU]: ...

class K1234(DummyMCSMU):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...

class K2450(KeithleySCPI):
    def __init__(self, address: jisa.addresses.Address): ...
    def fixLimits(self) -> None: ...
    def getCurrentLimit(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getName(self) -> str: ...
    def getOutputLimit(self) -> float: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getVoltageLimit(self) -> float: ...
    def isLimitTripped(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    @typing.overload
    def setMeasureRange(self, function: jisa.enums.Function, boolean: bool) -> None: ...
    @typing.overload
    def setMeasureRange(self, double: float) -> None: ...
    def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
    @typing.overload
    def setSourceValue(self, source: KeithleySCPI.Source, double: float) -> None: ...
    @typing.overload
    def setSourceValue(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...

_K26Dual__T = typing.TypeVar('_K26Dual__T', bound='K26Dual')  # <T>
class K26Dual(KeithleyTSP, jisa.devices.interfaces.MCSMU[KeithleyTSP.KSMU[_K26Dual__T]], typing.Generic[_K26Dual__T]):
    SMU_A: KeithleyTSP.KSMU = ...
    SMU_B: KeithleyTSP.KSMU = ...
    def __init__(self, address: jisa.addresses.Address, string: str): ...
    def getSMUs(self) -> java.util.List[KeithleyTSP.KSMU[_K26Dual__T]]: ...

_K26Single__T = typing.TypeVar('_K26Single__T', bound='K26Single')  # <T>
class K26Single(KeithleyTSP, jisa.devices.interfaces.SMU, typing.Generic[_K26Single__T]):
    SMU_A: KeithleyTSP.KSMU = ...
    def __init__(self, address: jisa.addresses.Address, string: str): ...
    def asAmmeter(self) -> jisa.devices.interfaces.IMeter: ...
    def asVoltmeter(self) -> jisa.devices.interfaces.VMeter: ...
    def disableAveraging(self, int: int) -> None: ...
    def getAverageCount(self) -> int: ...
    def getAverageMode(self) -> jisa.enums.AMode: ...
    @typing.overload
    def getCurrent(self) -> float: ...
    @typing.overload
    def getCurrent(self, double: float) -> float: ...
    def getCurrentLimit(self) -> float: ...
    def getCurrentRange(self) -> float: ...
    def getIVPoint(self) -> jisa.experiment.IVPoint: ...
    def getIntegrationTime(self) -> float: ...
    def getMeasureRange(self) -> float: ...
    def getMeasureValue(self) -> float: ...
    def getMeasured(self) -> jisa.enums.Source: ...
    def getOffMode(self) -> jisa.devices.interfaces.SMU.OffMode: ...
    def getOutputLimit(self) -> float: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getSource(self) -> jisa.enums.Source: ...
    def getSourceRange(self) -> float: ...
    def getSourceValue(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    @typing.overload
    def getVoltage(self) -> float: ...
    @typing.overload
    def getVoltage(self, double: float) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def getVoltageRange(self) -> float: ...
    def isAutoRangingCurrent(self) -> bool: ...
    def isAutoRangingMeasure(self) -> bool: ...
    def isAutoRangingSource(self) -> bool: ...
    def isAutoRangingVoltage(self) -> bool: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def isOn(self) -> bool: ...
    def measureCurrent(self) -> float: ...
    def measureVoltage(self) -> float: ...
    def pulseVoltage(self, double: float, double2: float, double3: float) -> float: ...
    def resetFilters(self) -> None: ...
    def setAverageCount(self, int: int) -> None: ...
    def setAverageMode(self, aMode: jisa.enums.AMode) -> None: ...
    def setAveraging(self, aMode: jisa.enums.AMode, int: int) -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setCurrentRange(self, double: float) -> None: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLimits(self, double: float, double2: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def setMeasureRange(self, double: float) -> None: ...
    def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
    def setOn(self, boolean: bool) -> None: ...
    def setOutputLimit(self, double: float) -> None: ...
    def setRanges(self, double: float, double2: float) -> None: ...
    def setSource(self, source: jisa.enums.Source) -> None: ...
    def setSourceRange(self, double: float) -> None: ...
    def setSourceValue(self, double: float) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def setVoltageRange(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...
    def useAutoCurrentRange(self) -> None: ...
    def useAutoMeasureRange(self) -> None: ...
    def useAutoRanges(self) -> None: ...
    def useAutoSourceRange(self) -> None: ...
    def useAutoVoltageRange(self) -> None: ...
    def waitForStableCurrent(self, double: float, int: int, int2: int) -> None: ...
    def waitForStableVoltage(self, double: float, int: int) -> None: ...

class K6430(KeithleySCPI):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getLockObject(self) -> typing.Any: ...
    def getName(self) -> str: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getTerminalType(self, terminals: jisa.enums.Terminals) -> jisa.enums.TType: ...
    def getTerminals(self) -> jisa.enums.Terminals: ...
    def isFourProbeEnabled(self) -> bool: ...
    def isLineFilterEnabled(self) -> bool: ...
    def setFourProbeEnabled(self, boolean: bool) -> None: ...
    def setIntegrationTime(self, double: float) -> None: ...
    def setLineFilterEnabled(self, boolean: bool) -> None: ...
    def setOffMode(self, offMode: jisa.devices.interfaces.SMU.OffMode) -> None: ...
    def setTerminals(self, terminals: jisa.enums.Terminals) -> None: ...

class K2611B(K26Single['K2611B']):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...

class K2612A(K26Dual['K2612A']):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...

class K2612B(K26Dual['K2612B']):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...

class K2614B(K26Dual['K2614B']):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...

class K2635A(K26Single['K2635A']):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.devices.smu")``.

    Agilent4155B: typing.Type[Agilent4155B]
    Agilent4155C: typing.Type[Agilent4155C]
    Agilent4156B: typing.Type[Agilent4156B]
    Agilent4156C: typing.Type[Agilent4156C]
    AgilentB1500A: typing.Type[AgilentB1500A]
    AgilentSPA: typing.Type[AgilentSPA]
    DummyMCSMU: typing.Type[DummyMCSMU]
    K1234: typing.Type[K1234]
    K236: typing.Type[K236]
    K2400: typing.Type[K2400]
    K2450: typing.Type[K2450]
    K2611B: typing.Type[K2611B]
    K2612A: typing.Type[K2612A]
    K2612B: typing.Type[K2612B]
    K2614B: typing.Type[K2614B]
    K2635A: typing.Type[K2635A]
    K26Dual: typing.Type[K26Dual]
    K26Single: typing.Type[K26Single]
    K6430: typing.Type[K6430]
    KeithleySCPI: typing.Type[KeithleySCPI]
    KeithleyTSP: typing.Type[KeithleyTSP]
    TestFET: typing.Type[TestFET]
