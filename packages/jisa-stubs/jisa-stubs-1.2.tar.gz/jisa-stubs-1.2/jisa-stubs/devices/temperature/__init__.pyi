
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.intelligt.modbus.jlibmodbus.serial
import java.lang
import java.util
import jisa
import jisa.addresses
import jisa.devices.interfaces
import jisa.visa
import kotlin.reflect
import typing



class ArroyoTEC(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getInputs(self) -> java.util.List[jisa.devices.interfaces.TC.TMeter]: ...
    def getLoops(self) -> java.util.List[jisa.devices.interfaces.TC.Loop]: ...
    def getOutputs(self) -> java.util.List[jisa.devices.interfaces.TC.Heater]: ...
    class SensorType(java.lang.Enum['ArroyoTEC.SensorType']):
        DISABLED: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        THERMISTOR_100uA: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        THERMISTOR_10uA: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        LM335: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        AD590: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        RTD: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        RTD_4_WIRE: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        THERMISTOR_1mA: typing.ClassVar['ArroyoTEC.SensorType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ArroyoTEC.SensorType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ArroyoTEC.SensorType']: ...

class CryoCon22C(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    SENSOR_A: 'CryoCon22C.TMeter' = ...
    SENSOR_B: 'CryoCon22C.TMeter' = ...
    HEATER_1: 'CryoCon22C.Heater' = ...
    HEATER_2: 'CryoCon22C.Heater' = ...
    HEATER_3: 'CryoCon22C.Heater' = ...
    HEATER_4: 'CryoCon22C.Heater' = ...
    LOOP_1: 'CryoCon22C.Loop' = ...
    LOOP_2: 'CryoCon22C.Loop' = ...
    LOOP_3: 'CryoCon22C.Loop' = ...
    LOOP_4: 'CryoCon22C.Loop' = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getInputs(self) -> java.util.List['CryoCon22C.TMeter']: ...
    def getLoops(self) -> java.util.List['CryoCon22C.Loop']: ...
    def getOutputs(self) -> java.util.List['CryoCon22C.Heater']: ...
    class Heater(jisa.devices.interfaces.TC.Heater):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getNumber(self) -> int: ...
        def getValue(self) -> float: ...
        def setLimit(self, double: float) -> None: ...
    class Loop(jisa.devices.interfaces.TC.ZonedLoop):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAvailableInputs(self) -> java.util.List['CryoCon22C.TMeter']: ...
        def getAvailableOutputs(self) -> java.util.List['CryoCon22C.Heater']: ...
        def getDValue(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIValue(self) -> float: ...
        def getInput(self) -> jisa.devices.interfaces.PID.Input: ...
        def getManualValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOutput(self) -> 'CryoCon22C.Heater': ...
        def getPValue(self) -> float: ...
        def getRampRate(self) -> float: ...
        def getSetPoint(self) -> float: ...
        def isPIDEnabled(self) -> bool: ...
        def isRampEnabled(self) -> bool: ...
        def setDValue(self, double: float) -> None: ...
        def setIValue(self, double: float) -> None: ...
        def setInput(self, input: jisa.devices.interfaces.PID.Input) -> None: ...
        def setManualValue(self, double: float) -> None: ...
        def setOutput(self, output: jisa.devices.interfaces.PID.Output) -> None: ...
        def setPIDEnabled(self, boolean: bool) -> None: ...
        def setPValue(self, double: float) -> None: ...
        def setRampEnabled(self, boolean: bool) -> None: ...
        def setRampRate(self, double: float) -> None: ...
        def setSetPoint(self, double: float) -> None: ...
    class TMeter(jisa.devices.interfaces.TC.TMeter):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getSensor(self) -> str: ...
        def getSensorName(self) -> str: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setTemperatureRange(self, double: float) -> None: ...

class ET2408(jisa.visa.ModbusRTUDevice, jisa.devices.interfaces.TC):
    THERMOMETER: jisa.devices.interfaces.TC.TMeter = ...
    HEATER: jisa.devices.interfaces.TC.Heater = ...
    LOOP: jisa.devices.interfaces.TC.Loop = ...
    @typing.overload
    def __init__(self, address: jisa.addresses.Address): ...
    @typing.overload
    def __init__(self, address: jisa.addresses.Address, baudRate: com.intelligt.modbus.jlibmodbus.serial.SerialPort.BaudRate, int: int, int2: int, parity: com.intelligt.modbus.jlibmodbus.serial.SerialPort.Parity): ...
    @staticmethod
    def getDescription() -> str: ...
    def getInputs(self) -> java.util.List[jisa.devices.interfaces.TC.TMeter]: ...
    def getLoops(self) -> java.util.List[jisa.devices.interfaces.TC.Loop]: ...
    def getName(self) -> str: ...
    def getOutputs(self) -> java.util.List[jisa.devices.interfaces.TC.Heater]: ...

class FakeTC(jisa.devices.interfaces.TC):
    def __init__(self, address: jisa.addresses.Address): ...
    def close(self) -> None: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIDN(self) -> str: ...
    def getInputs(self) -> java.util.List[jisa.devices.interfaces.TC.TMeter]: ...
    def getLoops(self) -> java.util.List[jisa.devices.interfaces.TC.Loop]: ...
    def getName(self) -> str: ...
    def getOutputs(self) -> java.util.List[jisa.devices.interfaces.TC.Heater]: ...

class ITC503(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    heater: jisa.devices.interfaces.TC.Heater = ...
    loop: jisa.devices.interfaces.TC.ZonedLoop = ...
    def __init__(self, address: jisa.addresses.Address): ...
    def getChannelFrequency(self, int: int) -> float: ...
    @typing.overload
    def getConfigurationParameters(self, kClass: kotlin.reflect.KClass[typing.Any]) -> java.util.List[jisa.devices.interfaces.Instrument.Parameter[typing.Any]]: ...
    @typing.overload
    def getConfigurationParameters(self, class_: typing.Type[typing.Any]) -> java.util.List[jisa.devices.interfaces.Instrument.Parameter[typing.Any]]: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIDN(self) -> str: ...
    def getInputs(self) -> java.util.List['ITC503.TMeter']: ...
    def getLoops(self) -> java.util.List[jisa.devices.interfaces.TC.Loop]: ...
    def getOutputs(self) -> java.util.List[jisa.devices.interfaces.TC.Heater]: ...
    def setMode(self, mode: 'ITC503.Mode') -> None: ...
    def setTimeout(self, int: int) -> None: ...
    class Mode(java.lang.Enum['ITC503.Mode']):
        LOCAL_LOCKED: typing.ClassVar['ITC503.Mode'] = ...
        REMOTE_LOCKED: typing.ClassVar['ITC503.Mode'] = ...
        LOCAL_UNLOCKED: typing.ClassVar['ITC503.Mode'] = ...
        REMOTE_UNLOCKED: typing.ClassVar['ITC503.Mode'] = ...
        def toInt(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ITC503.Mode': ...
        @staticmethod
        def values() -> typing.MutableSequence['ITC503.Mode']: ...
    class TMeter(jisa.devices.interfaces.TC.TMeter):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getNumber(self) -> int: ...
        def getSensorName(self) -> str: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setTemperatureRange(self, double: float) -> None: ...

class LS331(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    INPUT_A: 'LS331.TMeter' = ...
    INPUT_B: 'LS331.TMeter' = ...
    OUTPUT_1: 'LS331.Heater' = ...
    OUTPUT_2: 'LS331.Analogue' = ...
    LOOP_1: 'LS331.Loop' = ...
    LOOP_2: 'LS331.Loop' = ...
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getInputs(self) -> java.util.List[jisa.devices.interfaces.PID.Input]: ...
    def getLoops(self) -> java.util.List['LS331.Loop']: ...
    def getOutputs(self) -> java.util.List[jisa.devices.interfaces.PID.Output]: ...
    class Analogue(jisa.devices.interfaces.PID.Output):
        def __init__(self, lS331: 'LS331'): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> float: ...
        def getValueName(self) -> str: ...
        def setLimit(self, double: float) -> None: ...
    class Heater(jisa.devices.interfaces.TC.Heater):
        def __init__(self, lS331: 'LS331'): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getValue(self) -> float: ...
        def setLimit(self, double: float) -> None: ...
    class Loop(jisa.devices.interfaces.TC.ZonedLoop):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAvailableInputs(self) -> java.util.List[jisa.devices.interfaces.PID.Input]: ...
        def getAvailableOutputs(self) -> java.util.List[jisa.devices.interfaces.PID.Output]: ...
        def getDValue(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIValue(self) -> float: ...
        def getInput(self) -> 'LS331.TMeter': ...
        def getManualValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOutput(self) -> jisa.devices.interfaces.PID.Output: ...
        def getPValue(self) -> float: ...
        def getRampRate(self) -> float: ...
        def getSetPoint(self) -> float: ...
        def isPIDEnabled(self) -> bool: ...
        def isRampEnabled(self) -> bool: ...
        def setDValue(self, double: float) -> None: ...
        def setIValue(self, double: float) -> None: ...
        def setInput(self, input: jisa.devices.interfaces.PID.Input) -> None: ...
        def setManualValue(self, double: float) -> None: ...
        def setOutput(self, output: jisa.devices.interfaces.PID.Output) -> None: ...
        def setPIDEnabled(self, boolean: bool) -> None: ...
        def setPValue(self, double: float) -> None: ...
        def setRampEnabled(self, boolean: bool) -> None: ...
        def setRampRate(self, double: float) -> None: ...
        def setSetPoint(self, double: float) -> None: ...
    class TMeter(jisa.devices.interfaces.TC.TMeter):
        def __init__(self, lS331: 'LS331', string: str): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLabel(self) -> str: ...
        def getName(self) -> str: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setTemperatureRange(self, double: float) -> None: ...

class LS336(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    def __init__(self, address: jisa.addresses.Address): ...
    @staticmethod
    def getDescription() -> str: ...
    def getHeaters(self) -> java.util.List['LS336.Heater']: ...
    def getInputs(self) -> java.util.List['LS336.TMeter']: ...
    def getLoops(self) -> java.util.List['LS336.Loop']: ...
    def getOutputs(self) -> java.util.List['LS336.Heater']: ...
    def getThermometers(self) -> java.util.List['LS336.TMeter']: ...
    class Heater(jisa.devices.interfaces.TC.Heater):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getNumber(self) -> int: ...
        def getValue(self) -> float: ...
        def setLimit(self, double: float) -> None: ...
    class Loop(jisa.devices.interfaces.TC.ZonedLoop):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAvailableInputs(self) -> java.util.List[jisa.devices.interfaces.PID.Input]: ...
        def getAvailableOutputs(self) -> java.util.List[jisa.devices.interfaces.PID.Output]: ...
        def getDValue(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIValue(self) -> float: ...
        def getInput(self) -> 'LS336.TMeter': ...
        def getManualValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOutput(self) -> 'LS336.Heater': ...
        def getPID(self) -> 'LS336.PIDValue': ...
        def getPValue(self) -> float: ...
        def getRampRate(self) -> float: ...
        def getSetPoint(self) -> float: ...
        def isPIDEnabled(self) -> bool: ...
        def isRampEnabled(self) -> bool: ...
        def setDValue(self, double: float) -> None: ...
        def setIValue(self, double: float) -> None: ...
        def setInput(self, input: jisa.devices.interfaces.PID.Input) -> None: ...
        def setManualValue(self, double: float) -> None: ...
        def setOutput(self, output: jisa.devices.interfaces.PID.Output) -> None: ...
        def setPIDEnabled(self, boolean: bool) -> None: ...
        def setPIDValues(self, double: float, double2: float, double3: float) -> None: ...
        def setPValue(self, double: float) -> None: ...
        def setRampEnabled(self, boolean: bool) -> None: ...
        def setRampRate(self, double: float) -> None: ...
        def setSetPoint(self, double: float) -> None: ...
    class TMeter(jisa.devices.interfaces.TC.TMeter):
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLetter(self) -> str: ...
        def getName(self) -> str: ...
        def getNumber(self) -> int: ...
        def getSensorName(self) -> str: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setTemperatureRange(self, double: float) -> None: ...
    class PIDValue: ...

class USBTC08(jisa.visa.NativeDevice['USBTC08.NativeInterface'], jisa.devices.interfaces.MSTMeter['USBTC08.TC08TMeter']):
    CHANNEL_0: 'USBTC08.TC08TMeter' = ...
    CHANNEL_1: 'USBTC08.TC08TMeter' = ...
    CHANNEL_2: 'USBTC08.TC08TMeter' = ...
    CHANNEL_3: 'USBTC08.TC08TMeter' = ...
    CHANNEL_4: 'USBTC08.TC08TMeter' = ...
    CHANNEL_5: 'USBTC08.TC08TMeter' = ...
    CHANNEL_6: 'USBTC08.TC08TMeter' = ...
    CHANNEL_7: 'USBTC08.TC08TMeter' = ...
    CHANNEL_8: 'USBTC08.TC08TMeter' = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, address: jisa.addresses.Address): ...
    def close(self) -> None: ...
    @staticmethod
    def findUnits() -> java.util.List['USBTC08']: ...
    def getAddress(self) -> jisa.addresses.Address: ...
    @staticmethod
    def getDescription() -> str: ...
    def getIDN(self) -> str: ...
    def getLineFrequency(self) -> 'USBTC08.Frequency': ...
    def getName(self) -> str: ...
    def getSerial(self) -> str: ...
    def getTemperatureRange(self, int: int) -> float: ...
    def getTemperatures(self, *tC08TMeter: 'USBTC08.TC08TMeter') -> java.util.Map['USBTC08.TC08TMeter', float]: ...
    def getThermometers(self) -> java.util.List['USBTC08.TC08TMeter']: ...
    def setLineFrequency(self, frequency: 'USBTC08.Frequency') -> None: ...
    class Frequency(java.lang.Enum['USBTC08.Frequency']):
        FIFTY_HERTZ: typing.ClassVar['USBTC08.Frequency'] = ...
        SIXTY_HERTZ: typing.ClassVar['USBTC08.Frequency'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'USBTC08.Frequency': ...
        @staticmethod
        def values() -> typing.MutableSequence['USBTC08.Frequency']: ...
    class TC08TMeter(jisa.devices.interfaces.TCouple):
        def __init__(self, uSBTC08: 'USBTC08', int: int): ...
        def close(self) -> None: ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getSensorType(self) -> jisa.devices.interfaces.TCouple.Type: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setSensorType(self, type: jisa.devices.interfaces.TCouple.Type) -> None: ...
        def setTemperatureRange(self, double: float) -> None: ...

class MercuryITC(jisa.visa.VISADevice, jisa.devices.interfaces.TC):
    def __init__(self, address: jisa.addresses.Address): ...
    def getInputs(self) -> java.util.List['MercuryITC.TMeter']: ...
    def getLoops(self) -> java.util.List['MercuryITC.Loop']: ...
    def getOutputs(self) -> java.util.List['MercuryITC.Heater']: ...
    def readITC(self, *string: str) -> typing.MutableSequence[str]: ...
    def writeITC(self, *string: str) -> typing.MutableSequence[str]: ...
    class AuxOutput(jisa.devices.temperature.MercuryITC.Component, jisa.devices.interfaces.PID.Output):
        def __init__(self, mercuryITC: 'MercuryITC', string: str): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getUnits(self) -> str: ...
        def getValue(self) -> float: ...
        def getValueName(self) -> str: ...
        def setLimit(self, double: float) -> None: ...
    class Heater(jisa.devices.temperature.MercuryITC.Component, jisa.devices.interfaces.TC.Heater):
        def __init__(self, mercuryITC: 'MercuryITC', string: str): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getLimit(self) -> float: ...
        def getName(self) -> str: ...
        def getValue(self) -> float: ...
        def setLimit(self, double: float) -> None: ...
    class Loop(jisa.devices.interfaces.TC.ZonedLoop):
        def __init__(self, mercuryITC: 'MercuryITC', tMeter: 'MercuryITC.TMeter'): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getAvailableInputs(self) -> java.util.List['MercuryITC.TMeter']: ...
        def getAvailableOutputs(self) -> java.util.List['MercuryITC.Heater']: ...
        def getDValue(self) -> float: ...
        def getIDN(self) -> str: ...
        def getIValue(self) -> float: ...
        def getInput(self) -> 'MercuryITC.TMeter': ...
        def getManualValue(self) -> float: ...
        def getName(self) -> str: ...
        def getOutput(self) -> 'MercuryITC.Heater': ...
        def getPValue(self) -> float: ...
        def getRampRate(self) -> float: ...
        def getSetPoint(self) -> float: ...
        def isPIDEnabled(self) -> bool: ...
        def isRampEnabled(self) -> bool: ...
        def setDValue(self, double: float) -> None: ...
        def setIValue(self, double: float) -> None: ...
        def setInput(self, input: jisa.devices.interfaces.PID.Input) -> None: ...
        def setManualValue(self, double: float) -> None: ...
        def setOutput(self, output: jisa.devices.interfaces.PID.Output) -> None: ...
        def setPIDEnabled(self, boolean: bool) -> None: ...
        def setPValue(self, double: float) -> None: ...
        def setRampEnabled(self, boolean: bool) -> None: ...
        def setRampRate(self, double: float) -> None: ...
        def setSetPoint(self, double: float) -> None: ...
    class TMeter(jisa.devices.temperature.MercuryITC.Component, jisa.devices.interfaces.TC.TMeter):
        def __init__(self, mercuryITC: 'MercuryITC', string: str): ...
        def getAddress(self) -> jisa.addresses.Address: ...
        def getIDN(self) -> str: ...
        def getName(self) -> str: ...
        def getTemperature(self) -> float: ...
        def getTemperatureRange(self) -> float: ...
        def setTemperatureRange(self, double: float) -> None: ...
    class Component: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.devices.temperature")``.

    ArroyoTEC: typing.Type[ArroyoTEC]
    CryoCon22C: typing.Type[CryoCon22C]
    ET2408: typing.Type[ET2408]
    FakeTC: typing.Type[FakeTC]
    ITC503: typing.Type[ITC503]
    LS331: typing.Type[LS331]
    LS336: typing.Type[LS336]
    MercuryITC: typing.Type[MercuryITC]
    USBTC08: typing.Type[USBTC08]
