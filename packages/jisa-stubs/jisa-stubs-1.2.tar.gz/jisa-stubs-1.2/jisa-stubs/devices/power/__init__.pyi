
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import jisa.addresses
import jisa.devices.interfaces
import jisa.visa
import typing



class AgilentE3644A(jisa.visa.VISADevice, jisa.devices.interfaces.DCPower):
    def __init__(self, address: jisa.addresses.Address): ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def isOn(self) -> bool: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...

class IPS120(jisa.visa.VISADevice, jisa.devices.interfaces.EMController):
    def __init__(self, address: jisa.addresses.Address): ...
    def getActivity(self) -> 'IPS120.Activity': ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getField(self) -> float: ...
    def getMagnetCurrent(self) -> float: ...
    def getPersistentCurrent(self) -> float: ...
    def getRampRates(self) -> java.util.List[jisa.devices.interfaces.EMController.Ramp]: ...
    def isStable(self) -> bool: ...
    def setActivity(self, activity: 'IPS120.Activity') -> None: ...
    def setCurrent(self, double: float) -> None: ...
    def setField(self, double: float) -> None: ...
    def setHeater(self, boolean: bool) -> None: ...
    def setMode(self, mode: 'IPS120.Mode') -> None: ...
    def setRampRates(self, *ramp: jisa.devices.interfaces.EMController.Ramp) -> None: ...
    def turnOff(self) -> None: ...
    def waitUntilStable(self) -> None: ...
    class Activity(java.lang.Enum['IPS120.Activity']):
        HOLD: typing.ClassVar['IPS120.Activity'] = ...
        GO_SETPOINT: typing.ClassVar['IPS120.Activity'] = ...
        GO_ZERO: typing.ClassVar['IPS120.Activity'] = ...
        UNK: typing.ClassVar['IPS120.Activity'] = ...
        CLAMP: typing.ClassVar['IPS120.Activity'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'IPS120.Activity': ...
        @staticmethod
        def values() -> typing.MutableSequence['IPS120.Activity']: ...
    class CStatus(java.lang.Enum['IPS120.CStatus']):
        LOCAL_LOCKED: typing.ClassVar['IPS120.CStatus'] = ...
        REMOTE_LOCKED: typing.ClassVar['IPS120.CStatus'] = ...
        LOCAL_UNLOCKED: typing.ClassVar['IPS120.CStatus'] = ...
        REMOTE_UNLOCKED: typing.ClassVar['IPS120.CStatus'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'IPS120.CStatus': ...
        @staticmethod
        def values() -> typing.MutableSequence['IPS120.CStatus']: ...
    class HeaterState(java.lang.Enum['IPS120.HeaterState']):
        OFF_ZERO: typing.ClassVar['IPS120.HeaterState'] = ...
        ON: typing.ClassVar['IPS120.HeaterState'] = ...
        OFF_NOT_ZERO: typing.ClassVar['IPS120.HeaterState'] = ...
        HEATER_FAULT: typing.ClassVar['IPS120.HeaterState'] = ...
        NO_SWITCH_FITTED: typing.ClassVar['IPS120.HeaterState'] = ...
        code: int = ...
        @staticmethod
        def fromCode(int: int) -> 'IPS120.HeaterState': ...
        def getCode(self) -> int: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'IPS120.HeaterState': ...
        @staticmethod
        def values() -> typing.MutableSequence['IPS120.HeaterState']: ...
    class Mode(java.lang.Enum['IPS120.Mode']):
        LOCAL_LOCKED: typing.ClassVar['IPS120.Mode'] = ...
        REMOTE_LOCKED: typing.ClassVar['IPS120.Mode'] = ...
        LOCAL_UNLOCKED: typing.ClassVar['IPS120.Mode'] = ...
        REMOTE_UNLOCKED: typing.ClassVar['IPS120.Mode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'IPS120.Mode': ...
        @staticmethod
        def values() -> typing.MutableSequence['IPS120.Mode']: ...

class K2200(jisa.visa.VISADevice, jisa.devices.interfaces.DCPower):
    def __init__(self, address: jisa.addresses.Address): ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def isOn(self) -> bool: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...

class TSX3510P(jisa.visa.VISADevice, jisa.devices.interfaces.DCPower):
    def __init__(self, address: jisa.addresses.Address): ...
    def decreaseI(self) -> None: ...
    def getCurrent(self) -> float: ...
    @staticmethod
    def getDescription() -> str: ...
    def getSetCurrent(self) -> float: ...
    def getSetVoltage(self) -> float: ...
    def getVoltage(self) -> float: ...
    def getVoltageLimit(self) -> float: ...
    def increaseI(self) -> None: ...
    def isOn(self) -> bool: ...
    def setCurrent(self, double: float) -> None: ...
    def setCurrentLimit(self, double: float) -> None: ...
    def setDeltaI(self, double: float) -> None: ...
    def setVoltage(self, double: float) -> None: ...
    def setVoltageLimit(self, double: float) -> None: ...
    def turnOff(self) -> None: ...
    def turnOn(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.devices.power")``.

    AgilentE3644A: typing.Type[AgilentE3644A]
    IPS120: typing.Type[IPS120]
    K2200: typing.Type[K2200]
    TSX3510P: typing.Type[TSX3510P]
