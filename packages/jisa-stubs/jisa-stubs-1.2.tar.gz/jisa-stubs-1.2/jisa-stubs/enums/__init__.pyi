
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.net
import javafx.scene.image
import javafx.scene.paint
import typing



class AMode(java.lang.Enum['AMode']):
    NONE: typing.ClassVar['AMode'] = ...
    MEAN_REPEAT: typing.ClassVar['AMode'] = ...
    MEAN_MOVING: typing.ClassVar['AMode'] = ...
    MEDIAN_REPEAT: typing.ClassVar['AMode'] = ...
    MEDIAN_MOVING: typing.ClassVar['AMode'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'AMode': ...
    @staticmethod
    def values() -> typing.MutableSequence['AMode']: ...

class Coupling(java.lang.Enum['Coupling']):
    AC: typing.ClassVar['Coupling'] = ...
    DC: typing.ClassVar['Coupling'] = ...
    GROUND: typing.ClassVar['Coupling'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Coupling': ...
    @staticmethod
    def values() -> typing.MutableSequence['Coupling']: ...

class Filter(java.lang.Enum['Filter']):
    NONE: typing.ClassVar['Filter'] = ...
    HIGH_PASS: typing.ClassVar['Filter'] = ...
    LOW_PASS: typing.ClassVar['Filter'] = ...
    BAND_PASS: typing.ClassVar['Filter'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Filter': ...
    @staticmethod
    def values() -> typing.MutableSequence['Filter']: ...

class Function(java.lang.Enum['Function']):
    VOLT: typing.ClassVar['Function'] = ...
    CURR: typing.ClassVar['Function'] = ...
    RES: typing.ClassVar['Function'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Function': ...
    @staticmethod
    def values() -> typing.MutableSequence['Function']: ...

class Icon(java.lang.Enum['Icon']):
    FLASK: typing.ClassVar['Icon'] = ...
    CLOCK: typing.ClassVar['Icon'] = ...
    REPEAT: typing.ClassVar['Icon'] = ...
    DEVICE: typing.ClassVar['Icon'] = ...
    DASHBOARD: typing.ClassVar['Icon'] = ...
    PLOT: typing.ClassVar['Icon'] = ...
    DATA: typing.ClassVar['Icon'] = ...
    VOLTMETER: typing.ClassVar['Icon'] = ...
    THERMOMETER: typing.ClassVar['Icon'] = ...
    SNOWFLAKE: typing.ClassVar['Icon'] = ...
    LIGHTBULB: typing.ClassVar['Icon'] = ...
    WIFI: typing.ClassVar['Icon'] = ...
    CONNECTION: typing.ClassVar['Icon'] = ...
    MAGNET: typing.ClassVar['Icon'] = ...
    WAVE: typing.ClassVar['Icon'] = ...
    COGS: typing.ClassVar['Icon'] = ...
    DIODE: typing.ClassVar['Icon'] = ...
    TRANSISTOR: typing.ClassVar['Icon'] = ...
    RHEOSTAT: typing.ClassVar['Icon'] = ...
    LED: typing.ClassVar['Icon'] = ...
    RESISTOR: typing.ClassVar['Icon'] = ...
    HALL: typing.ClassVar['Icon'] = ...
    ELECTRICITY: typing.ClassVar['Icon'] = ...
    CIRCLES: typing.ClassVar['Icon'] = ...
    def getBlackImage(self) -> javafx.scene.image.Image: ...
    def getColouredImage(self, color: javafx.scene.paint.Color) -> javafx.scene.image.Image: ...
    def getURL(self) -> java.net.URL: ...
    def getWhiteImage(self) -> javafx.scene.image.Image: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Icon': ...
    @staticmethod
    def values() -> typing.MutableSequence['Icon']: ...

class Impedance(java.lang.Enum['Impedance']):
    HIGH: typing.ClassVar['Impedance'] = ...
    LOW: typing.ClassVar['Impedance'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Impedance': ...
    @staticmethod
    def values() -> typing.MutableSequence['Impedance']: ...

class Input(java.lang.Enum['Input']):
    A: typing.ClassVar['Input'] = ...
    B: typing.ClassVar['Input'] = ...
    DIFF: typing.ClassVar['Input'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Input': ...
    @staticmethod
    def values() -> typing.MutableSequence['Input']: ...

class LineFilter(java.lang.Enum['LineFilter']):
    NONE: typing.ClassVar['LineFilter'] = ...
    X1: typing.ClassVar['LineFilter'] = ...
    X2: typing.ClassVar['LineFilter'] = ...
    X1_X2: typing.ClassVar['LineFilter'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'LineFilter': ...
    @staticmethod
    def values() -> typing.MutableSequence['LineFilter']: ...

class OscMode(java.lang.Enum['OscMode']):
    FREQUENCY: typing.ClassVar['OscMode'] = ...
    PERIOD: typing.ClassVar['OscMode'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'OscMode': ...
    @staticmethod
    def values() -> typing.MutableSequence['OscMode']: ...

class Shield(java.lang.Enum['Shield']):
    GROUND: typing.ClassVar['Shield'] = ...
    FLOAT: typing.ClassVar['Shield'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Shield': ...
    @staticmethod
    def values() -> typing.MutableSequence['Shield']: ...

class Source(java.lang.Enum['Source']):
    VOLTAGE: typing.ClassVar['Source'] = ...
    CURRENT: typing.ClassVar['Source'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Source': ...
    @staticmethod
    def values() -> typing.MutableSequence['Source']: ...

class TType(java.lang.Enum['TType']):
    TRIAX: typing.ClassVar['TType'] = ...
    PHOENIX: typing.ClassVar['TType'] = ...
    BNC: typing.ClassVar['TType'] = ...
    BANANA: typing.ClassVar['TType'] = ...
    NONE: typing.ClassVar['TType'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'TType': ...
    @staticmethod
    def values() -> typing.MutableSequence['TType']: ...

class Terminals(java.lang.Enum['Terminals']):
    FRONT: typing.ClassVar['Terminals'] = ...
    REAR: typing.ClassVar['Terminals'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Terminals': ...
    @staticmethod
    def values() -> typing.MutableSequence['Terminals']: ...

class WaveForm(java.lang.Enum['WaveForm']):
    SIN: typing.ClassVar['WaveForm'] = ...
    SQU: typing.ClassVar['WaveForm'] = ...
    RAMP: typing.ClassVar['WaveForm'] = ...
    PULS: typing.ClassVar['WaveForm'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'WaveForm': ...
    @staticmethod
    def values() -> typing.MutableSequence['WaveForm']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.enums")``.

    AMode: typing.Type[AMode]
    Coupling: typing.Type[Coupling]
    Filter: typing.Type[Filter]
    Function: typing.Type[Function]
    Icon: typing.Type[Icon]
    Impedance: typing.Type[Impedance]
    Input: typing.Type[Input]
    LineFilter: typing.Type[LineFilter]
    OscMode: typing.Type[OscMode]
    Shield: typing.Type[Shield]
    Source: typing.Type[Source]
    TType: typing.Type[TType]
    Terminals: typing.Type[Terminals]
    WaveForm: typing.Type[WaveForm]
