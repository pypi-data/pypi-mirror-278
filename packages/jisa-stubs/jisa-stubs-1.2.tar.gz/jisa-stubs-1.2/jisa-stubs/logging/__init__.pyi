
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.time
import java.util
import java.util.regex
import typing



class Log(java.lang.Iterable['LogEntry']):
    def __init__(self, string: str): ...
    def addDebug(self, string: str) -> None: ...
    @typing.overload
    def addEntry(self, localDateTime: java.time.LocalDateTime, level: 'LogEntry.Level', string: str) -> None: ...
    @typing.overload
    def addEntry(self, level: 'LogEntry.Level', string: str) -> None: ...
    @typing.overload
    def addEntry(self, logEntry: 'LogEntry') -> None: ...
    def addError(self, string: str) -> None: ...
    def addFatal(self, string: str) -> None: ...
    def addMessage(self, string: str) -> None: ...
    def addWarning(self, string: str) -> None: ...
    def close(self) -> None: ...
    def iterator(self) -> java.util.Iterator['LogEntry']: ...

class LogEntry:
    LINE_PATTERN: typing.ClassVar[java.util.regex.Pattern] = ...
    @typing.overload
    def __init__(self, localDateTime: java.time.LocalDateTime, level: 'LogEntry.Level', string: str): ...
    @typing.overload
    def __init__(self, level: 'LogEntry.Level', string: str): ...
    @staticmethod
    def fromString(string: str) -> 'LogEntry': ...
    def getLevel(self) -> 'LogEntry.Level': ...
    def getMessage(self) -> str: ...
    def getTime(self) -> java.time.LocalDateTime: ...
    def toString(self) -> str: ...
    class Level(java.lang.Enum['LogEntry.Level']):
        DEBUG: typing.ClassVar['LogEntry.Level'] = ...
        MESSAGE: typing.ClassVar['LogEntry.Level'] = ...
        WARNING: typing.ClassVar['LogEntry.Level'] = ...
        ERROR: typing.ClassVar['LogEntry.Level'] = ...
        FATAL: typing.ClassVar['LogEntry.Level'] = ...
        @staticmethod
        def fromCode(string: str) -> 'LogEntry.Level': ...
        def getCode(self) -> str: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'LogEntry.Level': ...
        @staticmethod
        def values() -> typing.MutableSequence['LogEntry.Level']: ...

class Logger:
    def __init__(self): ...
    @staticmethod
    def addDebug(string: str) -> None: ...
    @typing.overload
    @staticmethod
    def addEntry(localDateTime: java.time.LocalDateTime, level: LogEntry.Level, string: str) -> None: ...
    @typing.overload
    @staticmethod
    def addEntry(level: LogEntry.Level, string: str) -> None: ...
    @typing.overload
    @staticmethod
    def addEntry(logEntry: LogEntry) -> None: ...
    @staticmethod
    def addError(string: str) -> None: ...
    @staticmethod
    def addFatal(string: str) -> None: ...
    @staticmethod
    def addMessage(string: str) -> None: ...
    @staticmethod
    def addWarning(string: str) -> None: ...
    @staticmethod
    def close() -> None: ...
    @staticmethod
    def getCurrentLog() -> Log: ...
    @staticmethod
    def start(string: str) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.logging")``.

    Log: typing.Type[Log]
    LogEntry: typing.Type[LogEntry]
    Logger: typing.Type[Logger]
