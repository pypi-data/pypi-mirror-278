
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import javafx.scene.chart
import jisa.maths.functions
import jisa.results
import jpype
import org.apache.commons.math.analysis
import org.apache.commons.math.optimization
import org.apache.commons.math.optimization.fitting
import typing



class Fit:
    def getError(self, int: int) -> float: ...
    def getErrors(self) -> typing.MutableSequence[float]: ...
    def getFunction(self) -> jisa.maths.functions.Function: ...
    def getParameter(self, int: int) -> float: ...
    def getParameters(self) -> typing.MutableSequence[float]: ...

class Fitter:
    def __init__(self, pFunction: typing.Union[jisa.maths.functions.PFunction, typing.Callable]): ...
    @typing.overload
    def addPoint(self, double: float, double2: float) -> None: ...
    @typing.overload
    def addPoint(self, double: float, double2: float, double3: float) -> None: ...
    @typing.overload
    def addPoints(self, collection: typing.Union[java.util.Collection['Fitter.Point'], typing.Sequence['Fitter.Point'], typing.Set['Fitter.Point']]) -> None: ...
    @typing.overload
    def addPoints(self, *point: 'Fitter.Point') -> None: ...
    def clearPoints(self) -> None: ...
    @staticmethod
    def estimateErrors(multivariateRealFunction: typing.Union[org.apache.commons.math.analysis.MultivariateRealFunction, typing.Callable], doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int) -> typing.MutableSequence[float]: ...
    def fit(self) -> Fit: ...
    def getAbsoluteTolerance(self) -> float: ...
    def getFunction(self) -> jisa.maths.functions.PFunction: ...
    def getMaxEvaluations(self) -> int: ...
    def getMaxIterations(self) -> int: ...
    def getMaxLimits(self) -> typing.MutableSequence[float]: ...
    def getMinLimits(self) -> typing.MutableSequence[float]: ...
    def getPoints(self) -> java.util.List['Fitter.Point']: ...
    def getRelativeTolerance(self) -> float: ...
    def getStart(self) -> typing.MutableSequence[float]: ...
    def setAbsoluteTolerance(self, double: float) -> None: ...
    def setLimits(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setMaxEvaluations(self, int: int) -> None: ...
    def setMaxIterations(self, int: int) -> None: ...
    def setMaxLimits(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setMinLimits(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def setPoints(self, collection: typing.Union[java.util.Collection['Fitter.Point'], typing.Sequence['Fitter.Point'], typing.Set['Fitter.Point']]) -> None: ...
    @typing.overload
    def setPoints(self, *point: 'Fitter.Point') -> None: ...
    def setRelativeTolerance(self, double: float) -> None: ...
    def setStart(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    class Point:
        x: float = ...
        y: float = ...
        w: float = ...
        def __init__(self, double: float, double2: float, double3: float): ...

class Fitting:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def cosFit(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'CosFit': ...
    @typing.overload
    @staticmethod
    def cosFit(list: java.util.List[javafx.scene.chart.XYChart.Data[float, float]]) -> 'CosFit': ...
    @typing.overload
    @staticmethod
    def cosFit(resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]) -> 'CosFit': ...
    @typing.overload
    @staticmethod
    def fit(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], pFunction: typing.Union[jisa.maths.functions.PFunction, typing.Callable], *double: float) -> Fit: ...
    @typing.overload
    @staticmethod
    def fit(list: java.util.List[javafx.scene.chart.XYChart.Data[float, float]], pFunction: typing.Union[jisa.maths.functions.PFunction, typing.Callable], *double: float) -> Fit: ...
    @typing.overload
    @staticmethod
    def fit(resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], pFunction: typing.Union[jisa.maths.functions.PFunction, typing.Callable], *double: float) -> Fit: ...
    @typing.overload
    @staticmethod
    def gaussianFit(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'GaussianFit': ...
    @typing.overload
    @staticmethod
    def gaussianFit(list: java.util.List[javafx.scene.chart.XYChart.Data[float, float]]) -> 'GaussianFit': ...
    @typing.overload
    @staticmethod
    def gaussianFit(resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]) -> 'GaussianFit': ...
    @typing.overload
    @staticmethod
    def linearFit(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'LinearFit': ...
    @typing.overload
    @staticmethod
    def linearFit(list: java.util.List[javafx.scene.chart.XYChart.Data[float, float]]) -> 'LinearFit': ...
    @typing.overload
    @staticmethod
    def linearFit(resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number]) -> 'LinearFit': ...
    @staticmethod
    def linearFitWeighted(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]]) -> 'LinearFit': ...
    @typing.overload
    @staticmethod
    def polyFit(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], int: int) -> 'PolyFit': ...
    @typing.overload
    @staticmethod
    def polyFit(list: java.util.List[javafx.scene.chart.XYChart.Data[float, float]], int: int) -> 'PolyFit': ...
    @typing.overload
    @staticmethod
    def polyFit(resultTable: jisa.results.ResultTable, column: jisa.results.Column[java.lang.Number], column2: jisa.results.Column[java.lang.Number], int: int) -> 'PolyFit': ...
    @staticmethod
    def polyFitWeighted(iterable: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable2: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], iterable3: typing.Union[java.lang.Iterable[float], typing.Sequence[float], typing.Set[float], typing.Callable[[], java.util.Iterator[typing.Any]]], int: int) -> 'PolyFit': ...
    @staticmethod
    def toPRFunction(pFunction: typing.Union[jisa.maths.functions.PFunction, typing.Callable]) -> org.apache.commons.math.optimization.fitting.ParametricRealFunction: ...

class JISAConvergenceChecker(org.apache.commons.math.optimization.SimpleRealPointChecker):
    def __init__(self): ...
    def converged(self, int: int, realPointValuePair: org.apache.commons.math.optimization.RealPointValuePair, realPointValuePair2: org.apache.commons.math.optimization.RealPointValuePair) -> bool: ...

class CosFit(Fit):
    def __init__(self, harmonicFunction: org.apache.commons.math.optimization.fitting.HarmonicFunction): ...
    def getAmplitude(self) -> float: ...
    def getAngFrequency(self) -> float: ...
    def getError(self, int: int) -> float: ...
    def getErrors(self) -> typing.MutableSequence[float]: ...
    def getFunction(self) -> jisa.maths.functions.Function: ...
    def getParameter(self, int: int) -> float: ...
    def getParameters(self) -> typing.MutableSequence[float]: ...
    def getPhase(self) -> float: ...

class GaussianFit(Fit):
    def __init__(self, gaussianFunction: org.apache.commons.math.optimization.fitting.GaussianFunction): ...
    def getAmplitude(self) -> float: ...
    def getDeviation(self) -> float: ...
    def getError(self, int: int) -> float: ...
    def getErrors(self) -> typing.MutableSequence[float]: ...
    def getFunction(self) -> jisa.maths.functions.Function: ...
    def getOffset(self) -> float: ...
    def getParameter(self, int: int) -> float: ...
    def getParameters(self) -> typing.MutableSequence[float]: ...
    def getPosition(self) -> float: ...

class PolyFit(Fit):
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]): ...
    def getError(self, int: int) -> float: ...
    def getErrors(self) -> typing.MutableSequence[float]: ...
    def getFunction(self) -> jisa.maths.functions.Function: ...
    def getParameter(self, int: int) -> float: ...
    def getParameters(self) -> typing.MutableSequence[float]: ...

class LinearFit(PolyFit):
    def __init__(self, polyFit: PolyFit): ...
    def getGradient(self) -> float: ...
    def getGradientError(self) -> float: ...
    def getIntercept(self) -> float: ...
    def getInterceptError(self) -> float: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jisa.maths.fits")``.

    CosFit: typing.Type[CosFit]
    Fit: typing.Type[Fit]
    Fitter: typing.Type[Fitter]
    Fitting: typing.Type[Fitting]
    GaussianFit: typing.Type[GaussianFit]
    JISAConvergenceChecker: typing.Type[JISAConvergenceChecker]
    LinearFit: typing.Type[LinearFit]
    PolyFit: typing.Type[PolyFit]
